# T11 – Functions & Procedures (Complete Optimized Version)

This is the complete replacement for the T11 section in allskills.md.

---

ID: T11.GK.01
Topic: T11 – Functions & Procedures
Skill: Group activities that belong together
Description: Students identify activities that naturally belong together as a group. For example, in a picture sequence showing "get ready for school," they circle all the steps about eating breakfast (get bowl, pour cereal, add milk, eat) as one group and all the steps about getting dressed as another group. This builds the foundational idea that actions can be organized into meaningful clusters before introducing the concept of naming or reusing these groups.

Assessment example: Given 12 picture cards showing a morning routine, students use colored circles to group related activities: breakfast steps in blue, getting dressed steps in green, brushing teeth steps in yellow.

Dependencies:
* T01.GK.03: Find the first and last pictures
* T03.GK.01: Identify parts that make up a whole

---

ID: T11.GK.02
Topic: T11 – Functions & Procedures
Skill: Name a group of activities
Description: Students practice giving a clear, descriptive name to a group of related activities. After grouping activities together (like in T11.GK.01), they choose a name that describes what the whole group does. For example, a group of steps about mixing ingredients might be called "Make the Batter" rather than vague names like "Step 1" or "The First Part."

Assessment example: Given three groups of picture cards (1: wash hands, put on apron, get ingredients; 2: mix, stir, pour; 3: put in oven, set timer, wait), students suggest appropriate names like "Get Ready," "Make the Batter," and "Bake the Cake."

Dependencies:
* T11.GK.01: Group activities that belong together

---

ID: T11.GK.03
Topic: T11 – Functions & Procedures
Skill: Use a named group in a bigger plan
Description: Students see how a named group of activities can be referenced by its name in a larger set of instructions. For example, instead of listing all breakfast steps again, a morning routine might just say "Do Breakfast" as one step. This introduces the core idea of abstraction: once you name a group, you can refer to the whole group by that single name.

Assessment example: Students create a simplified "Get Ready for School" plan with just three steps: "Do Breakfast," "Get Dressed," "Pack Backpack," where each step represents a group of activities they previously organized.

Dependencies:
* T11.GK.02: Name a group of activities

---

ID: T11.G1.01
Topic: T11 – Functions & Procedures
Skill: Find repeated groups of activities
Description: Students examine a longer picture-based activity plan and identify when the same group of actions appears multiple times. For example, in a "classroom game" sequence, they might notice that "reset the game board" (put pieces back, shuffle cards, reset timer) happens before each round. This builds recognition of repetition at the group level, not just single actions.

Assessment example: Given a picture sequence for playing three rounds of a board game, students circle the "setup" activities that appear before each round, recognizing that the same group of actions repeats.

Dependencies:
* T11.GK.03: Use a named group in a bigger plan
* T04.G1.01: Notice when steps repeat in a sequence

---

ID: T11.G1.02
Topic: T11 – Functions & Procedures
Skill: Create labels for repeated activity groups
Description: Students create a label or title for a group of activities that repeats, so they can refer to it by name instead of drawing or listing the same steps multiple times. This introduces the practical benefit of naming: it saves time and reduces clutter when the same sequence is needed in multiple places.

Assessment example: After identifying that "clean workspace" (wipe table, throw away trash, put supplies away) happens multiple times in an art project, students create a "Clean Workspace" label card they can place in the sequence wherever needed.

Dependencies:
* T11.G1.01: Find repeated groups of activities
* T11.GK.02: Name a group of activities

---

ID: T11.G1.03
Topic: T11 – Functions & Procedures
Skill: Use a label to replace repeated activity groups
Description: Students simplify a complex picture-based plan by replacing repeated activity groups with their labels. Where they previously had the full sequence of steps repeated, they now place just the label card. This demonstrates how abstraction reduces complexity and makes plans easier to read and follow.

Assessment example: Students take a 20-step picture sequence for a class activity that has three repeated "clean up" sections and replace each with a single "Clean Up" label card, reducing the sequence to 14 steps plus the definition of "Clean Up."

Dependencies:
* T11.G1.02: Create labels for repeated activity groups

---

ID: T11.G1.04
Topic: T11 – Functions & Procedures
Skill: Recognize the need for different versions of similar groups
Description: Students identify when activity groups are similar but not identical, requiring different labels. For example, "Set Up for Game 1" and "Set Up for Game 2" involve similar activities but with different materials. This introduces the idea that sometimes you need multiple related groups rather than one group with variations.

Assessment example: Given a sequence for running two different classroom games, students identify that both games have "setup" phases but decide whether to create "Setup Game 1" and "Setup Game 2" labels or find what's common enough for a single "Setup Game" label.

Dependencies:
* T11.G1.03: Use a label to replace repeated activity groups

---

ID: T11.G2.01
Topic: T11 – Functions & Procedures
Skill: Identify when to create activity groups for organization
Description: Students decide whether to group activities based on organization benefits, not just repetition. Some groups of activities should be named and separated even if they only happen once, because they represent distinct responsibilities or phases. For example, "Check Safety Rules" might happen only once at the start but deserves its own label for clarity.

Assessment example: Given a field trip plan, students identify which activity groups should get labels: some because they repeat (like "count students"), others because they're important distinct phases (like "review safety rules" or "board the bus") even though they happen only once.

Dependencies:
* T11.G1.04: Recognize the need for different versions of similar groups
* T03.G2.01: Choose subtasks for a simple project idea

---

ID: T11.G2.02
Topic: T11 – Functions & Procedures
Skill: Create multiple labeled groups that work together
Description: Students organize a moderately complex activity plan into 3-5 labeled groups that work together to accomplish the overall goal. They identify natural boundaries between groups and give each a clear name. This builds decomposition skills: breaking a large plan into a coordinated set of smaller, named pieces.

Assessment example: For a "make and serve snacks" activity, students create labels for: "Wash Hands," "Prepare Snacks," "Set Table," "Serve Snacks," "Clean Up," showing how each labeled group contributes to the whole activity.

Dependencies:
* T11.G2.01: Identify when to create activity groups for organization
* T03.G2.02: Group subtasks by type

---

ID: T11.G2.03
Topic: T11 – Functions & Procedures
Skill: Explain dependencies between labeled groups
Description: Students identify and explain when one labeled group must happen before another, and when groups can happen in any order. They use simple language like "you must do Wash Hands before Prepare Snacks" or "Set Table can happen before or after Prepare Snacks." This builds understanding of dependencies and sequencing at a higher level of abstraction.

Assessment example: Given 5 labeled activity groups for a class party, students create arrows or ordering notes showing which groups must happen in sequence and which can happen in flexible order, explaining their reasoning.

Dependencies:
* T11.G2.02: Create multiple labeled groups that work together
* T01.G2.01: Identify pictures that must stay in order vs those that can swap

---

ID: T11.G2.04
Topic: T11 – Functions & Procedures
Skill: Recognize when labeled groups can be reused in different plans
Description: Students identify labeled activity groups that could be useful in multiple different plans, not just the current one. For example, "Wash Hands" and "Clean Workspace" are useful in many different activities (art, science, cooking). This introduces the concept of reusable components: some groups are specific to one plan, while others are general-purpose.

Assessment example: After creating labeled groups for a cooking activity, students sort the labels into "only for cooking" (like "Mix Ingredients") and "useful for other activities" (like "Wash Hands" or "Clean Up"), suggesting other activities where the reusable labels could be used.

Dependencies:
* T11.G2.02: Create multiple labeled groups that work together

---

ID: T11.G2.05
Topic: T11 – Functions & Procedures
Skill: Describe the purpose of each labeled group
Description: Students write or explain in one sentence what each labeled activity group is meant to accomplish and why it's part of the overall plan. This focuses on the WHAT and WHY (the group's purpose and role) rather than HOW (the specific steps inside). This thinking skill prepares students to design and document custom blocks with clear purposes.

Assessment example: For a classroom activity broken into labeled groups, students complete sentences like "The Setup Group gets everything ready so we can start the activity" and "The Practice Group helps us learn the new skill before we try it ourselves."

Dependencies:
* T11.G2.02: Create multiple labeled groups that work together
* T02.G2.01: Turn a picture routine into labeled boxes

---

ID: T11.G3.01
Topic: T11 – Functions & Procedures
Skill: Understand when to use custom blocks vs loops
Description: Students identify scenarios where a custom block (called "My Block" in CreatiCode) is more appropriate than a loop. They recognize that loops repeat the SAME action multiple times, while custom blocks group a SEQUENCE of different actions for reuse or organization. Given example scripts or problems, they choose the better organizational approach and explain their reasoning. This conceptual gateway skill builds organizational thinking without requiring students to define custom blocks yet.

Assessment example: Present 3-4 scenarios (e.g., "draw a house," "move 10 steps 5 times," "reset game state," "count to 10"). Students label each as better solved with a loop or a custom block and explain why.

Dependencies:
* T06.G3.01: Build a green-flag script that runs a 3-5 block sequence
* T07.G3.02: Trace a script with a simple loop
* T01.G3.12: Predict the final state of a simple algorithm

---

ID: T11.G3.00
Topic: T11 – Functions & Procedures
Skill: Distinguish custom blocks from built-in blocks
Description: Students learn that CreatiCode has two types of blocks: built-in blocks (provided by CreatiCode, like "move 10 steps" or "say Hello") and custom blocks (created by programmers, found in the "My Blocks" category). They examine several example projects and identify which blocks are custom (defined by the programmer) versus built-in (provided by the system). They understand that custom blocks are tools programmers create to organize their own code.

Assessment example: Given a script with 8-10 blocks including some from "Motion," "Looks," and "My Blocks" categories, students identify which blocks are custom (from My Blocks) and which are built-in, explaining how they can tell.

Dependencies:
* T06.G3.01: Build a green-flag script that runs a 3-5 block sequence
* T02.G3.01: Match a short block script to the right task

---

ID: T11.G3.02
Topic: T11 – Functions & Procedures
Skill: Use a pre-made custom block with parameters
Description: Students use an existing custom block (e.g., `call DrawRectangle [50] [30]` or `call MoveSprite [100] [200]`) provided in a starter project, and experiment with different argument values to see how the block's behavior changes. They learn that arguments (values in square brackets when calling) let one block handle many situations. Students do not create the block themselves yet; they explore how calling a pre-made block with different values produces different results.

Assessment example: Given a starter project with `call DrawShape [sides] [size]`, students try different values like `call DrawShape [3] [50]` for a triangle and `call DrawShape [6] [30]` for a hexagon, observing how the same block creates different shapes.

Dependencies:
* T11.G3.00: Distinguish custom blocks from built-in blocks
* T08.G3.02: Decide when a single if is enough
* T09.G3.01.04: Display variable value on stage using the variable monitor

---

ID: T11.G3.03
Topic: T11 – Functions & Procedures
Skill: Identify repeated or grouped actions that could become custom blocks
Description: Students examine a longer script (15-30 blocks) that is ALREADY WRITTEN and identify groups of blocks that appear multiple times OR represent distinct behaviors. They draw boxes around these groups and label each with a descriptive name (e.g., "ResetPlayer," "CheckWinCondition"). This builds the habit of recognizing natural custom block boundaries IN EXISTING CODE before actually creating them. This is ANALYSIS of existing code, as opposed to DESIGN before coding (covered in G5.01.01).

Assessment example: Given a 20-block script for a maze game, students circle and label groups like "move character," "check wall collision," and "update score display," explaining why each group makes sense as a potential custom block.

Dependencies:
* T11.G3.02: Use a pre-made custom block with parameters
* T09.G3.02: Use a variable in a conditional (if block)
* T08.G3.03: Pick the right conditional block for a scenario

---

ID: T11.G3.04
Topic: T11 – Functions & Procedures
Skill: Identify reporter blocks in existing code
Description: Students learn to recognize reporter blocks (blocks with rounded shapes that fit inside input slots) versus command blocks (blocks that perform actions and stack vertically). Using existing CreatiCode projects, they identify reporter blocks like `(pick random 1 to 10)`, `(distance to [sprite])`, or `(x position)` and observe where these blocks can be used (inside input slots of other blocks). This prepares students to understand return values from custom reporter blocks in later grades.

Assessment example: Given 10-12 different blocks from various categories, students sort them into "reporter blocks" (rounded, return a value) and "command blocks" (rectangular, do an action) and show one example of where each type can be used in a script.

Dependencies:
* T11.G3.03: Identify repeated or grouped actions that could become custom blocks
* T09.G3.04: Debug a single missing or wrong variable block
* T07.G3.04: Use repeat-until to reach a simple goal

---

ID: T11.G3.05.01
Topic: T11 – Functions & Procedures
Skill: Explore the "Make a Block" interface basics
Description: Students open CreatiCode's "My Blocks" category, click "Make a Block," and explore the basic interface. They type a simple block name (without parameters, like "ResetGame" or "JumpUp") and observe the preview of how the block will look. After clicking OK, they see the `define (ResetGame)` hat block appear, understanding this is where they would add the block's code. They practice this process 2-3 times with different names, exploring without completing full implementations yet.

Assessment example: Students open the "Make a Block" dialog, type three different simple block names like "StartGame", "ShowMenu", and "PlaySound", observe each preview, click OK to see the define block appear, then delete them without adding code inside.

Dependencies:
* T11.G3.04: Identify reporter blocks in existing code
* T07.G3.04: Use repeat-until to reach a simple goal
* T09.G3.01.04: Display variable value on stage using the variable monitor

---

ID: T11.G3.05.02
Topic: T11 – Functions & Procedures
Skill: Add one parameter to a custom block interface
Description: Students extend their exploration of the "Make a Block" interface by adding a single parameter using parentheses notation. They type block names with one input like `DrawSquare (size)` or `SayMessage (text)` and observe how the parameter appears in both the preview and the resulting `define (DrawSquare (size))` hat block. They understand that text in parentheses becomes an input slot that will receive values when the block is called.

Assessment example: Students create 2-3 custom block interfaces with one parameter each (like `Jump (height)`, `MoveForward (distance)`, `SetSpeed (speed)`), observing the preview and define block for each, then cancel or delete without implementing the blocks.

Dependencies:
* T11.G3.05.01: Explore the "Make a Block" interface basics

---

ID: T11.G4.01
Topic: T11 – Functions & Procedures
Skill: Define and call a simple custom block (no parameters)
Description: Students create their first complete custom block with no inputs (e.g., `ResetPlayer`) using CreatiCode's "Make a Block" button. In the dialog, they type just the block name. After clicking OK, a `define (ResetPlayer)` hat block appears where they add 3-5 blocks inside the definition. To run the custom block, they use `call ResetPlayer` from a main script. Students compare the before/after organization to see how custom blocks improve readability by grouping related actions under a meaningful name.

Assessment example: Students create a `SetupGame` custom block that goes to x:0 y:0, sets score to 0, and shows the sprite. They then call it from the green flag script using `call SetupGame`, verifying that the grouped actions execute when called.

Dependencies:
* T03.G2.01: Choose subtasks for a simple project idea
* T03.G2.02: Group subtasks by type
* T04.G2.03: Compare a long explicit description vs a compressed "repeat" description
* T06.G2.03: Design a simple "if-then" game rule
* T06.G3.01: Build a green-flag script that runs a 3-5 block sequence
* T11.G3.05.01: Explore the "Make a Block" interface basics

---

ID: T11.G4.01.01
Topic: T11 – Functions & Procedures
Skill: Call a custom block from multiple places
Description: Students practice the key benefit of custom blocks: reuse. They create one custom block definition (like `ResetPlayer` or `ClearScreen`) and call it from 2-3 different places in their program (e.g., from the green flag script at startup, from a "game over" script, from a "restart" button). They verify that changing the definition once updates the behavior everywhere it's called, demonstrating the power of abstraction.

Assessment example: Students create a `ShowWelcomeMessage` custom block that says "Welcome!" and sets the sprite to x:0 y:0. They call this block from both the green flag event and when the space key is pressed, verifying that the same behavior happens in both places.

Dependencies:
* T11.G4.01: Define and call a simple custom block (no parameters)

---

ID: T11.G4.02
Topic: T11 – Functions & Procedures
Skill: Distinguish command blocks from reporter blocks
Description: Students learn to recognize which blocks DO something (command/stack blocks that perform actions) and which blocks RETURN a value (reporter blocks with rounded shapes). In CreatiCode, command blocks stack vertically in scripts and are called with `call BlockName`, while reporter blocks fit inside input slots. Students categorize a set of BUILT-IN blocks first, understanding the two types before learning about custom reporters with `report` syntax in Grade 5.

Assessment example: Given 10 built-in blocks (mix of commands like "move 10 steps" and reporters like "(x position)" or "(pick random 1 to 10)"), students categorize them as "command blocks" (do something) or "reporter blocks" (return a value) and for each explain where it can be used.

Dependencies:
* T11.G4.01: Define and call a simple custom block (no parameters)
* T04.G2.01: Identify the repeating unit in a longer pattern
* T04.G2.02: Spot repeated step sequences in everyday algorithms
* T07.G2.01: Identify when to use "repeat" vs "do once"
* T09.G3.01.04: Display variable value on stage using the variable monitor
* T11.G3.04: Identify reporter blocks in existing code

---

ID: T11.G4.03
Topic: T11 – Functions & Procedures
Skill: Use a built-in reporter block's result in a calculation or condition
Description: Students call built-in reporter blocks (like `(pick random 1 to 10)`, `(distance to [sprite])`, `(length of [list])`) and use their returned values directly in conditions or arithmetic expressions (e.g., `if <(distance to [sprite]) < 50>`, `set x to ((pick random 1 to 10) + 5)`). They practice chaining and nesting multiple reporters together in compound expressions, understanding that reporters can be nested inside other blocks' input slots. This prepares them to create their own custom reporter blocks in Grade 5.

Assessment example: Students create a script that uses `if <(distance to [Cat]) < 100>` to detect when the player is near an enemy, combining the reporter block with a comparison operator.

Dependencies:
* T11.G4.02: Distinguish command blocks from reporter blocks
* T04.G2.01: Identify the repeating unit in a longer pattern
* T04.G2.02: Spot repeated step sequences in everyday algorithms
* T07.G2.01: Identify when to use "repeat" vs "do once"
* T08.G3.01: Use a simple if in a script
* T09.G3.01.04: Display variable value on stage using the variable monitor
* T11.G3.04: Identify reporter blocks in existing code

---

ID: T11.G4.03.01
Topic: T11 – Functions & Procedures
Skill: Nest reporter blocks inside other reporters
Description: Students practice nesting reporter blocks inside other reporter blocks to create more complex expressions. For example, they place `(pick random 1 to 10)` inside `(+ 5)` to create `((pick random 1 to 10) + 5)`, or nest `(length of [list])` inside `(* 2)` for calculations. This builds comfort with reporter composition, a key skill for using custom reporters later.

Assessment example: Students create expressions that nest 2-3 reporter blocks, such as `((x position) + ((pick random 1 to 10) * 5))` to add a random offset to the sprite's current position.

Dependencies:
* T11.G4.03: Use a built-in reporter block's result in a calculation or condition

---

ID: T11.G4.04
Topic: T11 – Functions & Procedures
Skill: Describe the purpose of each custom block in a script
Description: Students read a script that uses several custom blocks (called with `call BlockName`) and write a one-sentence description of each block's PURPOSE (e.g., "The `call ResetPlayer` block resets the player to the starting position and clears the score"). They focus on WHAT each block does (its goal), not HOW it does it (implementation details). They also identify how blocks fit together in the program's overall structure (e.g., setup, game loop, scoring, ending).

Assessment example: Given a game script with blocks `call SetupGame`, `call MovePlayer`, `call CheckCollision`, and `call UpdateScore`, students write a sentence describing what each block does based on its name and context.

Dependencies:
* T11.G4.01: Define and call a simple custom block (no parameters)
* T02.G2.01: Turn a picture routine into labeled boxes
* T02.G2.02: Read a box diagram and choose the matching pictures
* T03.G2.01: Choose subtasks for a simple project idea
* T03.G2.02: Group subtasks by type
* T04.G2.01: Identify the repeating unit in a longer pattern
* T04.G2.02: Spot repeated step sequences in everyday algorithms
* T07.G2.01: Identify when to use "repeat" vs "do once"

---

ID: T11.G4.05
Topic: T11 – Functions & Procedures
Skill: Trace execution through a script with custom blocks
Description: Students trace step-by-step through a script that uses `call` blocks, predicting the order of execution. When the script reaches `call MyBlock`, students trace INTO the custom block definition, follow the blocks inside, then return to continue after the call. They number each block in execution order and track any variable changes. This LOW-LEVEL tracing (execution order) complements G4.04's HIGH-LEVEL understanding (purpose).

Assessment example: Given a script with `when green flag clicked` → `call Setup` → `call MainLoop`, students number all blocks in order: 1-3 in the main script, then 4-7 inside Setup's definition, then 8-12 inside MainLoop's definition.

Dependencies:
* T11.G4.01: Define and call a simple custom block (no parameters)
* T03.G2.01: Choose subtasks for a simple project idea
* T03.G2.02: Group subtasks by type
* T04.G2.01: Identify the repeating unit in a longer pattern
* T04.G2.02: Spot repeated step sequences in everyday algorithms
* T07.G2.01: Identify when to use "repeat" vs "do once"
* T11.G3.04: Identify reporter blocks in existing code
* T13.G3.01: Test and trace simple block-based scripts

---

ID: T11.G4.06.01
Topic: T11 – Functions & Procedures
Skill: Identify the argument block in a custom block definition
Description: Students examine a custom block definition with one parameter and identify the `(argument (name))` reporter block used inside the definition. They understand that this special reporter block represents "the value that gets passed in" when the block is called. They locate where the argument block appears in the definition and recognize it only works inside that definition.

Assessment example: Given a `define (DrawSquare (size))` block with several blocks inside including `move (argument (size)) steps`, students identify which block is the argument block and explain that it retrieves the "size" value passed when calling the block.

Dependencies:
* T11.G4.01: Define and call a simple custom block (no parameters)
* T11.G3.02: Use a pre-made custom block with parameters
* T03.G2.01: Choose subtasks for a simple project idea
* T03.G2.02: Group subtasks by type
* T04.G2.01: Identify the repeating unit in a longer pattern
* T04.G2.02: Spot repeated step sequences in everyday algorithms
* T06.G2.01: Create a simple cause-and-effect chain with picture cards
* T06.G2.02: Match multiple triggers to the same action

---

ID: T11.G4.06.02
Topic: T11 – Functions & Procedures
Skill: Trace the flow of a parameter value through a custom block
Description: Students trace how a value passed during a `call` flows through a custom block definition via the `(argument (name))` block. For example, with `define (SayTwice (message))` containing `say (argument (message))` and `wait 1 seconds` and `say (argument (message))`, when students trace `call SayTwice [Hello]`, they identify that each `(argument (message))` evaluates to "Hello" at runtime. This builds understanding of parameter substitution.

Assessment example: Given `define (MoveAndTurn (distance))` with blocks `move (argument (distance)) steps` and `turn right ((argument (distance)) / 2) degrees`, students trace what happens when `call MoveAndTurn [60]` runs, showing that the first argument returns 60 and the second returns 30.

Dependencies:
* T11.G4.06.01: Identify the argument block in a custom block definition
* T13.G3.01: Test and trace simple block-based scripts

---

ID: T11.G4.07
Topic: T11 – Functions & Procedures
Skill: Define a custom block with one parameter
Description: Students create their first custom block with one input parameter using CreatiCode's "Make a Block" button. They type the block name with one parameter in parentheses like `DrawSquare (size)`. After clicking OK, a `define (DrawSquare (size))` hat block appears. Inside the definition, they use the `(argument (size))` reporter to access the parameter value. They call the block with different arguments like `call DrawSquare [50]` and `call DrawSquare [100]` to see how the parameter makes the block reusable for different sizes.

Assessment example: Students create `define (SayHello (name))` with `say (join [Hello, ] (argument (name)))` inside. They test it by calling `call SayHello [Alice]` and `call SayHello [Bob]`, verifying different outputs.

Dependencies:
* T11.G4.06.01: Identify the argument block in a custom block definition
* T03.G2.01: Choose subtasks for a simple project idea
* T03.G2.02: Group subtasks by type
* T04.G2.01: Identify the repeating unit in a longer pattern
* T04.G2.02: Spot repeated step sequences in everyday algorithms
* T07.G2.01: Identify when to use "repeat" vs "do once"

---

ID: T11.G4.07.01
Topic: T11 – Functions & Procedures
Skill: Call the same custom block with different parameter values
Description: Students practice the key value of parameters: one block definition can handle many different situations by changing the input values. They create one parameterized custom block and call it 3-5 times with different argument values, observing how the same code produces different results based on the inputs. This reinforces understanding of parameters as "customization points" that make blocks more versatile.

Assessment example: Students create `define (DrawPolygon (sides))` and call it multiple times: `call DrawPolygon [3]` (triangle), `call DrawPolygon [4]` (square), `call DrawPolygon [6]` (hexagon), `call DrawPolygon [8]` (octagon), seeing how one block creates all these shapes.

Dependencies:
* T11.G4.07: Define a custom block with one parameter

---

ID: T11.G4.08
Topic: T11 – Functions & Procedures
Skill: Test a custom block with simple inputs
Description: Students test a newly created parameterized custom block by calling it with 2-3 different input values to verify it works as expected. They observe the sprite's behavior or output for each test case and confirm the block performs its intended action correctly. This introduces basic testing practices early, building habits of verification: try different values, check the result, identify if something doesn't work right.

Assessment example: After creating `define (MoveDistance (steps))`, students test it with `call MoveDistance [10]`, `call MoveDistance [50]`, and `call MoveDistance [100]`, observing that the sprite moves the correct distance each time.

Dependencies:
* T11.G4.07: Define a custom block with one parameter
* T03.G2.01: Choose subtasks for a simple project idea
* T03.G2.02: Group subtasks by type
* T04.G2.01: Identify the repeating unit in a longer pattern
* T04.G2.02: Spot repeated step sequences in everyday algorithms
* T07.G2.01: Identify when to use "repeat" vs "do once"
* T13.G3.01: Test and trace simple block-based scripts

---

ID: T11.G4.09
Topic: T11 – Functions & Procedures
Skill: Recognize when to use a parameter vs a fixed value
Description: Students analyze custom block scenarios and decide whether a value should be a parameter (input) or a fixed value (hardcoded in the block definition). They understand that values that need to change between different calls should be parameters, while values that stay the same can be fixed. For example, in a "JumpUp" block, the jump height might be a parameter, but the animation delay might be a fixed value.

Assessment example: Given 4-5 custom block scenarios like "play a sound effect" (should the sound name be a parameter?) or "reset player position" (should the starting position be a parameter?), students decide which values should be parameters and explain their reasoning.

Dependencies:
* T11.G4.07: Define a custom block with one parameter
* T11.G4.08: Test a custom block with simple inputs

---

ID: T11.G5.01.01
Topic: T11 – Functions & Procedures
Skill: Identify 2-3 main responsibilities in a project description
Description: Given a project description (e.g., "make a simple quiz game"), students identify 2-3 distinct main responsibilities or phases that would each make a good custom block (e.g., "show question," "check answer," "update score"). This preliminary decomposition skill helps students see major functional boundaries before detailed planning. Students explain what each responsibility does, preparing for more detailed decomposition in T11.G5.01.02.

Assessment example: Given "Create a platformer game," students identify 3 main responsibilities like "player movement," "collision detection," and "level progression," explaining briefly what each area involves.

Dependencies:
* T11.G4.04: Describe the purpose of each custom block in a script
* T11.G4.05: Trace execution through a script with custom blocks
* T03.G5.01: Create a feature list and subtask breakdown

---

ID: T11.G5.01.02
Topic: T11 – Functions & Procedures
Skill: Create a complete custom block decomposition plan
Description: Students take a project description and create a complete plan showing 4-6 custom blocks with clear names and brief descriptions of each block's responsibility. This is problem decomposition BEFORE coding—students plan the custom block structure first, then implement. They ensure each block has a single clear purpose and the blocks work together to accomplish the project goal. They may sketch or write out how the blocks will be called and interact.

Assessment example: Given "Create a pet care game," students plan custom blocks like `FeedPet (foodType)`, `PlayWithPet (activity)`, `CheckHealth`, `UpdateMood`, `ShowStatus`, explaining what each block does and which blocks call others.

Dependencies:
* T11.G5.01.01: Identify 2-3 main responsibilities in a project description

---

ID: T11.G5.02.01
Topic: T11 – Functions & Procedures
Skill: Create 2-3 parameterized custom blocks for a small project
Description: Students implement a small project (10-15 blocks total) that uses 2-3 custom blocks with parameters. Each block should have 1-2 parameters and be called from at least one place. They practice creating the definitions using the `define` block, implementing the logic inside using `argument` blocks, and calling the blocks using the `call` syntax with appropriate arguments. This introduces coordinated use of multiple custom blocks.

Assessment example: Students create a simple drawing tool with two custom blocks: `define (DrawLine (length))` and `define (ChangeColor (colorName))`. They use these blocks together to draw a pattern with different colored lines of various lengths.

Dependencies:
* T11.G4.07: Define a custom block with one parameter
* T11.G4.08: Test a custom block with simple inputs

---

ID: T11.G5.02.02
Topic: T11 – Functions & Procedures
Skill: Demonstrate code reuse with parameterized custom blocks
Description: Students extend their project from T11.G5.02.01 to demonstrate how parameterized custom blocks enable code reuse. They call the same custom block with different parameter values in multiple places, showing that one flexible block definition can handle many similar situations. They explain how this reduces code duplication and makes the program easier to understand and modify.

Assessment example: Students create `define (DrawPolygon (sides) (size))` and use it throughout a drawing program: `call DrawPolygon [3] [50]` for triangles, `call DrawPolygon [4] [60]` for squares, `call DrawPolygon [6] [40]` for hexagons, demonstrating that one block handles all regular polygons.

Dependencies:
* T11.G5.02.01: Create 2-3 parameterized custom blocks for a small project

---

ID: T11.G5.03
Topic: T11 – Functions & Procedures
Skill: Match parameter names to argument values when calling custom blocks
Description: Students trace how argument values passed during a `call` block correspond to parameter names in the custom block definition by position. For `define (DrawRect (width) (height))` called with `call DrawRect [100] [50]`, students identify that 100 maps to `width` and 50 maps to `height`. They practice with blocks having 2-3 parameters, understanding that arguments are matched by POSITION (first argument to first parameter, etc.) not by name.

Assessment example: Given `define (MoveAndSay (x) (y) (message))` and `call MoveAndSay [100] [200] [Hello]`, students identify which value each parameter receives and predict what each `(argument (...))` block would return inside the definition.

Dependencies:
* T11.G4.07: Define a custom block with one parameter
* T02.G5.01: Trace a script with nested loops using debug print

---

ID: T11.G5.03.01
Topic: T11 – Functions & Procedures
Skill: Debug incorrect parameter order
Description: Students identify and fix bugs caused by arguments being passed in the wrong order. They examine calls to custom blocks where the arguments are swapped or misplaced, predict the incorrect behavior, then fix the call to pass arguments in the correct order. This reinforces understanding that argument position matters and builds debugging skills for a common mistake.

Assessment example: Given `define (CreatePlayer (name) (color) (size))` and a buggy call `call CreatePlayer [30] [red] [Alice]`, students identify that the arguments are in wrong positions, predict the bug (size gets "Alice", name gets 30, etc.), and write the corrected call `call CreatePlayer [Alice] [red] [30]`.

Dependencies:
* T11.G5.03: Match parameter names to argument values when calling custom blocks

---

ID: T11.G5.04
Topic: T11 – Functions & Procedures
Skill: Choose between adding a parameter vs creating a separate block
Description: Students analyze scenarios and decide whether to add a parameter to an existing custom block OR create separate blocks. For example: should `DrawRectangle` have a color parameter (`DrawRectangle (width) (height) (color)`), or should there be separate `DrawRedRectangle` and `DrawBlueRectangle` blocks? They justify design choices: parameters are better when the variation is continuous/has many possible values; separate blocks may be clearer when there are few fixed options.

Assessment example: For "play different sound effects in a game," students decide between `PlaySound (soundName)` vs separate `PlayJumpSound`, `PlayCoinSound`, `PlayGameOverSound` blocks, and explain their reasoning based on how many sounds there are and whether new sounds will be added.

Dependencies:
* T11.G5.01.02: Create a complete custom block decomposition plan
* T11.G5.03: Match parameter names to argument values when calling custom blocks

---

ID: T11.G5.05
Topic: T11 – Functions & Procedures
Skill: Analyze a modular program structure
Description: Students examine a larger project (game, animation, simulation) and identify how it uses custom blocks to organize functionality into major components. They explain how this modular design makes the code easier to understand, modify, and debug compared to a non-modular version. They create a diagram or outline showing the major custom blocks and their relationships (which blocks call which other blocks).

Assessment example: Given a complete game project with 6-8 custom blocks, students create a structure diagram showing the main script at the top, which blocks it calls directly, and which helper blocks are called by those blocks, explaining how the organization improves clarity.

Dependencies:
* T11.G5.01.01: Identify 2-3 main responsibilities in a project description
* T11.G4.04: Describe the purpose of each custom block in a script
* T11.G4.05: Trace execution through a script with custom blocks
* T02.G5.01: Trace a script with nested loops using debug print
* T03.G5.01: Create a feature list and subtask breakdown

---

ID: T11.G5.06
Topic: T11 – Functions & Procedures
Skill: Define a custom block with two or more parameters
Description: Students create a custom block with multiple parameters (e.g., `DrawRectangle (width) (height)` or `MoveSprite (x) (y) (speed)`). Inside the definition, they access each parameter using the `argument` block for each parameter name. They practice ordering parameters logically and using clear parameter names. They call the block with various argument combinations, testing that each parameter works correctly.

Assessment example: Students create `define (DrawRectangle (width) (height) (color))` with code that uses all three parameters. They test with calls like `call DrawRectangle [100] [50] [red]` and `call DrawRectangle [80] [120] [blue]`.

Dependencies:
* T11.G4.07: Define a custom block with one parameter
* T11.G5.03: Match parameter names to argument values when calling custom blocks

---

ID: T11.G5.07
Topic: T11 – Functions & Procedures
Skill: Decide whether a custom block should be a command or reporter
Description: Students analyze scenarios and decide whether a custom block should perform an action (command block, use `call`) or return a value (reporter block, use `report` with `return`). For example, "DrawCircle" should be a command (it does something visual), while "CalculateArea" should be a reporter (it computes and returns a number). They justify their design choice based on whether the block DOES something or COMPUTES something. This introduces the concept of custom reporters before implementing them in T11.G5.08.

Assessment example: Given 6-8 custom block scenarios (e.g., "move sprite to position," "calculate distance between sprites," "draw polygon," "find maximum value," "reset game state," "check if player won"), students categorize each as command or reporter and explain their reasoning.

Dependencies:
* T11.G4.02: Distinguish command blocks from reporter blocks
* T11.G4.07: Define a custom block with one parameter
* T11.G5.02.01: Create 2-3 parameterized custom blocks for a small project

---

ID: T11.G5.08
Topic: T11 – Functions & Procedures
Skill: Define a custom reporter block that returns a value
Description: Students create a custom block that returns a value using CreatiCode's `return [value]` block inside the definition. For example, `define (Average (a) (b))` with a `return [((argument (a)) + (argument (b))) / 2]` block. To use the return value, they call the block with `report Average [10] [20]` instead of `call`, allowing the result to be used in expressions, conditions, or variable assignments.

Assessment example: Students create a custom reporter block `define (Maximum (a) (b))` that returns the larger of two numbers using an if-else block and two return blocks. They test it in different contexts: `say (report Maximum [5] [3])`, `set score to (report Maximum [score] [0])`, and `if <(report Maximum [x] [y]) > 100>`.

Dependencies:
* T11.G5.07: Decide whether a custom block should be a command or reporter
* T11.G4.03: Use a built-in reporter block's result in a calculation or condition

---

ID: T11.G5.08.01
Topic: T11 – Functions & Procedures
Skill: Use custom reporter return value in multiple contexts
Description: Students practice using the value returned by their custom reporter blocks in various contexts: inside other reporters, in conditional tests, in variable assignments, and nested inside other custom blocks. They demonstrate that custom reporters work just like built-in reporters—they can be placed anywhere a value is needed. This builds fluency with reporter composition and reinforces that well-designed reporters are versatile tools.

Assessment example: Students create `define (DistanceBetween (x1) (y1) (x2) (y2))` that returns the calculated distance. They use it in multiple ways: `say (report DistanceBetween [0] [0] [100] [100])`, `if <(report DistanceBetween [x1] [y1] [x2] [y2]) < 50>`, and `set closestDistance to (report DistanceBetween [x1] [y1] [x2] [y2])`.

Dependencies:
* T11.G5.08: Define a custom reporter block that returns a value

---

ID: T11.G5.09
Topic: T11 – Functions & Procedures
Skill: Debug a script with incorrect custom block calls
Description: Students examine a script that uses custom blocks incorrectly and identify 2-3 bugs. Common errors include: wrong argument values, missing calls, arguments in wrong order, using `call` when `report` is needed (or vice versa), wrong number of arguments, or calling a block before it's defined. They fix each bug and test that the corrected script works properly.

Assessment example: Given a script with bugs like `call MoveSprite [100]` (missing second argument), `set x to (call GetPosition)` (should use `report`), and `call DrawShape [red] [5]` (arguments swapped), students identify each bug, explain the problem, and write the correct version.

Dependencies:
* T11.G5.08: Define a custom reporter block that returns a value
* T11.G4.05: Trace execution through a script with custom blocks
* T02.G5.01: Trace a script with nested loops using debug print

---

ID: T11.G5.10
Topic: T11 – Functions & Procedures
Skill: Use comments to document custom block purpose
Description: Students use CreatiCode's `// [comment]` block to add comments inside and above custom block definitions, documenting what the block does, what each parameter represents, and what value it returns (if any). They practice writing clear, concise documentation comments that help others (or their future selves) understand the block's purpose and usage without reading all the implementation details.

Assessment example: Students add documentation comments to their custom blocks, such as: `// This block draws a polygon with the given number of sides and size`, `// Parameters: sides (number), size (number)`, `// Returns: nothing (command block)`.

Dependencies:
* T11.G4.07: Define a custom block with one parameter
* T11.G5.08: Define a custom reporter block that returns a value

---

ID: T11.G5.11
Topic: T11 – Functions & Procedures
Skill: Create custom blocks with mixed text labels and parameters
Description: Students create custom blocks that include both descriptive text labels AND input parameters to make the block read like natural language. For example, `Move sprite (sprite) to x (x) y (y)` or `Set (variable) to random from (min) to (max)`. In CreatiCode's "Make a Block" dialog, they type the full block signature with text labels between parameters, making the block's purpose clear when used in scripts. This improves code readability by making block calls self-documenting.

Assessment example: Students create a block like `Draw (shape) with size (size) and color (color)` that reads naturally when called: `call Draw [square] with size [50] and color [red]`, making the code easy to understand at a glance.

Dependencies:
* T11.G5.06: Define a custom block with two or more parameters
* T11.G5.10: Use comments to document custom block purpose
* T09.G5.01: Use multiple variables together in a single expression

---

ID: T11.G5.12
Topic: T11 – Functions & Procedures
Skill: Identify when code duplication signals need for custom block
Description: Students examine code with duplicated sequences of 3-5 blocks and recognize this as a signal that a custom block should be created. They identify the duplicated sections, note any values that vary between duplications (potential parameters), and explain how creating a custom block would improve the code. This "code smell" detection skill helps students proactively recognize refactoring opportunities.

Assessment example: Given a script with three identical 5-block sequences for checking different sprite collisions (only the sprite name changes), students identify the duplication, suggest a `CheckCollision (spriteName)` custom block, and explain how it would eliminate the repeated code.

Dependencies:
* T11.G5.05: Analyze a modular program structure
* T11.G5.06: Define a custom block with two or more parameters

---

ID: T11.G6.01.01
Topic: T11 – Functions & Procedures
Skill: Choose clear, descriptive names for custom blocks
Description: Students practice naming custom blocks with clear, descriptive names that communicate the block's purpose. They evaluate name quality: good names use verbs for command blocks and noun phrases for reporters, are specific rather than vague, and follow consistent naming conventions. They compare weak names (like "Block1," "DoStuff," "X") with strong names (like "ResetPlayer," "CheckCollision," "CalculateScore") and explain why the strong names are better.

Assessment example: Given 8-10 poorly named custom blocks like "Go," "Thing," "Block2," "X," students suggest better names and explain their improvements. For example, "Go" might become "MoveToStartPosition" and "Thing" might become "UpdateHealthBar."

Dependencies:
* T11.G5.04: Choose between adding a parameter vs creating a separate block
* T11.G5.05: Analyze a modular program structure
* T11.G5.06: Define a custom block with two or more parameters

---

ID: T11.G6.01.02
Topic: T11 – Functions & Procedures
Skill: Design clear parameter lists for custom blocks
Description: Students design parameter lists for custom blocks by determining what inputs the block needs and choosing descriptive parameter names. They consider parameter order (most important or natural reading order first) and avoid redundant parameters. They practice thinking through "what information does this block need from the caller?" and "what names make the block call easy to understand?"

Assessment example: For a block that should "move a sprite smoothly from its current position to a target position," students design the parameter list, deciding between options like `MoveTo (x) (y)` vs `MoveSprite (sprite) to (x) (y)` vs `MoveSmoothly (x) (y) (speed)`, explaining trade-offs for each design.

Dependencies:
* T11.G6.01.01: Choose clear, descriptive names for custom blocks

---

ID: T11.G6.01.03
Topic: T11 – Functions & Procedures
Skill: Design complete custom block interfaces before implementation
Description: Students design custom blocks by fully specifying the interface (name, parameters, return value if any, and purpose description) BEFORE writing the code inside. They complete a design template for 3-5 custom blocks: block name with parameters, what it does (one sentence), what each parameter means, what it returns (if anything). This "interface-first" design approach ensures blocks have clear, well-thought-out contracts before implementation, making them more reusable and maintainable.

Assessment example: For a "battle system" feature, students design interfaces: `Attack (attacker) (defender) returns: damage dealt`, `Heal (target) (amount) returns: actual healing (after max HP cap)`, `CheckDefeat (sprite) returns: true if HP <= 0`, completing a design document before any coding.

Dependencies:
* T11.G6.01.02: Design clear parameter lists for custom blocks

---

ID: T11.G6.02.01
Topic: T11 – Functions & Procedures
Skill: Create a program with 4-6 coordinated custom blocks
Description: Students design and implement a moderately complex program (e.g., a game with setup, gameplay, and end screen) structured as a set of 4-6 custom blocks, each handling a distinct responsibility. They demonstrate that the blocks work together to accomplish the program's goal, with a clear main script that coordinates the custom blocks. This is modular programming in practice.

Assessment example: Students create a quiz game with blocks: `SetupQuiz`, `ShowQuestion (questionNum)`, `CheckAnswer (userAnswer)`, `UpdateScore (correct)`, `ShowResults`, with a main script that coordinates these blocks to run a complete quiz.

Dependencies:
* T11.G6.01.03: Design complete custom block interfaces before implementation
* T11.G5.05: Analyze a modular program structure
* T11.G5.06: Define a custom block with two or more parameters

---

ID: T11.G6.02.02
Topic: T11 – Functions & Procedures
Skill: Verify custom block independence and isolation
Description: Students verify that their custom blocks are properly independent—changing one block's internal implementation doesn't break other blocks as long as the interface (name, parameters, return value) stays the same. They demonstrate this by modifying a block's internals (changing how it accomplishes its goal) while keeping the interface the same, and showing that the rest of the program still works correctly. This teaches the value of abstraction and encapsulation.

Assessment example: Students modify the internal implementation of their `DrawPolygon (sides)` block (changing from a repeat loop to explicit turn commands for triangles/squares) and verify that all calls to `DrawPolygon` in other parts of the program still work without any changes to those calling scripts.

Dependencies:
* T11.G6.02.01: Create a program with 4-6 coordinated custom blocks

---

ID: T11.G6.03
Topic: T11 – Functions & Procedures
Skill: Test custom blocks with boundary and edge cases
Description: Students test their custom blocks systematically with not just normal inputs, but also boundary values (e.g., 0, 1, maximum values) and edge cases (negative numbers, very large numbers, empty strings). They identify and fix bugs that only appear with certain inputs. For example, testing a "DrawPolygon (sides)" block with sides=3 (normal), sides=100 (large), sides=2 (invalid), sides=0 (invalid), and sides=-5 (invalid).

Assessment example: Students create a test plan for a custom block like `ClampValue (value) (min) (max)` and test it with: value within range, value equal to min, value equal to max, value below min, value above max, min > max, and all equal values, documenting expected and actual results.

Dependencies:
* T11.G5.06: Define a custom block with two or more parameters
* T11.G5.09: Debug a script with incorrect custom block calls

---

ID: T11.G6.03.01
Topic: T11 – Functions & Procedures
Skill: Handle invalid inputs gracefully in custom blocks
Description: Students add defensive code to custom blocks to detect and handle invalid inputs appropriately. Instead of allowing blocks to crash or produce nonsense results with bad inputs, they add checks (using if blocks) and either: display an error message, use safe default values, or return a special "error" value. This introduces the concept of robust code that anticipates misuse.

Assessment example: Students modify their `DrawPolygon (sides)` block to check: if sides < 3, say "Error: need at least 3 sides" and stop the block. They test that the block now handles invalid inputs gracefully instead of attempting to draw an impossible shape.

Dependencies:
* T11.G6.03: Test custom blocks with boundary and edge cases

---

ID: T11.G6.04
Topic: T11 – Functions & Procedures
Skill: Refactor spaghetti code into organized custom blocks
Description: Students take a messy, unorganized script (20-30 blocks) and improve it by identifying and extracting logical units into custom blocks, dramatically improving readability without changing behavior. They verify the refactored code produces the same output. This teaches the practical skill of improving existing code through decomposition and organization.

Assessment example: Given a 25-block script that mixes game setup, player movement, collision checking, and scoring all in one long sequence, students refactor it into `SetupGame`, `MovePlayer`, `CheckCollisions`, and `UpdateScore` custom blocks, demonstrating that the refactored version is easier to understand and modify while producing identical behavior.

Dependencies:
* T11.G6.01.03: Design complete custom block interfaces before implementation
* T11.G5.05: Analyze a modular program structure

---

ID: T11.G6.05
Topic: T11 – Functions & Procedures
Skill: Add input validation to custom blocks
Description: Students add input validation to custom blocks to check that parameters meet requirements before executing the main logic. They use conditional blocks to verify parameter values are in valid ranges, are the right type, or meet other constraints. When validation fails, the block provides clear feedback. This is a more sophisticated version of error handling that validates inputs proactively.

Assessment example: In a `SetPlayerSpeed (speed)` block, students add validation: if speed < 0 or speed > 100, say "Speed must be between 0 and 100" and stop the block. Otherwise, set the speed variable. They test with valid and invalid inputs to verify the validation works.

Dependencies:
* T11.G6.03: Test custom blocks with boundary and edge cases
* T11.G5.06: Define a custom block with two or more parameters

---

ID: T11.G6.06
Topic: T11 – Functions & Procedures
Skill: Critique custom block naming and parameter choices
Description: Students evaluate custom block designs focusing specifically on naming conventions and parameter choices. They identify unclear or inconsistent names (e.g., "block1" vs "CalculateScore"), overly generic parameter names (e.g., "x" vs "playerScore"), missing parameters (forcing users to set variables before calling), or redundant parameters (values that could be calculated inside the block). They suggest concrete improvements to make blocks more understandable and reusable.

Assessment example: Given 5-6 custom block signatures like `DoStuff (x) (y)`, `Calculate (num)`, `MoveSprite (sprite) left (distance) by (amount)` (redundant parameters), students critique each and suggest improved names and parameter lists, explaining why the improvements matter.

Dependencies:
* T11.G6.01.03: Design complete custom block interfaces before implementation
* T11.G5.04: Choose between adding a parameter vs creating a separate block
* T11.G5.11: Create custom blocks with mixed text labels and parameters

---

ID: T11.G6.07
Topic: T11 – Functions & Procedures
Skill: Evaluate custom block scope and single responsibility
Description: Students evaluate whether custom blocks follow the "single responsibility principle"—each block should do ONE thing well. They identify blocks that try to do too much (e.g., a "SetupAndStartGame" block that does setup, plays music, shows instructions, AND starts the timer—four responsibilities) or too little (e.g., a block that just sets one variable—could be done without a custom block). They explain whether blocks should be split into smaller blocks or combined into larger ones, justifying their recommendations.

Assessment example: Students review 4-5 custom blocks and identify which ones violate single responsibility. For example, they identify that `SetupGameAndShowInstructions` should be split into two blocks: `SetupGame` (initializes variables and positions) and `ShowInstructions` (displays tutorial text), explaining how this improves clarity and reusability.

Dependencies:
* T11.G6.01.03: Design complete custom block interfaces before implementation
* T11.G5.05: Analyze a modular program structure

---

ID: T11.G6.08
Topic: T11 – Functions & Procedures
Skill: Evaluate custom block return value design
Description: Students evaluate whether custom blocks correctly use return values versus side effects (setting variables, moving sprites, changing state). They identify blocks that should return a value but instead set a global variable (reducing reusability), and blocks that return values when they should just perform actions. They explain the trade-offs between returning values (more flexible, easier to test) and modifying state (sometimes simpler for certain operations).

Assessment example: Given 5-6 custom block implementations, students identify design issues. For example: "CalculateScore" should return the score value instead of setting a global `score` variable (more flexible); "DrawShape" correctly performs an action without returning anything; "GetPlayerX" should return the x position instead of setting a `playerX` variable.

Dependencies:
* T11.G5.07: Decide whether a custom block should be a command or reporter
* T11.G5.08: Define a custom reporter block that returns a value

---

ID: T11.G6.09
Topic: T11 – Functions & Procedures
Skill: Compare before and after code organization
Description: Students compare two versions of the same program: one written without custom blocks (all inline code) and one properly organized with custom blocks. They create a side-by-side comparison identifying specific improvements in the modular version: readability (easier to see structure), maintainability (changes are localized), reusability (blocks called multiple times), and testability (blocks can be tested individually). This develops critical thinking about when and why to use custom blocks.

Assessment example: Given two implementations of the same game (one 50-block monolithic script, one organized into 6 custom blocks), students write a comparison report identifying 4-5 specific ways the modular version is better, with concrete examples from the code.

Dependencies:
* T11.G6.04: Refactor spaghetti code into organized custom blocks
* T11.G6.02.01: Create a program with 4-6 coordinated custom blocks

---

ID: T11.G7.01
Topic: T11 – Functions & Procedures
Skill: Implement algorithms as reusable custom blocks
Description: Students implement ONE specific algorithm (e.g., linear search through a list, finding the maximum value in a list, computing greatest common divisor, or binary search) as a custom block with clear parameters and return values. They demonstrate that the complex algorithm is encapsulated in a reusable block that hides implementation details—users can call the block without understanding how the algorithm works internally. They test the block with multiple different inputs to verify correctness and reusability.

Assessment example: Students create a `FindMaxInList (listName)` custom reporter block that uses a loop and comparison logic to find the largest value in any list. They test it with different lists (numbers, scores, ages) to demonstrate it works with any list of numbers.

Dependencies:
* T11.G6.01.03: Design complete custom block interfaces before implementation
* T11.G5.08: Define a custom reporter block that returns a value
* T11.G6.04: Refactor spaghetti code into organized custom blocks

---

ID: T11.G7.02.01
Topic: T11 – Functions & Procedures
Skill: Plan a coordinated set of 3-5 custom blocks for one feature
Description: Students design (on paper or as documentation, not code yet) exactly 3-5 related custom blocks that will work together to implement ONE specific game feature or subsystem. They specify each block's interface (name, parameters, return value), describe what it does, and explain how the blocks interact (which blocks call which others). This planning skill ensures thoughtful design before implementation.

Assessment example: Students create a design document for a "Health System" with blocks: `TakeDamage (amount)`, `Heal (amount)`, `IsAlive returns: true/false`, `ShowHealthBar`, explaining that TakeDamage and Heal modify the health variable and call ShowHealthBar, while IsAlive checks if health > 0.

Dependencies:
* T11.G6.02.01: Create a program with 4-6 coordinated custom blocks
* T11.G6.01.03: Design complete custom block interfaces before implementation
* T11.G6.06: Critique custom block naming and parameter choices
* T11.G6.07: Evaluate custom block scope and single responsibility

---

ID: T11.G7.02.02
Topic: T11 – Functions & Procedures
Skill: Implement a coordinated set of custom blocks for one feature
Description: Students implement the custom block set they planned in T11.G7.02.01, creating exactly 3-5 related blocks that work together. They test each block individually and then test the feature as a whole. They demonstrate that the blocks have consistent naming patterns, complementary parameters, and clear division of responsibilities. They show the complete feature working correctly in a demonstration project.

Assessment example: Students implement their planned "Inventory System" with blocks `AddItem (item)`, `RemoveItem (item)`, `HasItem (item) returns: true/false`, `ShowInventory`, and `ClearInventory`. They demonstrate these blocks working together in a simple collection game where players pick up items, check their inventory, and use items.

Dependencies:
* T11.G7.02.01: Plan a coordinated set of 3-5 custom blocks for one feature

---

ID: T11.G7.02.03
Topic: T11 – Functions & Procedures
Skill: Document a coordinated custom block set
Description: Students create comprehensive documentation for their coordinated block set, including: an overview of what the feature does, a list of all blocks with their interfaces, usage examples showing how to call each block, and notes on how the blocks work together. This documentation helps others use the feature without reading the implementation code, demonstrating that well-documented abstractions enable knowledge sharing and code reuse.

Assessment example: Students write documentation for their "Score System" blocks that includes: purpose ("manages player score with combo multipliers"), block list (`AddPoints (points)`, `ApplyMultiplier (multiplier)`, `ResetCombo`, `GetScore returns: current score`), example usage showing a typical scoring sequence, and notes explaining that ResetCombo should be called when the player makes a mistake.

Dependencies:
* T11.G7.02.02: Implement a coordinated set of custom blocks for one feature
* T11.G5.10: Use comments to document custom block purpose

---

ID: T11.G7.03
Topic: T11 – Functions & Procedures
Skill: Understand encapsulation and information hiding
Description: Students understand the principle of encapsulation: a well-designed custom block acts like a "black box" where users only need to know WHAT it does (its interface: name, parameters, return value) and not HOW it does it (the implementation inside). They compare examples of blocks with clean, self-contained interfaces versus blocks that require users to know internal details (like specific variable names used inside). They explain how "information hiding" makes code easier to use, understand, and modify, because changes to internal implementation won't break code that calls the block as long as the interface stays the same.

Assessment example: Students compare two implementations of a score system: (A) custom blocks with clear interfaces that hide internal score tracking in local variables, vs (B) blocks that require callers to directly manipulate global score variables. They explain why version A is better: users don't need to know how score is stored internally, and the implementation can be changed without breaking calling code.

Dependencies:
* T11.G7.01: Implement algorithms as reusable custom blocks
* T11.G6.01.03: Design complete custom block interfaces before implementation
* T11.G6.08: Evaluate custom block return value design

---

ID: T11.G7.04
Topic: T11 – Functions & Procedures
Skill: Trace and debug multi-level custom block calls
Description: Students trace through the execution of a script where custom blocks call other custom blocks (2-3 levels deep). They predict outputs, track variable values through multiple call levels, and identify bugs in the call hierarchy. This reinforces understanding of the call stack: when block A calls block B calls block C, execution goes into C, returns to B, returns to A. They practice debugging errors that only appear when blocks are called in certain combinations.

Assessment example: Given a game script where `UpdateGame` calls `MovePlayer` which calls `CheckBoundary`, and there's a bug in CheckBoundary's logic, students trace through the full execution path to find where the bug occurs, tracking position values through all three block levels.

Dependencies:
* T11.G7.02.02: Implement a coordinated set of custom blocks for one feature
* T11.G5.09: Debug a script with incorrect custom block calls
* T11.G6.05: Add input validation to custom blocks

---

ID: T11.G7.05
Topic: T11 – Functions & Procedures
Skill: Understand when custom blocks call each other (helper blocks)
Description: Students learn that custom blocks can call other custom blocks, and identify "helper blocks" that are primarily called by other custom blocks rather than from main scripts. They understand that breaking complex blocks into smaller helper blocks improves organization and enables reuse at multiple levels. They design block structures where main blocks handle coordination and call helper blocks for specific subtasks.

Assessment example: Students create a `DrawComplexShape` block that calls helper blocks `DrawPolygon (sides)` and `MoveToNextPosition (x) (y)`. They explain that the helper blocks are reusable pieces that DrawComplexShape orchestrates to accomplish its goal.

Dependencies:
* T11.G7.02.02: Implement a coordinated set of custom blocks for one feature
* T11.G7.04: Trace and debug multi-level custom block calls

---

ID: T11.G8.01
Topic: T11 – Functions & Procedures
Skill: Design general-purpose custom blocks with reusable interfaces
Description: Students design 3-5 custom blocks specifically for reuse across different projects or contexts. Unlike project-specific blocks, these have general-purpose interfaces that don't depend on specific sprite names, variable names, or game logic. For example, `CheckCollision (sprite1) (sprite2)` works with ANY sprites, not just "player" and "enemy". Students identify what makes a block general-purpose (parameterizing everything that varies, avoiding hard-coded values, using clear generic names) versus project-specific, and explain the benefits and limitations of general-purpose design.

Assessment example: Students create general-purpose utility blocks like `CheckOverlap (sprite1) (sprite2) returns: true/false`, `ClampValue (value) (min) (max) returns: clamped value`, and `WrapPosition (x) (y) (minX) (maxX) (minY) (maxY)` that could be used in any game project. They explain what makes these reusable (parameterized, no hard-coded game-specific values) versus a block like `CheckPlayerEnemyCollision` which is game-specific.

Dependencies:
* T11.G6.01.03: Design complete custom block interfaces before implementation
* T11.G7.02.02: Implement a coordinated set of custom blocks for one feature
* T11.G7.03: Understand encapsulation and information hiding
* T02.G6.01: Learn the pseudocode generation block
* T04.G6.01: Group snippets by underlying algorithm pattern
* T07.G6.01: Trace nested loops with variable bounds

---

ID: T11.G8.02
Topic: T11 – Functions & Procedures
Skill: Demonstrate custom block reuse across multiple contexts
Description: Students create a small library of 3-4 general-purpose custom blocks and demonstrate their reusability by using EACH block in at least TWO different contexts within a project or across two small projects. For example, a `CheckOverlap (sprite1) (sprite2)` block might be used for both player-enemy collision AND player-collectible collision. They document how the same block interface serves multiple purposes without modification, demonstrating that good abstraction enables code reuse.

Assessment example: Students create utility blocks for games (e.g., `RandomPosition (minX) (maxX) (minY) (maxY)`, `WrapAround (sprite) (minX) (maxX) (minY) (maxY)`, `ClampValue (value) (min) (max) returns: value`) and use each block in multiple different game mechanics (enemy spawning, player wrapping, collectible placement, health clamping, speed limiting), showing that good abstraction reduces code duplication across the project.

Dependencies:
* T11.G8.01: Design general-purpose custom blocks with reusable interfaces
* T08.G6.01: Use conditionals to control simulation steps
* T09.G6.01: Model real-world quantities using variables and formulas
* T02.G6.01: Learn the pseudocode generation block
* T04.G6.01: Group snippets by underlying algorithm pattern
* T09.G6.02: Apply operator precedence rules (PEMDAS) in expressions

---

ID: T11.G8.03
Topic: T11 – Functions & Procedures
Skill: Refactor a large program into a hierarchical block structure
Description: Students take a large, unorganized program (30+ blocks) and reorganize it using a thoughtful hierarchy of custom blocks: top-level blocks that coordinate major features, mid-level blocks that implement specific features by calling helper blocks, and low-level utility blocks that handle common operations. They create a diagram showing the hierarchy (which blocks call which others) and document how the structure improves clarity and maintainability. They demonstrate that changes to low-level blocks propagate correctly through the hierarchy.

Assessment example: Students refactor a 40-block game into a hierarchy: main script calls `SetupGame`, `RunGameLoop`, `ShowGameOver`; RunGameLoop calls `ProcessInput`, `UpdateGame`, `RenderFrame`; UpdateGame calls `MovePlayer`, `UpdateEnemies`, `CheckCollisions`; and several utility blocks like `ClampPosition` and `CheckOverlap` are called by multiple blocks. They create a call diagram showing this structure.

Dependencies:
* T11.G7.02.02: Implement a coordinated set of custom blocks for one feature
* T11.G7.03: Understand encapsulation and information hiding
* T11.G7.04: Trace and debug multi-level custom block calls
* T09.G6.01: Model real-world quantities using variables and formulas
* T17.G6.01: Configure surface friction parameters
* T22.G6.01.01: Make a basic ChatGPT request with one parameter

---

ID: T11.G8.04
Topic: T11 – Functions & Procedures
Skill: Create custom blocks that work with lists and complex data
Description: Students create custom blocks that accept and return lists or structured data, enabling powerful abstractions for managing collections. They implement blocks like `FilterList (listName) (condition) returns: filtered list`, `FindInList (listName) (value) returns: index or -1`, or blocks that manage game entities stored as lists of structured data. These blocks demonstrate that custom blocks can handle complex data types, not just simple numbers and strings.

Assessment example: Students create an inventory system using list-based custom blocks: `AddItemToInventory (itemList) (itemName) (quantity)`, `RemoveItemFromInventory (itemList) (itemName) (quantity) returns: success`, `FindItem (itemList) (itemName) returns: index`, showing how blocks can encapsulate complex list operations.

Dependencies:
* T11.G8.01: Design general-purpose custom blocks with reusable interfaces
* T10.G7.01: Use lists of lists (2D lists) to store tabular data
* T11.G7.02.02: Implement a coordinated set of custom blocks for one feature
* T11.G7.03: Understand encapsulation and information hiding
* T07.G6.01: Trace nested loops with variable bounds
* T08.G6.01: Use conditionals to control simulation steps
* T09.G6.01: Model real-world quantities using variables and formulas

---

ID: T11.G8.05
Topic: T11 – Functions & Procedures
Skill: Analyze trade-offs between modular and inline code
Description: Students examine two versions of a program: one organized into many custom blocks, one written mostly inline. They discuss trade-offs in readability (blocks add abstraction but also indirection), maintainability (blocks make changes easier but add complexity), code reuse (blocks enable reuse but require good design), and cognitive load (blocks can simplify OR complicate depending on design quality). They develop critical thinking about when and how much to modularize, understanding that over-modularization (too many tiny blocks) can be as problematic as under-modularization (huge monolithic scripts).

Assessment example: Students compare three versions of the same program: (A) all inline (50 blocks), (B) reasonably modular (6-8 custom blocks), (C) overly modular (20+ tiny custom blocks). They write an analysis explaining why version B is often best, but identifying scenarios where A or C might be preferable.

Dependencies:
* T11.G8.03: Refactor a large program into a hierarchical block structure
* T11.G7.03: Understand encapsulation and information hiding
* T11.G7.04: Trace and debug multi-level custom block calls
* T05.G6.01: Apply empathy, needs, and accessibility checklist to a design
* T09.G6.01: Model real-world quantities using variables and formulas
* T13.G6.01: Trace complex code with multiple variables

---

ID: T11.G8.06
Topic: T11 – Functions & Procedures
Skill: Create a reusable block library across projects
Description: Students create a collection of 5-8 general-purpose custom blocks designed to be copied and reused across multiple different projects. They organize these blocks into a "library" project that serves as a starting point or reference. The blocks cover common needs like collision detection, mathematical utilities, drawing helpers, or input handling. Students document each block's interface and usage, and demonstrate copying blocks from the library into 2-3 different new projects where they're immediately useful without modification.

Assessment example: Students create a "Game Utilities Library" with blocks like `CheckCollision (sprite1) (sprite2)`, `ClampValue (val) (min) (max)`, `RandomRange (min) (max)`, `WrapAround (sprite)`, `DistanceBetween (x1) (y1) (x2) (y2)`. They demonstrate copying these blocks into different game projects (platformer, shooter, puzzle game) where they work without changes.

Dependencies:
* T11.G8.01: Design general-purpose custom blocks with reusable interfaces
* T11.G8.02: Demonstrate custom block reuse across multiple contexts

---

ID: T11.G8.07
Topic: T11 – Functions & Procedures
Skill: Refactor redundant custom blocks into general versions
Description: Students examine a project with multiple similar custom blocks that have slight variations (e.g., `CheckPlayerEnemyCollision`, `CheckPlayerCoinCollision`, `CheckEnemyWallCollision`) and refactor them into one general-purpose block with appropriate parameters (e.g., `CheckCollision (sprite1) (sprite2)`). They replace all calls to the specific blocks with calls to the general block, testing that behavior remains the same. This teaches the skill of recognizing patterns in code and extracting generalizations that reduce duplication while maintaining functionality.

Assessment example: Students find a project with separate blocks for `DrawRedSquare (size)`, `DrawBlueSquare (size)`, `DrawGreenSquare (size)` and refactor into one `DrawSquare (size) (color)` block, updating all callers and verifying the program still works correctly.

Dependencies:
* T11.G8.01: Design general-purpose custom blocks with reusable interfaces
* T11.G6.04: Refactor spaghetti code into organized custom blocks
* T11.G5.12: Identify when code duplication signals need for custom block
