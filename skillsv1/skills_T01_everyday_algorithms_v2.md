# T01 – Everyday Algorithms & Step‑by‑Step Thinking: K–8 Skill List (v2)

Topic reference: `T01 Everyday Algorithms & Step‑by‑Step Thinking` in `domains_topics_overview.md`  
Domain: Algorithms & Design (D1) · Primary CSTA focus: ALG‑AF (with links to ALG‑PS, ALG‑IM, PRO‑PF, PRO‑TR)

This v2 revision:

- Aligns tightly with the **CSTA Draft 2.0 K–8 standards** in `docs/CSTA_STANDARDS_REFERENCE.md`.
- Honors the **K–2 picture-based framework** and quality constraints in `docs/K2_QUALITY_GUIDELINES.md`.
- Clarifies the boundary between **T01 (everyday algorithms & design)** and **T02 (representation & tracing)**.
- Right-sizes several **middle-school skills** so each remains a single, auto‑gradable objective (IXL‑style).

Each skill below has:

- a stable **ID** (`T01.G<grade>.<nn>`),
- an IXL‑style **short name**,
- a **description** (what understanding/behavior it targets),
- a **challenge format** (the typical problem type to assess it).

Where relevant, a primary **CSTA code** is noted.

---

## Grade K (PreK–K)

Students in kindergarten recognize simple, everyday routines and processes as algorithms. Activities are unplugged or picture‑based digital tasks and focus on following and ordering **3‑step sequences** in familiar contexts. The emphasis is on concrete, intuitive understanding of “first, next, last.”

All Grade K skills are implemented as **picture‑based, drag‑and‑drop activities** consistent with `k2_skill_format_spec.json`.

### T01.GK.01 – Identify steps in a simple routine

- **Short name:** Put everyday steps in order  
- **Description:** Students identify and arrange the steps in a familiar 3‑step routine (e.g., getting ready for bed, arriving at school). They recognize that the steps have a sensible order and that mixing them up makes the routine confusing. This builds awareness that everyday tasks follow algorithms.  
- **Challenge format:** Picture‑based, drag‑drop sequence. Show three images (for example: “put on pajamas,” “brush teeth,” “get in bed”) in random order. Students drag them into first/next/last slots. Auto‑grading checks for the exact correct order.  
- **CSTA:** EK‑ALG‑AF‑01 (Identify algorithms in daily activities).

### T01.GK.02 – Follow directions with a sequence of steps

- **Short name:** Follow a short set of directions  
- **Description:** Students follow a short sequence of simple instructions (e.g., “Stand up. Touch your head. Sit down.”) and notice that they must pay attention to the order. Mistakes when skipping or reordering steps highlight the importance of sequence.  
- **Challenge format:** Unplugged or onscreen guided activity. Teacher or system presents a 3‑step direction set; students act it out or move a character on a grid with arrows. Auto‑grading (in digital version) uses a path‑tracing interaction where students drag arrow cards into order and the system simulates the path to confirm the goal is reached.  
- **CSTA:** EK‑ALG‑AF‑01, EK‑ALG‑PS‑03 (Identify individual parts of a whole).

### T01.GK.03 – Order picture story panels into a sequence

- **Short name:** Put story pictures in order  
- **Description:** Students arrange 3–4 picture panels to tell a short story (e.g., “put on shirt,” “put on pants,” “put on shoes,” “go outside”). They understand that story events must happen in a sensible order and that algorithms work similarly.  
- **Challenge format:** Picture‑based, drag‑and‑drop sequence. Show scrambled panels; students drag into 3–4 slots. Auto‑grading verifies the final sequence matches the correct story.  
- **CSTA:** EK‑ALG‑AF‑01, EK‑ALG‑PS‑03.

### T01.GK.04 – Describe a simple repeating pattern of actions

- **Short name:** Spot actions that repeat  
- **Description:** Students observe a simple repeating action pattern (e.g., “hop, clap, hop, clap” or “spin, jump, spin, jump”) and describe what happens “again and again.” This prepares them for loops later while keeping the focus on everyday actions, not code.  
- **Challenge format:** Picture‑based guided observation. An animation or picture sequence shows a short pattern repeated several times. Students answer questions like “What does the person do over and over?” by choosing a picture pair that represents the repeating unit. Auto‑grading checks the selected pattern.  
- **CSTA:** EK‑ALG‑AF‑01, EK‑ALG‑PS‑03.

---

## Grade 1

Grade 1 students formalize their understanding of algorithms as **clear step‑by‑step instructions** with a start and end. They work mostly with **picture sequences and simple language**, occasionally seeing very short code‑like scripts as stories about what a character does.

### T01.G1.01 – Create steps for a simple everyday task

- **Short name:** Make step‑by‑step instructions  
- **Description:** Students create a sequence of simple steps for a familiar task (e.g., planting a seed, getting ready for recess). They understand that clear, ordered steps form an algorithm that someone else can follow.  
- **Challenge format:** Picture‑based guided creation. Provide images representing steps (e.g., “get a pot,” “add soil,” “put seed in,” “water”). Students drag pictures onto numbered slots (1, 2, 3, 4). Auto‑grading checks order and that no steps are missing.  
- **CSTA:** E1‑ALG‑AF‑01 (Create algorithms that include step‑by‑step instructions).

### T01.G1.02 – Predict the next step in a story sequence

- **Short name:** What happens next?  
- **Description:** Students look at a 3‑picture sequence that shows the start of a routine or story and predict the next step by choosing from picture options. This introduces **algorithmic prediction** based on current state.  
- **Challenge format:** Picture‑based multiple choice. Show three panels in order plus 3–4 options for “what happens next.” Students click the correct picture. Auto‑grading checks the chosen option.  
- **CSTA:** E1‑ALG‑AF‑01, E1‑ALG‑PS‑03 (Describe the function of individual parts in a system).

### T01.G1.03 – Identify a missing or incorrect step in an algorithm

- **Short name:** Find the missing step  
- **Description:** Students inspect a picture sequence or short set of written steps for a familiar task (e.g., baking cookies) where one key step is missing or incorrect. They identify what is wrong and choose the step that fixes the algorithm.  
- **Challenge format:** Picture‑based click‑select. Show a 3–4 panel sequence with a missing slot or an obviously wrong panel. Provide 3–4 candidate step pictures. Students click the missing or correct step. Auto‑grading checks the selection.  
- **CSTA:** E1‑ALG‑AF‑01, E1‑ALG‑PS‑03.

### T01.G1.04 – Compare two algorithms for the same task

- **Short name:** Which instructions are better?  
- **Description:** Students compare two short sets of steps that both complete the same everyday task (e.g., cleaning a desk) but differ in order or clarity. They decide if both work, or which is easier to follow, introducing the idea that **multiple algorithms** can solve one problem.  
- **Challenge format:** Concept, visual comparison. Show two picture or text sequences side‑by‑side. Ask questions like “Do both get the desk clean?” or “Which uses fewer steps?” Students answer via multiple choice. Auto‑grading checks the response.  
- **CSTA:** E1‑ALG‑AF‑01, E1‑ALG‑PS‑03.

---

## Grade 2

Grade 2 introduces **branching (if/then choices)** and **repetition** in everyday algorithms. Students still mostly use natural language and pictures, but begin to recognize **“if… then…”** and **“do it again”** patterns that will later map to conditionals and loops in code.

### T01.G2.01 – Write an algorithm that includes an if/then choice

- **Short name:** Add an if/then choice to steps  
- **Description:** Students complete or create a simple everyday algorithm that includes a branching point (e.g., “If it is raining, take an umbrella. If it is not raining, wear a hat.”). They see that algorithms can follow different paths depending on a condition.  
- **Challenge format:** Concept, guided template. Provide a sentence frame like “If ___, then ___. If not, then ___.” and a scenario with pictures (rainy vs sunny). Students drag words/pictures into blanks or choose from options. Auto‑grading checks that conditions and actions are correctly paired.  
- **CSTA:** E2‑ALG‑AF‑01 (Model daily processes by creating and following algorithms with sequence, events, and iteration).

### T01.G2.02 – Write an algorithm using “repeat” or “do again”

- **Short name:** Use “repeat” in everyday steps  
- **Description:** Students describe a routine that repeats actions many times (e.g., “brush 20 times,” “clap 5 times”) using natural language like “repeat ___ times” instead of listing the same step over and over. This prepares them for loops in code.  
- **Challenge format:** Concept, guided template. Show an example (e.g., 5 pictures of tooth‑brushing in a row). Students choose between “brush, brush, brush, brush, brush” and “repeat 5 times: brush teeth,” or drag a “repeat 5” card next to one action picture. Auto‑grading checks for correct use of repeat language.  
- **CSTA:** E2‑ALG‑AF‑01, E2‑ALG‑PS‑03 (Modify algorithms with repeating patterns to use iteration).

### T01.G2.03 – Trace an algorithm that includes choices or repeats

- **Short name:** Follow steps with choices or repeats  
- **Description:** Given a short everyday algorithm that includes an if/then choice or a repeat, students trace through it step by step and predict the outcome (e.g., a final number, which door is used, or how many actions happen).  
- **Challenge format:** Concept, interactive tracing. Show a simple numeric or picture‑based algorithm (e.g., “Start with 4. If the number is even, add 10. If it is odd, subtract 5.”). Students trace or simulate it and choose the final result from options. Auto‑grading compares to the correct outcome.  
- **CSTA:** E2‑ALG‑AF‑01, E2‑ALG‑PS‑03.

### T01.G2.04 – Write directions to navigate a simple maze

- **Short name:** Give step‑by‑step maze directions  
- **Description:** Students write or assemble a list of directional steps (Forward, Turn Left, Turn Right, Stop) that guide a character through a small grid or maze to reach a goal. This combines sequencing with spatial reasoning as a bridge to coordinate‑based coding.  
- **Challenge format:** Path‑tracing digital activity. Show a grid with a start and goal. Students drag arrow icons into a sequence bar to form instructions. The system animates the path to confirm whether the goal is reached without hitting walls. Auto‑grading checks successful navigation.  
- **CSTA:** E2‑ALG‑AF‑01, E2‑ALG‑PS‑03.

---

## Grade 3

Grade 3 is the transition from unplugged algorithms to **block‑based code in CreatiCode**. Students now create and refine algorithms in code that include sequence, basic events, simple conditionals, and loops, then explain what those algorithms do.

### T01.G3.01 – Create a simple coded algorithm (sequence and events)

- **Short name:** Write a sequence of blocks in code  
- **Description:** Students create a short program in CreatiCode where a sprite follows a sequence of steps triggered by an event (e.g., the green flag). Example: “When green flag clicked, move 10 steps, turn 90 degrees, move 10 steps, say ‘Done!’.” This is their first coded algorithm focusing on sequence and events.  
- **Challenge format:** Coding, starter project. Provide a sprite and basic motion/say blocks. Prompt: “Make the sprite move in an L‑shape and then say ‘Hello!’.” Auto‑grading checks (1) presence of the event block, (2) correct block order, and (3) final visible behavior.  
- **CSTA:** E3‑ALG‑AF‑01, E3‑PRO‑PF‑01.

### T01.G3.02 – Add a simple if/then condition to an algorithm

- **Short name:** Add a choice to your program  
- **Description:** Students modify an existing script to include an if/then condition (e.g., “If touching the goal, say ‘Victory!’.”). They see how algorithms can react differently based on conditions in the program.  
- **Challenge format:** Coding, scaffolded editing. Provide a movement script and ask students to insert an `if touching color [goal]` or `if key [space] pressed` block with an action inside. Auto‑grading checks (1) correct placement of the if block, (2) appropriate condition, and (3) correct behavior when the condition is met.  
- **CSTA:** E3‑ALG‑AF‑01, E3‑PRO‑PF‑01.

### T01.G3.03 – Use a loop in code for repetition

- **Short name:** Use a repeat block in code  
- **Description:** Students create or modify a program to use a loop (`repeat` or `forever`) so a sequence of actions happens multiple times. Example: `repeat 4 { move 10; turn 90 }` to walk in a square. This connects their earlier “repeat” language to actual loop blocks.  
- **Challenge format:** Coding, starter project. Prompt: “Make the sprite turn 4 times to face all directions.” Students use a `repeat 4` block containing a `turn 90` block. Auto‑grading verifies the loop structure, repeat count, and that the sprite ends facing the original direction.  
- **CSTA:** E3‑ALG‑AF‑01, E3‑PRO‑PF‑01.

### T01.G3.04 – Describe what a simple program’s algorithm does

- **Short name:** Explain what the program does  
- **Description:** After running a short program, students explain in everyday language what the algorithm does (e.g., “The sprite moves forward, then spins around 3 times and says ‘Woohoo!’.”). This strengthens mental models of algorithm behavior.  
- **Challenge format:** Concept, code‑reading item. Show a short CreatiCode script and provide 3–4 possible descriptions. Students pick the best description or write a 1–2 sentence explanation. Auto‑grading checks for matching description or key ideas in the student answer.  
- **CSTA:** E3‑ALG‑AF‑01, E3‑ALG‑PS‑03.

---

## Grade 4

Grade 4 emphasizes **designing, improving, and tracing** algorithms in code. Students solve simple problems, optimize their solutions, and use variables as part of algorithm design.

### T01.G4.01 – Design an algorithm to solve a simple problem

- **Short name:** Design a program to solve a problem  
- **Description:** Given a problem statement (e.g., “Make a sprite navigate to the goal without touching walls”), students design or refine an algorithm in code that meets the goal. This shifts emphasis from following directions to **planning an algorithm** that solves a problem.  
- **Challenge format:** Coding, problem‑solving challenge. Provide a starter project with sprites and obstacles. Prompt: “Create a program where the sprite reaches the flag without touching red walls.” Auto‑grading checks goal attainment and basic structural expectations (use of events, loops, and/or conditionals as appropriate).  
- **CSTA:** E4‑ALG‑AF‑01.

### T01.G4.02 – Improve an algorithm to use fewer steps

- **Short name:** Make an algorithm more efficient  
- **Description:** Students compare two algorithms that both solve a problem, then refactor code to remove obvious repetition or unnecessary checks (e.g., replacing five identical movements with a `repeat 5` loop). They see that algorithm design includes **clarity and efficiency**, not just correctness.  
- **Challenge format:** Coding, refactor challenge. Provide a script with copy‑pasted blocks or redundant checks. Prompt: “Rewrite this program so it uses fewer blocks but does the same thing.” Auto‑grading checks that behavior is unchanged and that repeated patterns are replaced with loops or simpler logic.  
- **CSTA:** E4‑ALG‑AF‑01, E4‑ALG‑PS‑03.

### T01.G4.03 – Use a variable (counter) in an algorithm

- **Short name:** Use a variable to track something  
- **Description:** Students create and use a simple variable (e.g., `score`, `steps`, `lives`) as part of their algorithm. Example: add 1 to `coins` each time the sprite touches a coin. This embeds basic data handling into algorithm design.  
- **Challenge format:** Coding, starter project. Provide a project with a sprite and collectible objects. Students create or use an existing variable and update it in the correct event (e.g., on collision). Auto‑grading checks that the variable is initialized, updated correctly, and displayed.  
- **CSTA:** E4‑ALG‑AF‑01, E4‑PRO‑DH‑02.

### T01.G4.04 – Trace and predict a multi‑step algorithm

- **Short name:** Predict what a multi‑step program does  
- **Description:** Given a script that includes sequence, at least one loop, and possibly a variable, students trace it step by step to predict final outcomes (e.g., final position or final variable value). This deepens their ability to simulate algorithms mentally.  
- **Challenge format:** Concept, code‑reading task. Show a script with 6–10 blocks. Ask concrete questions such as “How many times does the sprite move 10 steps?” or “What is the final value of `count`?”. Auto‑grading compares student answers with simulated results.  
- **CSTA:** E4‑ALG‑AF‑01, E4‑ALG‑PS‑03.

---

## Grade 5

Grade 5 students work with **two representations** of algorithms (flowcharts/pseudocode and code) specifically in the context of **everyday problems and CreatiCode projects**. T02 covers broader representation fluency; T01 focuses on algorithm quality for real tasks.

### T01.G5.01 – Implement code from a flowchart or pseudocode

- **Short name:** Convert an algorithm plan into code  
- **Description:** Given a flowchart or pseudocode for a small real‑world task (e.g., “ask for a number; if > 10 say ‘Big’, else say ‘Small’”), students create matching block‑based code in CreatiCode. The focus is on faithfully turning an **algorithm plan** into a working program.  
- **Challenge format:** Coding, translation challenge. Provide a simple flowchart or pseudocode plus a starter project. Students add appropriate blocks (questions, if/else, output). Auto‑grading checks conditional structure and behavior on test inputs.  
- **CSTA:** E5‑ALG‑AF‑01, E5‑PRO‑PF‑01.

### T01.G5.02 – Represent a coded algorithm as a flowchart or pseudocode

- **Short name:** Turn a program into a flowchart or pseudocode  
- **Description:** Given a short CreatiCode program that solves an everyday problem, students create a flowchart or structured pseudocode that represents its algorithm (start/end, decisions, loops, variables). This reinforces understanding of the **logic behind the code**, not the notation itself (which is more fully developed in T02).  
- **Challenge format:** Concept, design task. Provide code and a flowchart/pseudocode template. Students fill in boxes/lines to match decisions and repetition in the code. Auto‑grading or rubric‑based checks look for correct branches, loops, and ordering.  
- **CSTA:** E5‑ALG‑AF‑01, E5‑ALG‑PS‑03.

### T01.G5.03 – Compare two algorithms that solve the same real‑world problem

- **Short name:** Compare different ways to solve a problem  
- **Description:** Students compare two algorithms for the same **real‑world task** (e.g., finding the largest score in a list, or picking a winner in a game) that may differ in number of steps, clarity, or fairness. They decide which is better and explain why, using everyday reasoning (e.g., fewer steps, easier to understand, fairer to players).  
- **Challenge format:** Concept, comparison and explanation. Show two short algorithms in code or pseudocode. Ask questions such as “Do both give the same answer?” and “Which is easier to understand or more fair?” Students answer multiple‑choice and provide a short justification. Auto‑grading checks chosen algorithm and key reasoning (e.g., mentions of steps, clarity, fairness).  
- **CSTA:** E5‑ALG‑AF‑01, E5‑ALG‑PS‑03.

### T01.G5.04 – Debug an algorithm that does not work correctly

- **Short name:** Fix a broken algorithm  
- **Description:** Students are given an algorithm with a logical error (e.g., a loop that runs one time too many, an incorrect comparison, or a missing update). They run the program, identify what is wrong, and correct the algorithm so it works for all given cases.  
- **Challenge format:** Coding, debugging challenge. Provide a starter project with a known bug and a description of expected behavior. Students modify code until tests pass (e.g., the sprite stops at the wall, the count is correct). Auto‑grading checks that the bug is resolved on multiple test cases.  
- **CSTA:** E5‑ALG‑AF‑01, E5‑ALG‑PS‑03, E5‑PRO‑TR‑03.

---

## Grade 6

In middle school, algorithms are studied more formally and in connection with **efficiency, fairness, and structure**. T01 keeps the focus on algorithms used in concrete problems and projects, while T02 deepens representation skills.

### T01.G6.01 – Analyze how an algorithm’s steps scale with input size

- **Short name:** Compare algorithm steps for different input sizes  
- **Description:** Students analyze a pair of simple search algorithms (e.g., linear search vs binary search on a sorted list) and compare how many steps they use for small, medium, and large inputs. They explain which algorithm is more efficient as the input grows.  
- **Challenge format:** Concept, analysis task. Provide pseudocode or block‑based representations of two search algorithms and a table of input sizes (10, 100, 1 000). Students fill in or choose step counts and answer questions like “Which algorithm is faster for 1 000 items?” Auto‑grading checks their step counts and comparisons.  
- **CSTA:** MS‑ALG‑AF‑02 (Describe how data is taken in, stored, processed, and output), MS‑ALG‑PS‑05 (Demonstrate correctness for given inputs).

### T01.G6.02 – Identify bias or unintended consequences in an algorithm

- **Short name:** Spot fairness problems in an algorithm  
- **Description:** Students examine a simple decision algorithm (e.g., criteria for choosing club leaders or awarding badges) and discuss how it might unfairly favor or disadvantage certain groups. They describe the issue and suggest a more fair algorithm.  
- **Challenge format:** Concept, structured reflection. Present a short scenario and algorithm description. Students answer MCQ items about who might be helped or hurt and propose a change using sentence starters. Auto‑grading checks for recognition of a plausible impact and a suggested improvement that addresses the bias.  
- **CSTA:** MS‑ALG‑IM‑08, MS‑ALG‑IM‑09.

### T01.G6.03 – Create a flowchart for a multi‑step computational problem

- **Short name:** Draw a flowchart for a multi‑step task  
- **Description:** Students design a flowchart for a moderately complex algorithm (e.g., a simple quiz game turn: ask question, check answer, update score, decide whether to keep playing). The focus is on **organizing algorithm steps and decisions** for a real CreatiCode‑style project, not on notation in isolation.  
- **Challenge format:** Concept, design task. Provide a project description and a flowchart template (start, process, decision, arrows). Students complete the flowchart showing at least one loop and one decision. Auto‑grading or rubric checks for complete paths, correct use of symbols, and logical order.  
- **CSTA:** MS‑ALG‑AF‑01.

### T01.G6.04 – Implement code from a detailed algorithm flowchart

- **Short name:** Code a program from a flowchart  
- **Description:** Students receive a detailed flowchart with multiple branches and a loop (for example, one turn of a quiz game) and implement it using block‑based or introductory text code. They experience the full cycle of **algorithm‑first, code‑second** development.  
- **Challenge format:** Coding, translation challenge. Provide the flowchart and a starter project. Students add events, conditionals, and loops to match each part of the flowchart. Auto‑grading checks structural correspondences (e.g., each decision box has a matching if/else) and correct behavior on test inputs.  
- **CSTA:** MS‑ALG‑AF‑01, MS‑PRO‑PF‑01.

---

## Grade 7

Grade 7 emphasizes **algorithm patterns**, selecting the right algorithm for a task, and reasoning about correctness and edge cases. Students also begin to move comfortably between block‑based code and pseudocode/text.

### T01.G7.01 – Recognize and apply common algorithm patterns

- **Short name:** Identify algorithm patterns  
- **Description:** Students learn to recognize and name common patterns: linear search, simple sort, accumulation (summing or counting), and simple simulation (repeat and update). When given a problem written in everyday language, they select an appropriate pattern and apply it in code.  
- **Challenge format:** Concept and application. Present short problem descriptions (“Find the student with the highest score,” “Count how many apples are red,” “Reorder names alphabetically”) and multiple pattern choices. Students choose the pattern and, in a second item, complete or select matching code. Auto‑grading checks both pattern choice and code correctness.  
- **CSTA:** MS‑ALG‑AF‑01, MS‑ALG‑AF‑02.

### T01.G7.02 – Choose an appropriate algorithm for a task

- **Short name:** Choose the right algorithm for the task  
- **Description:** Given a problem and several candidate algorithms, students decide which algorithm is most appropriate based on efficiency, clarity, and fit (e.g., choosing binary search over linear search on a large sorted list, or a sort algorithm that requires fewer passes).  
- **Challenge format:** Concept, explanation task. Provide a scenario (e.g., “You have a sorted list of 1 000 000 names and need to find one quickly.”) and two algorithm choices. Students select one and explain why their choice is better in a short sentence. Auto‑grading checks the selected algorithm and looks for key ideas such as “fewer comparisons” or “uses the sorted order.”  
- **CSTA:** MS‑ALG‑PS‑05, MS‑ALG‑PS‑06.

### T01.G7.03 – Represent an algorithm in pseudocode or simple text code

- **Short name:** Write pseudocode for an algorithm  
- **Description:** Students write pseudocode or simple text‑style code for a familiar algorithm pattern (e.g., finding the largest number in a list). They use structured constructs like “for each…,” “if… then…,” and variable updates to express the algorithm precisely.  
- **Challenge format:** Concept and coding. Provide an everyday‑language description of a task (e.g., “Find the tallest student in the line”). Students write pseudocode following a given format. Auto‑grading checks for required elements (loop, conditional, variable initialization and update).  
- **CSTA:** MS‑ALG‑AF‑01, MS‑PRO‑PF‑02.

### T01.G7.04 – Analyze an algorithm for correctness on edge cases

- **Short name:** Test an algorithm on tricky inputs  
- **Description:** Students test a given algorithm (in code or pseudocode) against edge cases such as empty input, single‑element input, maximum/minimum values, or repeated values. They decide whether the algorithm works for all cases and explain failures when they occur.  
- **Challenge format:** Concept, testing and reasoning. Provide an algorithm (e.g., “find max value in a list”) and a set of test cases including edge cases. Students select which tests reveal bugs and explain briefly what goes wrong. Auto‑grading checks identification of failing cases and recognition of the underlying issue (e.g., “doesn’t handle empty list”).  
- **CSTA:** MS‑ALG‑PS‑05, MS‑PRO‑TR‑11.

---

## Grade 8

Grade 8 synthesizes earlier understanding and applies algorithms to **simulations, recursive thinking, and societal impacts**, as well as refining larger programs for clarity and efficiency.

### T01.G8.01 – Design an algorithm for a simple simulation

- **Short name:** Create an algorithm to simulate a process  
- **Description:** Students design the core update rules for a simple simulation (e.g., a one‑species population that grows or shrinks, or objects moving with simple rules). They focus on specifying **one time‑step algorithm**: given the current state, how does the algorithm update it?  
- **Challenge format:** Coding, scoped design challenge. Provide a CreatiCode project that runs a loop for several time steps and stores state in variables (e.g., `population`). Students fill in or write the update rules inside the loop. Auto‑grading checks correct use of variables, conditions, and that the simulation behaves as described for sample inputs.  
- **CSTA:** MS‑ALG‑AF‑01, MS‑ALG‑AF‑02, DAA‑DI.

### T01.G8.02 – Understand recursion conceptually

- **Short name:** Recognize recursive structure in problems  
- **Description:** Students explore the idea that some problems can be solved by breaking them into smaller versions of themselves (e.g., “To find the largest number in a list, compare the first number with the largest of the rest.”). They identify the **base case** and the **recursive step** but do not yet implement recursion in code.  
- **Challenge format:** Concept, explanation and tracing. Present a natural‑language recursive description and ask students to identify the base case, the smaller subproblem, or what happens for a specific small input. Auto‑grading checks for correct identification of base and recursive steps.  
- **CSTA:** MS‑ALG‑PS‑07.

### T01.G8.03 – Analyze the impact of an algorithm on people and society

- **Short name:** Evaluate real‑world algorithm impacts  
- **Description:** Students examine a real‑world algorithmic system (e.g., social media recommendation, search ranking, or school scheduling) and analyze who benefits, who might be harmed, and what ethical issues may arise. They propose improvements that reduce harm or increase fairness.  
- **Challenge format:** Concept, structured reflection. Provide a short reading or scenario and guided prompts such as “Who is helped?”, “Who might be hurt?”, “What change could make this more fair?”. Students respond using sentence frames or multiple‑choice options plus brief explanations. Auto‑grading uses rubric‑like rules to check that they identify at least one plausible impact and an appropriate improvement.  
- **CSTA:** MS‑ALG‑IM‑08, MS‑ALG‑IM‑09.

### T01.G8.04 – Refactor a complex algorithm for clarity or efficiency

- **Short name:** Simplify and optimize complex code  
- **Description:** Given a working but moderately complex program (e.g., 40–60 blocks) with duplicated code and tangled logic, students refactor it to be clearer or more efficient. Typical improvements include extracting repeated logic into a custom block, introducing or improving loops, and renaming variables for readability.  
- **Challenge format:** Coding, focused refactor challenge. Provide an existing CreatiCode project that passes basic tests but contains obvious duplication. Prompt: “Simplify this code while keeping the behavior the same.” Auto‑grading checks that (1) program behavior on tests is unchanged, and (2) specific structural improvements are present (e.g., at least one custom block created from repeated sequences, or total number of blocks reduced by a target amount).  
- **CSTA:** MS‑PRO‑TR‑11, MS‑ALG‑PS‑05.

---

## Grade 9–12 Connection (Preview)

By Grade 8, students have a strong conceptual foundation in algorithms across:

- Everyday step‑by‑step routines and branching decisions.
- Block‑based coding with events, loops, and variables.
- Common algorithmic patterns (search, sort, accumulate, simulate).
- Efficiency, edge cases, fairness, and real‑world impacts.

In high school, they will:

- Study formal algorithm analysis (including Big‑O notation and complexity classes).
- Learn classic sorting and searching algorithms (e.g., merge sort, quicksort, binary search).
- Implement algorithms in text‑based languages (e.g., Python, Java).
- Use more complex data structures and understand how they support algorithm design.
- Engage with AI/ML and probabilistic algorithms that build on earlier simulation and data skills.

The transition from K–8 algorithmic thinking to high school computer science builds directly on this T01 progression, supported by representation and tracing skills in T02, problem decomposition in T03, and loop/conditional/variable skills in T07–T09.

