# T01 – Everyday Algorithms & Step‑by‑Step Thinking: K–8 Skill List (Draft v1)

Topic reference: `T01 Everyday Algorithms & Step‑by‑Step Thinking` in `domains_topics_overview.md`
Domain: Algorithms & Design (D1) · CSTA focus: ALG‑AF (with links to ALG‑HD, ALG‑PS, PRO‑PF)

Each skill below has:

- a stable **ID** (`T01.G<grade>.<nn>`),
- an IXL‑style **short name**,
- a **description** (what understanding/behavior it targets),
- a **challenge format** (the typical problem type to assess it).

Where relevant, a primary **CSTA code** is noted.

---

## Grade K (PreK–K)

Students in kindergarten recognize simple, everyday routines and processes as algorithms. Activities are unplugged and focus on oral descriptions, following sequences of pictures, and identifying the steps in familiar tasks. The emphasis is on concrete, intuitive understanding of "sequence" and "steps."

### T01.GK.01 – Identify steps in a classroom routine

- **Short name:** Recognize steps in daily routines
- **Description:** Students identify and describe the individual steps involved in familiar classroom routines (e.g., lining up, washing hands, getting ready for lunch). They recognize that these routines follow a sequence of actions and that changing the order might change the outcome. This builds awareness that everyday tasks follow algorithms.
- **Challenge format:** Concept, guided activity. A poster or animation shows a familiar routine (e.g., "Morning arrival"). Students are asked to point to or identify the first, middle, and last steps. Alternatively, students narrate the steps aloud or arrange picture cards in order. Auto‑grading uses sequence verification (checking correct order).
- **CSTA:** EK‑ALG‑AF‑01 (Identify algorithms in daily activities).

### T01.GK.02 – Follow directions with a sequence of steps

- **Short name:** Follow a sequence of directions
- **Description:** Students physically follow multi‑step instructions (e.g., "Stand up, raise your hand, turn around"). They understand that direction‑following requires attention to the order of steps and that mistakes happen when steps are skipped or reordered.
- **Challenge format:** Concept, interactive unplugged activity. Teacher or system provides a sequence of simple directions; students execute them in order. The system confirms successful completion. Variants include moving a toy through a path following arrow cards (up, left, right) or sorting objects into categories based on a sequence of yes/no questions.
- **CSTA:** EK‑ALG‑AF‑01, EK‑ALG‑PS‑03 (Identify individual parts of a whole).

### T01.GK.03 – Order picture story panels into a sequence

- **Short name:** Put story pictures in order
- **Description:** Students arrange picture cards to show a logical sequence (e.g., three or four panels depicting "getting dressed": shirt, pants, shoes, then out the door). They recognize that the order of events matters and that a different order changes the story or makes it nonsensical.
- **Challenge format:** Concept, multiple choice or drag-and-drop. Show four picture cards in scrambled order and ask students to arrange them to tell the correct story. Only one correct order is accepted. Auto‑grading verifies the final sequence.
- **CSTA:** EK‑ALG‑AF‑01, EK‑ALG‑PS‑03.

### T01.GK.04 – Describe a repeating pattern of actions

- **Short name:** Spot and describe repeating actions
- **Description:** Students observe a simple, repeating pattern of actions (e.g., hop, clap, hop, clap repeated three times) and describe what happens over and over. This bridges the idea of a routine into recognizing repetition, a key algorithmic concept. (This skill relates to T07 but focuses on algorithm mindset rather than loop code.)
- **Challenge format:** Concept, guided observation. Teacher or animation demonstrates a short sequence repeated several times (e.g., spin, jump, spin, jump). Students are asked "What does the person do again and again?" and select or name the repeating action pair. Auto‑grading checks the identified repeating unit.
- **CSTA:** EK‑ALG‑AF‑01, EK‑ALG‑PS‑03.

---

## Grade 1

Grade 1 students formalize their understanding of algorithms as sequences of steps with a clear start and end. They write (or draw) simple algorithms, describe them aloud, and trace through them step-by-step. The focus remains unplugged and concrete, with occasional very simple visual or block-based representations introduced.

### T01.G1.01 – Write or draw steps for a simple task

- **Short name:** Create step-by-step instructions for a task
- **Description:** Students create a sequence of simple, numbered steps to describe how to complete a task (e.g., "Make a sandwich" or "Sharpen a pencil"). They understand that clear, ordered steps form an algorithm and that the person following the instructions should be able to succeed.
- **Challenge format:** Concept/coding, guided creation. Students are given a task and asked to write or draw numbered steps on a template. A teacher or peer checks if the steps are in order and complete. Alternatively, the system provides image/text blocks to arrange. Auto‑grading checks for correct ordering and minimum number of steps.
- **CSTA:** E1‑ALG‑AF‑01 (Create algorithms that include step‑by‑step instructions).

### T01.G1.02 – Trace and predict the outcome of a simple algorithm

- **Short name:** Follow steps to see what happens
- **Description:** Given a short sequence of steps (e.g., "Start at the door. Walk forward 3 steps. Turn left. Walk forward 2 steps. Stop."), students predict or trace where they end up or what object they reach. This develops the practice of mental simulation and reasoning about algorithm behavior.
- **Challenge format:** Concept, interactive tracing. Show a simple algorithm written as steps or drawn as arrows on a grid/maze. Ask students to trace a path and predict the outcome (e.g., which room or object is reached). Provide a simple visual grid for reference. Auto‑grading compares the chosen outcome to the correct result.
- **CSTA:** E1‑ALG‑AF‑01, E1‑ALG‑PS‑03 (Describe function of parts within a system).

### T01.G1.03 – Identify missing or incorrect steps in an algorithm

- **Short name:** Find the mistake in instructions
- **Description:** Students read or listen to a short algorithm (e.g., "To get to the playground: Leave classroom, go to playground entrance, go through gate, walk to swings" but it's missing "go down the hallway"). They identify what step is missing or wrong and suggest what should be added or changed.
- **Challenge format:** Concept, multiple choice or open response. Show a sequence of steps and either mark one as wrong, or ask "What step is missing?" with multiple-choice options. Auto‑grading checks the selected correction.
- **CSTA:** E1‑ALG‑AF‑01, E1‑ALG‑PS‑03.

### T01.G1.04 – Compare two algorithms for the same task

- **Short name:** Compare different ways to do something
- **Description:** Students compare two different sequences of steps that accomplish the same goal (e.g., two different ways to arrange classroom supplies or two paths through a maze). They notice differences and discuss whether both work, which is simpler, or which is faster. This introduces the idea that algorithms can vary.
- **Challenge format:** Concept, comparison task. Show two short algorithms side-by-side and ask: "Do both get you to the same place?" or "Which one uses fewer steps?" Students select the answer. Auto‑grading checks the comparison.
- **CSTA:** E1‑ALG‑AF‑01, E1‑ALG‑PS‑03.

---

## Grade 2

Grade 2 introduces the first unplugged coding-like activity: simple algorithms with branching (if/then thinking) and iteration. Students now write or represent algorithms that include conditions ("if it's raining, use an umbrella") and repetition ("repeat 3 times"). They also begin to encounter very simple block-based or pseudocode representations.

### T01.G2.01 – Write an algorithm with "if/then" choice

- **Short name:** Write steps with a choice (if/then)
- **Description:** Students create or complete a simple algorithm that includes a branching point (e.g., "If the door is locked, ask for a key. If it's open, go inside."). This introduces conditional logic at the algorithm design level, before formal if/else blocks in code.
- **Challenge format:** Concept, guided template. Provide a scenario and a sentence starter: "If _____, then _____ . If _____, then _____." Students fill in missing conditions or outcomes, or choose the correct completion from options. Auto‑grading checks the logical pairing of condition and action.
- **CSTA:** E2‑ALG‑AF‑01 (Model daily processes by creating and following algorithms that include sequence, events, and iteration).

### T01.G2.02 – Write an algorithm with a repeat statement

- **Short name:** Write steps using "repeat" or "do again"
- **Description:** Students create or describe an algorithm using natural language for repetition (e.g., "Repeat 3 times: hop and clap" or "Do these steps until the cup is full: pour water, check level, stop"). This primes the concept of loops before formal loop blocks in code.
- **Challenge format:** Concept, guided template. Show a task and ask students to write or select a description using "repeat" or "do again." Example: "How would you describe brushing your teeth 20 times?" Students choose "Repeat 20 times: brush teeth" vs. listing it 20 times. Auto‑grading checks for use of the repeat concept.
- **CSTA:** E2‑ALG‑AF‑01.

### T01.G2.03 – Trace an algorithm with branching or repetition

- **Short name:** Follow steps with choices or repeats
- **Description:** Given an algorithm that includes an if/then choice or a repeat, students mentally or physically trace through it step by step, predicting the final outcome. This builds the mental model of how algorithms behave when they contain branching or loops.
- **Challenge format:** Concept, interactive tracing or simulation. Show a simple algorithm with branching (e.g., "If the number is even, add 10. If odd, subtract 5. Start with 4."). Students trace or the system animates the process. Ask: "What is the final number?" or "How many times does step X happen?" Auto‑grading compares to simulation.
- **CSTA:** E2‑ALG‑AF‑01, E2‑ALG‑PS‑03 (Modify algorithms with repeating patterns to use iteration).

### T01.G2.04 – Unplugged maze or robot navigation with instructions

- **Short name:** Write directions to navigate a maze
- **Description:** Students create a list of turn-and-move instructions (Forward, Left, Right, Stop) that guide a character or robot through a simple grid or maze to reach a goal. This combines sequencing with spatial reasoning and is a classic unplugged precursor to coordinate-based coding.
- **Challenge format:** Coding, interactive unplugged. Show a small grid or maze and a character's start and goal position. Students write or arrange directional cards/blocks (Forward, Right, Left) in order. The system animates the path or checks if the goal is reached. Auto‑grading verifies goal attainment.
- **CSTA:** E2‑ALG‑AF‑01, E2‑ALG‑PS‑03.

---

## Grade 3

Grade 3 students transition from unplugged activities to simple block-based code in CreatiCode. They now create and refine algorithms in code, including sequences, basic events (when green flag clicked, when key pressed), simple conditionals (if/else), and counters. The focus is still on understanding what algorithms do, not yet on complex optimization.

### T01.G3.01 – Create a simple algorithm in code (sequence and events)

- **Short name:** Write a sequence of blocks in code
- **Description:** Students create a short program using block-based code (in CreatiCode) where a sprite follows a sequence of steps triggered by the green flag. Example: "When green flag clicked, move 10 steps, turn 90 degrees, move 10 steps, say 'Done!'" This is the first coded algorithm, focusing on sequence and events.
- **Challenge format:** Coding, starter project. Provided: a sprite and basic motion/behavior blocks. Prompt: "Make the sprite move in an L‑shape and then say 'Hello!'" Students drag blocks into the script area. Auto‑grading checks (1) correct sequence, (2) correct property values (e.g., steps, angles), and (3) visual or verbal output confirmation.
- **CSTA:** E3‑ALG‑AF‑01 (Write steps in algorithms that include sequence, events, iteration, and selection), E3‑PRO‑PF‑01.

### T01.G3.02 – Add a simple if/then (conditional) to an algorithm

- **Short name:** Add a choice to your algorithm
- **Description:** Students modify a given script to include an if/then condition (e.g., "If touching the goal, say 'Victory!'"). This embeds the conditional logic into code and shows how algorithms can respond differently based on conditions.
- **Challenge format:** Coding, starter project. Provided: a sprite and a script with movement. Students add an `if touching color` or `if key pressed` block with an action (say, play sound, change costume). Auto‑grading checks (1) correct placement of the if block, (2) appropriate condition, and (3) intended action on each run.
- **CSTA:** E3‑ALG‑AF‑01, E3‑PRO‑PF‑01.

### T01.G3.03 – Use a loop in code for repetition

- **Short name:** Use a repeat block in code
- **Description:** Students create a program that uses a repeat (or forever) block to execute a sequence multiple times. Example: Repeat 4 { turn 90 degrees } to spin in a square. This brings the conceptual idea of repetition into actual code.
- **Challenge format:** Coding, starter project. Prompt: "Make the sprite turn 4 times to face all directions." Students use a `repeat 4` block containing a `turn 90` block. Auto‑grading checks (1) correct loop structure, (2) correct repeat count, and (3) final sprite orientation.
- **CSTA:** E3‑ALG‑AF‑01, E3‑PRO‑PF‑01.

### T01.G3.04 – Describe an algorithm in words after running code

- **Short name:** Explain what a program does
- **Description:** After creating or being shown a program, students write or speak a description of what the algorithm does. Example: Given a script with sequence and a loop, they write "The sprite moves forward, then spins around 3 times." This reinforces understanding of algorithm behavior through language.
- **Challenge format:** Concept, code-reading item. Show a short script; students choose a matching written description from options or write a 1–2 sentence explanation. Auto‑grading checks key terms (move, repeat, turn, etc.) and correct behavior description.
- **CSTA:** E3‑ALG‑AF‑01, E3‑ALG‑PS‑03 (Decompose a problem or task into smaller components).

---

## Grade 4

Grade 4 emphasizes algorithm design and refinement. Students create more complex algorithms that combine multiple concepts (sequence, events, conditionals, and simple counters/variables). They also begin to compare and optimize algorithms and think about problem decomposition.

### T01.G4.01 – Create an algorithm to solve a simple problem

- **Short name:** Design a program to solve a problem
- **Description:** Given a problem statement (e.g., "Make a sprite navigate to the goal without touching walls"), students design an algorithm from scratch (or refine a starter project) to solve it. This shifts focus from "following instructions" to "designing instructions to achieve a goal."
- **Challenge format:** Coding, problem-solving challenge. Prompt: "Create a program where the sprite moves to the finish flag without hitting red obstacles." Starter project provides sprites and a grid. Students write the full sequence of moves (using loops and/or conditionals as needed). Auto‑grading checks for goal attainment, no wall collisions, and code structure.
- **CSTA:** E4‑ALG‑AF‑01 (Create visual representations for algorithms that include sequence, events, iteration, and selection).

### T01.G4.02 – Optimize an algorithm (fewer steps or faster)

- **Short name:** Improve an algorithm to use fewer steps
- **Description:** Students compare two algorithms that solve the same problem but one is more efficient (uses fewer blocks, repeats, or conditions). They refactor code to reduce redundancy. Example: replacing five `move 10` blocks with `repeat 5 { move 10 }` or removing an unnecessary check.
- **Challenge format:** Coding, refactor challenge. Provided: a script with obvious repetition or redundancy. Prompt: "Rewrite this script using a loop to make it simpler." Students modify the code to be more efficient. Auto‑grading checks (1) loop or optimization is present, (2) behavior remains the same, and (3) code is shorter/clearer.
- **CSTA:** E4‑ALG‑AF‑01, E4‑ALG‑PS‑03 (Assess an algorithm's effectiveness in solving a problem).

### T01.G4.03 – Use a variable (counter) in an algorithm

- **Short name:** Use a variable to track something
- **Description:** Students create a variable (e.g., `score`, `steps`, `lives`) and use it in their algorithm to track state. Example: increment a score when touching a coin, or decrement lives on collision. This introduces variables as part of algorithm design.
- **Challenge format:** Coding, starter project. Prompt: "Create a program where the sprite collects coins. Use a variable to track how many coins you collect." Starter project provides a sprite, coins, and a placeholder variable. Students add the logic to increment the variable and display it. Auto‑grading checks variable initialization, updates on correct events, and display.
- **CSTA:** E4‑ALG‑AF‑01, E4‑PRO‑DH‑02 (Trace how data flows through a program).

### T01.G4.04 – Trace and predict the behavior of a multi-step algorithm

- **Short name:** Predict what a complex program does
- **Description:** Given an algorithm with sequence, branching, loops, and/or a variable, students trace through it step-by-step and predict the final outcome (e.g., final position, final variable value, sequence of events). This builds mental models of complex behavior.
- **Challenge format:** Concept, code-reading item. Show a script with 6–10 blocks including at least one loop and one conditional. Ask "How many times will the sprite move?" or "What is the final value of X?" with multiple choices. Students trace or the system animates the execution. Auto‑grading compares to simulation.
- **CSTA:** E4‑ALG‑AF‑01, E4‑ALG‑PS‑03.

---

## Grade 5

Grade 5 students engage in formal algorithmic problem-solving and begin to think about algorithm design as a discipline. They create, compare, and analyze algorithms in code, sometimes considering input/output, simple flowcharts, or pseudocode representations. The emphasis is on understanding algorithm structure and correctness.

### T01.G5.01 – Design an algorithm from a flowchart or pseudocode

- **Short name:** Convert a plan to code
- **Description:** Given a flowchart or pseudocode description of an algorithm, students translate it into block-based code in CreatiCode. Example: A flowchart shows "Start → Ask for a number → If number > 10, say 'Big.' Else, say 'Small.' → End." Students implement this with if/else blocks and input.
- **Challenge format:** Coding, translation challenge. Provided: a simple flowchart or pseudocode and a starter project. Students add the necessary blocks to match the flowchart. Auto‑grading checks (1) correct conditional structure, (2) appropriate branches, and (3) correct behavior on test inputs.
- **CSTA:** E5‑ALG‑AF‑01 (Create visual or textual representations of algorithms that include sequence, events, iteration, selection, and variables).

### T01.G5.02 – Create a flowchart or pseudocode for an algorithm in code

- **Short name:** Draw or describe an algorithm plan
- **Description:** Given a program (or a problem), students create a visual flowchart or write pseudocode to represent what it does or what it should do. This is the inverse of G5.01 and reinforces algorithm understanding through representation.
- **Challenge format:** Concept, design task. Prompt: "Your program will ask the user for their age and tell them if they're old enough to vote. Draw a flowchart or write the steps." Students submit a flowchart image (drawn or digital) or pseudocode text. Auto‑grading or rubric checking verifies logical correctness (all branches, decision points clear).
- **CSTA:** E5‑ALG‑AF‑01, E5‑ALG‑PS‑03 (Analyze algorithms for efficiency and accuracy).

### T01.G5.03 – Compare two algorithms for the same problem

- **Short name:** Compare different solutions
- **Description:** Given two algorithms that solve the same problem (e.g., finding the maximum number in a list), students compare them on criteria like correctness, efficiency (number of steps or iterations), readability, or use of variables. They articulate which is better and why.
- **Challenge format:** Concept, comparison plus explanation. Show two coded or pseudocode solutions. Ask: "Which algorithm is more efficient?" or "Which is easier to understand?" with a multiple-choice or written explanation. Auto‑grading checks the choice and key terms in the explanation (e.g., "fewer loops," "clearer variable names").
- **CSTA:** E5‑ALG‑AF‑01, E5‑ALG‑PS‑03.

### T01.G5.04 – Debug an algorithm that doesn't work correctly

- **Short name:** Fix a broken algorithm
- **Description:** Students are given an algorithm with a logical error (e.g., a loop that runs too many times, a condition with wrong comparison, or missing steps) and must identify and fix the error. This develops reasoning about algorithm correctness.
- **Challenge format:** Coding, debugging challenge. Provided: a project with a known bug (e.g., "The sprite should stop at the wall but it goes through."). Students run the program, identify the issue, and fix the code. Auto‑grading checks that the bug is resolved and the corrected behavior matches a reference.
- **CSTA:** E5‑ALG‑AF‑01, E5‑ALG‑PS‑03.

---

## Grade 6

In middle school, algorithms are studied more formally and in context of real-world problem-solving. Students analyze algorithm efficiency, understand different algorithm patterns, and think about algorithmic bias and impacts. The block-based environment is supplemented with more abstract representations (pseudocode, flowcharts, or brief textual code).

### T01.G6.01 – Analyze an algorithm's efficiency in different scenarios

- **Short name:** Compare algorithm speed for different inputs
- **Description:** Students examine an algorithm's performance (number of steps) under different input sizes or conditions. Example: A linear search algorithm is faster on a small list than a binary search is on a small list, but they scale differently. Students compare counts of operations or run time.
- **Challenge format:** Concept, analysis task. Show pseudocode or block code for two search algorithms. Provide test cases with different list sizes (small, medium, large). Ask: "Which algorithm is faster for a list of 1000 items?" Students test or reason about the number of comparisons needed. Auto‑grading checks answer and reasoning quality.
- **CSTA:** MS‑ALG‑AF‑02 (Describe how data is taken in as input, stored, processed, and then produced as output).

### T01.G6.02 – Identify bias or unintended consequences in an algorithm

- **Short name:** Spot fairness problems in an algorithm
- **Description:** Students examine a simple algorithm (often a decision algorithm, like "grading scale" or "student selection criteria") and discuss how it might unfairly impact certain groups. Example: An algorithm that selects only tall students for a team might inadvertently exclude shorter students who are equally qualified. Students articulate the bias and suggest improvements.
- **Challenge format:** Concept, discussion and reflection. Describe a simple algorithm or system (e.g., "Our class awards the 'best helper' to whoever has the fewest missing assignments."). Ask: "Is this fair to all students? Who might this hurt or help?" Students respond in structured text or choose from multiple-choice reflection questions. Auto‑grading scores on awareness of fairness and reasoned suggestions.
- **CSTA:** MS‑ALG‑IM‑08 (Describe common societal impacts, ethical issues, and biases of algorithms).

### T01.G6.03 – Create a flowchart for a multi-step problem

- **Short name:** Draw a flowchart for a complex task
- **Description:** Students create a detailed flowchart that represents a more complex algorithm with multiple decision points and loops. Example: A flowchart for a simple game turn (ask for input, validate, update score, check if won, repeat if not). This strengthens structured thinking about algorithms.
- **Challenge format:** Concept, design task. Prompt: "Create a flowchart for a program that asks players trivia questions until they get 3 wrong, then stops." Students draw (on paper or digitally) a flowchart with appropriate symbols (start/end, decision diamonds, processes, arrows). Auto‑grading or rubric checks structure, logical flow, and completeness.
- **CSTA:** MS‑ALG‑AF‑01 (Optimize visual representations of algorithms).

### T01.G6.04 – Implement an algorithm in code from a complex flowchart

- **Short name:** Code from a detailed flowchart
- **Description:** Students receive a detailed flowchart with multiple branches and loops, then implement it in block-based or introductory text code. This is a direct application of algorithm planning to code.
- **Challenge format:** Coding, translation challenge. Provided: a flowchart (possibly hand-drawn by a peer or digitally created) and a starter code project. Students add blocks to match the flowchart. Auto‑grading checks (1) correct structure (nested if/else, loops), (2) correct decision points, and (3) correct behavior on test inputs.
- **CSTA:** MS‑ALG‑AF‑01, MS‑PRO‑PF‑01.

---

## Grade 7

Grade 7 emphasizes algorithm patterns and their application to real computational problems. Students learn to recognize common algorithmic patterns (search, sort, simulate, accumulate) and understand when each is appropriate. They also continue to reason about algorithm complexity and impacts.

### T01.G7.01 – Recognize and apply common algorithm patterns (search, sort, accumulate)

- **Short name:** Identify algorithm patterns
- **Description:** Students learn to recognize and name common algorithmic patterns: linear search (find first matching item), simple sort (reorder items), accumulation (collect sums or counts), and simulation (repeat action with updates). When given a problem, they choose the appropriate pattern.
- **Challenge format:** Concept, multiple choice and application. Show problem descriptions (e.g., "Find the student with the highest score," "Arrange names alphabetically," "Count how many apples are red.") and ask students to identify the pattern needed. Then provide a starter project using that pattern; students apply it. Auto‑grading checks correct pattern choice and correct implementation.
- **CSTA:** MS‑ALG‑AF‑01, MS‑ALG‑AF‑02.

### T01.G7.02 – Understand why different algorithms are chosen for different problems

- **Short name:** Choose the right algorithm for the task
- **Description:** Given a problem, students consider multiple possible algorithms and justify which is most appropriate based on efficiency, clarity, or fit. Example: Why use a specific sorting algorithm over repeated swaps? Why use binary search instead of linear? This develops algorithmic decision-making.
- **Challenge format:** Concept, explanation task. Prompt: "You have a sorted list of 1,000,000 names and need to find one. Would you use linear search or binary search? Why?" Students select and explain. Auto‑grading checks choice and explanation quality (does it mention efficiency, number of comparisons, etc.?).
- **CSTA:** MS‑ALG‑PS‑05 (Demonstrate correctness of algorithms for given inputs), MS‑ALG‑PS‑06 (Verify whether an algorithm can help solve a problem).

### T01.G7.03 – Represent an algorithm in pseudocode or text code

- **Short name:** Write pseudocode for an algorithm
- **Description:** Students transition from block-based code to pseudocode or simple text-based code representation. They write an algorithm in plain language with code-like structure (e.g., "for each item in list: if item > max, set max = item"). This bridges to more formal programming.
- **Challenge format:** Concept and coding, mixed. Prompt: "Write pseudocode for a program that finds the largest number in a list." Students write text following a simple pseudocode format (for, if, set, print, etc.). Auto‑grading checks for correct structure (loop, conditional, variable update) and logical correctness.
- **CSTA:** MS‑ALG‑AF‑01, MS‑PRO‑PF‑02 (Develop code from algorithms that include variables, data, and storage).

### T01.G7.04 – Analyze an algorithm for correctness on edge cases

- **Short name:** Test an algorithm on tricky inputs
- **Description:** Students test an algorithm (given in code or pseudocode) on edge cases (empty input, single item, maximum/minimum values, repeats) and identify if it fails and why. This develops rigorous thinking about algorithm robustness.
- **Challenge format:** Concept, testing and debugging. Show an algorithm (e.g., finding max value) and provide test cases including edge cases (empty list, single item, all duplicates). Ask: "Does this algorithm work for all cases?" If not, what breaks? Students test and explain failures. Auto‑grading checks if they correctly identify failure cases and understand the reason.
- **CSTA:** MS‑ALG‑PS‑05, MS‑PRO‑TR‑11 (Use standard practices to test, debug, and document code).

---

## Grade 8

Grade 8 synthesizes earlier understanding and applies algorithms to complex real-world modeling and simulation. Students understand the role of algorithms in computational systems, think about recursion or divide-and-conquer concepts, and continue to reason about algorithmic impacts on society.

### T01.G8.01 – Design an algorithm for a simulation or model

- **Short name:** Create an algorithm to simulate a process
- **Description:** Students design an algorithm that simulates a real-world process or system (e.g., a predator-prey ecosystem, weather patterns with simple rules, or traffic flow). The algorithm repeatedly updates state and checks conditions to model behavior over time. This applies algorithmic thinking to simulation.
- **Challenge format:** Coding, design and implementation challenge. Prompt: "Design a program that simulates a simple ecosystem: rabbits eat grass and grow, foxes eat rabbits, grass regrows. Use variables and repeated updates." Students implement the algorithm (loop, updates, conditionals) in block-based or text code. Auto‑grading checks (1) correct use of loops and variables, (2) logical update rules, and (3) reasonable behavior over multiple steps.
- **CSTA:** MS‑ALG‑AF‑01, MS‑ALG‑AF‑02, DAA‑DI (Data Investigations with simulation).

### T01.G8.02 – Understand recursion conceptually (algorithm calling itself)

- **Short name:** Recognize recursive structure in problems
- **Description:** Students encounter the concept that some problems can be solved by breaking them into smaller versions of themselves (recursion conceptually, not yet in code). Example: "To find the largest number in a list, find the larger of the first number and the max of the rest." They understand the base case and recursive case but don't yet implement it in code (that's a high school topic).
- **Challenge format:** Concept, explanation and tracing. Show a problem and a recursive description (in words or pseudocode). Ask: "What is the base case?" or "What smaller problem are we solving?" Students identify or explain the recursive structure. Optionally, trace a simple recursive algorithm on a small input. Auto‑grading checks understanding of base case and recursive decomposition.
- **CSTA:** MS‑ALG‑PS‑07 (Hypothesize about internal processes of black-box systems).

### T01.G8.03 – Analyze the impact of an algorithm on society or individuals

- **Short name:** Evaluate real-world algorithm impacts
- **Description:** Students examine a real-world algorithmic system (e.g., social media recommendation, search rankings, college admission scoring) and analyze its societal impacts. They consider who benefits, who might be harmed, ethical implications, and possible improvements.
- **Challenge format:** Concept, research and reflection. Students research or are given information about an algorithmic system. They write a short report or respond to structured prompts: "How does this algorithm affect different groups?" "What could go wrong?" "How could it be improved?" Auto‑grading uses rubric to score understanding of impacts and thoughtfulness of critique.
- **CSTA:** MS‑ALG‑IM‑08, MS‑ALG‑IM‑09 (Modify an algorithm to address a societal impact or ethical issue).

### T01.G8.04 – Refactor a complex algorithm for clarity or efficiency

- **Short name:** Simplify or optimize complex code
- **Description:** Given a working but convoluted or inefficient algorithm (in block or text code), students refactor it to be clearer, more modular, or more efficient. Example: breaking a long script into named procedures, extracting repeated logic into a loop, or optimizing a search to avoid redundant checks.
- **Challenge format:** Coding, refactor challenge. Provided: a script or code that works but is complex or redundant (100+ lines, lots of copy-paste, or inefficient logic). Prompt: "Simplify this code." Students refactor, possibly creating helper blocks or loops. Auto‑grading checks (1) equivalent behavior, (2) reduced code length or improved clarity, and (3) correct structure (proper use of helper functions, loops, etc.).
- **CSTA:** MS‑PRO‑TR‑11 (Use standard practices to test, debug, and document code), PRO‑TR (Testing and Refining).

---

## Grade 9–12 Connection (Preview)

By Grade 8, students have a strong conceptual foundation in algorithms. In high school, they will:
- Study formal algorithm analysis (Big O notation, complexity classes)
- Learn classic sorting and searching algorithms (merge sort, quicksort, binary search)
- Implement algorithms in text-based languages (Python, Java, etc.)
- Understand data structures and how they support algorithm design
- Engage with AI/ML algorithms and probabilistic algorithms
- Continue analyzing and designing algorithms for real-world problems

The transition from K–8 algorithmic thinking to high school programming and computer science builds directly on the conceptual and practical foundations established in this T01 skill progression.
