# T14 – 2D Games: K–8 Skill List (Draft v1)

Topic reference: `T14 2D Games` in `domains_topics_overview.md`
Domain: Programming (D2) · CSTA focus: PRO‑PF, PRO‑PD (with links to ALG‑AF, ALG‑PS, DAA‑DF, DAA‑DP)

Each skill below has:

- a stable **ID** (`T14.G<grade>.<nn>`),
- an IXL‑style **short name**,
- a **description** (what understanding/behavior it targets),
- a **challenge format** (the typical problem type to assess it).

Where relevant, a primary **CSTA code** is noted.

---

## Grade K (PreK–K)

Games and interactive experiences are introduced through simple cause‑and‑effect patterns and basic game ideas (players, goals, score, start and end), using picture‑based, unplugged activities.

### T14.GK.01 – Match controls to character actions

- **Short name:** Connect a button or card to an action  
- **Description:** Students see pictures of simple controls (e.g., arrow cards, a big “jump” button, a “stop” sign) and pictures of a character moving or reacting. They match each control to the action it causes (e.g., left arrow → move left, jump button → jump), building the idea that an input leads to a game action.  
- **Challenge format:** Concept, picture matching. Show control cards and character action pictures; students drag or connect each control to the matching action. Auto‑grading checks correct control–action pairs.  
- **CSTA:** EK‑PRO‑DH‑03 (Identify gestures and symbols in everyday life that represent information).

### T14.GK.02 – Recognize a score in simple games

- **Short name:** Tell when points go up  
- **Description:** Students look at pictures from simple games (board games, playground games, or screenshots) that show a score or counter (stars, coins, or numbers). They notice when the score increases (e.g., after collecting a star) and what it means to “have more points.”  
- **Challenge format:** Concept, picture‑based questions. Show before/after pictures of a game with a score or stars and ask, “What happened to the score?” or “Who has more points?” Auto‑grading checks multiple‑choice answers.  
- **CSTA:** EK‑PRO‑DH‑03.

### T14.GK.03 – Recognize a game starting and ending

- **Short name:** Spot when a game starts and stops  
- **Description:** Students observe a simple game or picture story with a clear beginning (e.g., “Press start” or “When we say ‘Go!’”) and ending (e.g., “Game Over” or everyone stops moving). They identify which pictures show the start and end of the game, building intuition for game phases.  
- **Challenge format:** Concept, interactive or picture‑based. Show a 3–4 frame storyboard of a simple game: (1) title or start signal, (2) gameplay, (3) game over or finish. Ask students to identify which is the “start” and which is the “end,” or which signal tells players to begin. Auto‑grading checks selected sequence or responses.  
- **CSTA:** EK‑ALG‑AF‑01 (Identify algorithms in daily activities).

---

## Grade 1

Grade 1 students reason about simple game structure: players, goals, obstacles, score, and what makes games easier or harder, all through pictures and stories.

### T14.G1.01 – Identify the player, goal, and obstacles

- **Short name:** Find the player, goal, and dangers  
- **Description:** Students look at a picture of a simple game scene (board, playground, or 2D game screenshot) and identify which character is the player, which objects are goals (e.g., stars or coins), and which are obstacles or dangers (e.g., holes, enemies).  
- **Challenge format:** Concept, hotspot or matching. Students click or drag labels (“player,” “goal,” “danger”) onto objects in the scene. Auto‑grading checks correct labeling.  
- **CSTA:** E1‑ALG‑AF‑01.

### T14.G1.02 – Explain what happens when the player reaches a goal or obstacle

- **Short name:** Say what happens at goals and dangers  
- **Description:** Students match pictures showing the player reaching a goal vs hitting an obstacle with descriptions of what happens (e.g., “You get a point” vs “You must go back to start”). This builds understanding of basic win/lose or progress mechanics.  
- **Challenge format:** Concept, matching. Show small scenarios and short sentences; students connect each scenario to what happens next. Auto‑grading checks matches.  
- **CSTA:** E1‑ALG‑AF‑01.

### T14.G1.03 – Count points when collecting objects

- **Short name:** Add points for collecting things  
- **Description:** Students see sequences of pictures where a player collects objects (e.g., coins, stars) and a score or pile grows. They count how many points should be added and decide the final total or who has more.  
- **Challenge format:** Concept, picture‑based counting. Show a player collecting items step by step and provide answer choices for total points or comparison (“Who has more points?”). Auto‑grading checks numeric or comparative answers.  
- **CSTA:** E1‑PRO‑DH‑02.

### T14.G1.04 – Decide which change makes a game easier or harder

- **Short name:** Pick what makes the game easier or harder  
- **Description:** Students compare two versions of a game (e.g., more obstacles vs fewer, bigger vs smaller goal area) and choose which version would be easier or harder to win, explaining in simple terms.  
- **Challenge format:** Concept, comparison. Show two game layouts side by side and ask, “Which is easier?” or “Which is harder?” with follow‑up choices (“because there are more holes,” “because the goal is closer”). Auto‑grading checks choices and basic reasoning.  
- **CSTA:** E1‑ALG‑PS‑03.

---

## Grade 2

Grade 2 introduces simple notions of game flow (turns that repeat, lives/health, and hazards) and fairness, still at a conceptual, unplugged level.

### T14.G2.01 – Recognize a turn‑based loop in a game

- **Short name:** Notice that turns repeat in order  
- **Description:** Students examine pictures from a simple turn‑based game (e.g., roll‑and‑move board game) and identify the repeating cycle (roll → move → check what happened). They see that the same steps happen again and again in the same order.  
- **Challenge format:** Concept, sequence labeling. Show 3–4 pictures of players taking turns and ask students to arrange or label them as “Step 1, Step 2, Step 3,” then circle the part that repeats. Auto‑grading checks ordering and highlighted cycle.  
- **CSTA:** E2‑ALG‑AF‑01.

### T14.G2.02 – Understand lives or health in games

- **Short name:** Tell what happens when you lose a life  
- **Description:** Students look at game situations where hearts, lives, or health bars decrease when something bad happens (e.g., falling into a hole, bumping an enemy). They explain what happens when lives run out (e.g., “game over” or “start again”).  
- **Challenge format:** Concept, picture‑based questions. Show before/after pictures of lives or health and ask, “What happened?” or “What happens when no hearts are left?” Auto‑grading checks answers.  
- **CSTA:** E2‑PRO‑DH‑02.

### T14.G2.03 – Identify hazards and safe paths on a simple game board

- **Short name:** Find safe paths around hazards  
- **Description:** Students see a simple grid or path with hazards (e.g., holes, spikes, enemies) and goals. They choose paths that reach the goal while avoiding hazards, reinforcing the idea of obstacles and safe movement.  
- **Challenge format:** Concept, path‑tracing. Students trace or choose among 2–3 possible paths; auto‑grading checks whether chosen paths reach the goal without touching hazards.  
- **CSTA:** E2‑ALG‑PS‑03.

### T14.G2.04 – Describe start, play, and end as parts of a game

- **Short name:** Name the parts of a game’s timeline  
- **Description:** Students are shown pictures or descriptions of a game’s title/start, gameplay, and game‑over or celebration. They label each part and describe what players are doing in each phase (getting ready, playing, stopping/resetting).  
- **Challenge format:** Concept, labeling and matching. Provide three labeled boxes (“Start,” “Play,” “End”) and several pictures; students place each picture in the right box and answer a simple question like “What happens at the end?” Auto‑grading checks placements and answers.  
- **CSTA:** E2‑ALG‑AF‑01.

---

## Grade 3

Grade 3 expands to multi‑state games (title, play, game over), more complex collision logic, and refinement of game mechanics.

### T14.G3.01 – Create a title screen and a start button

- **Short name:** Build a game start screen
- **Description:** Students design a title screen that appears when the game loads and is replaced by gameplay when a button is clicked. This introduces simple state management: the game switches from a "start" state to a "play" state.
- **Challenge format:** Coding, guided construction. Starter project includes a backdrop for the title and a button sprite. When the game starts, the button is shown; when clicked, it broadcasts a message (e.g., `game start`) that hides the button and triggers gameplay. Auto‑grading checks that the title screen displays initially and gameplay begins correctly after the button is clicked.
- **CSTA:** E3‑PRO‑PF‑01 (Develop code from a student‑created algorithm that includes sequence, events, iteration, and selection).

### T14.G3.02 – End the game with a game over screen

- **Short name:** Display a game over screen with a message
- **Description:** When a win or loss condition is met, students switch to a "game over" state: gameplay pauses, a screen appears showing the final score or outcome, and the game no longer responds to player input for gameplay (though a "restart" option may be available).
- **Challenge format:** Coding, guided construction. Starter project includes a game over backdrop and a restart button. When `game over` is triggered (e.g., lives reach 0 or goal is reached), students switch the backdrop and broadcast `game over`, which disables gameplay loops. Auto‑grading simulates win/loss conditions and confirms proper state transitions.
- **CSTA:** E3‑PRO‑PF‑01.

### T14.G3.03 – Use a loop to repeatedly spawn enemies

- **Short name:** Create multiple enemies in a loop
- **Description:** Instead of manually placing each enemy sprite, students use a loop to create multiple enemy clones or reset their positions repeatedly, building in a pattern or at intervals. This reduces code duplication and introduces spawning logic.
- **Challenge format:** Coding, guided construction with cloning or list creation. Starter project provides an enemy sprite and a loop outline. Students fill in the loop to create or respawn enemies at intervals (e.g., `repeat 5 { create clone }`). Auto‑grading verifies that the correct number of enemies appear.
- **CSTA:** E3‑PRO‑PF‑01, E3‑ALG‑AF‑01 (Write the steps in algorithms that include sequence, events, iteration, and selection).

### T14.G3.04 – Check multiple win/loss conditions

- **Short name:** End game based on several conditions
- **Description:** Students add multiple conditional branches to check different game‑ending scenarios (e.g., "win if score ≥ 10 OR lose if lives = 0 OR lose if time runs out"). This teaches compound logic in a game context.
- **Challenge format:** Coding, starter project with partial conditions. Students complete the logic using `if`, `else if`, or multiple `if` blocks with compound conditions (e.g., `if score ≥ 10 then set state to win`). Auto‑grading tests various game states and confirms correct transitions.
- **CSTA:** E3‑PRO‑PF‑01.

---

## Grade 4

Grade 4 deepens game mechanics with more sophisticated collision handling, variable timing, and refinement of game behavior.

### T14.G4.01 – Detect different types of collisions

- **Short name:** Handle multiple collision types
- **Description:** Students expand beyond simple "touching" checks to distinguish between collisions with different object types (e.g., `if touching coin` vs `if touching enemy` vs `if touching wall`), each triggering a different outcome. This mirrors real game architecture.
- **Challenge format:** Coding, starter project with multiple sprite types (coins, enemies, obstacles). Students add separate collision checks for each type, each with its own handler (e.g., coins increase score, enemies decrease lives). Auto‑grading simulates multiple collisions and confirms appropriate responses for each type.
- **CSTA:** E4‑PRO‑PF‑01 (Develop code from a student‑created algorithm that includes sequence, events, iteration, and selection).

### T14.G4.02 – Implement simple AI movement for enemies

- **Short name:** Make an enemy move toward or away from the player
- **Description:** Students create a simple AI: enemies move in a pattern (e.g., patrol left‑right) or follow a basic rule (e.g., move toward the player if closer than a distance threshold, otherwise patrol). This introduces algorithmic decision‑making in game design.
- **Challenge format:** Coding, guided construction. Starter project provides an enemy sprite and a player sprite. Students implement a loop that checks the distance or position relationship and moves the enemy accordingly (e.g., `if player x > enemy x then move right`). Auto‑grading verifies that the enemy exhibits the intended behavior.
- **CSTA:** E4‑PRO‑PF‑01.

### T14.G4.03 – Use a timer or counter for paced events

- **Short name:** Trigger events at timed intervals
- **Description:** Students implement a timer variable that increments each frame/loop iteration and triggers events when the timer reaches a threshold (e.g., spawn an enemy every 30 frames, or show a warning when time is low). This teaches event pacing.
- **Challenge format:** Coding, guided construction. Starter project includes a forever loop, a timer variable, and event triggers. Students increment the timer, check if it exceeds a threshold, and reset it. Auto‑grading verifies that events occur at the correct intervals.
- **CSTA:** E4‑PRO‑PF‑01, E4‑PRO‑DH‑02 (Trace how data flows through and alters values in an existing program, using variables).

### T14.G4.04 – Refactor game code for clarity

- **Short name:** Clean up game code and remove duplication
- **Description:** Students review their game code and identify repeated patterns (e.g., multiple similar collision checks or movement sequences) and refactor them using custom blocks or loops to reduce duplication and improve readability.
- **Challenge format:** Coding, refactor challenge. Starter project contains a working game with redundant code (e.g., four nearly identical collision handlers). Students consolidate logic using loops, custom blocks, or conditionals, preserving all functionality. Auto‑grading checks that the refactored code behaves identically and uses fewer lines.
- **CSTA:** E4‑PRO‑PF‑01, E4‑PRO‑PM‑05 (Document a program, using embedded or external comments).

---

## Grade 5

Grade 5 emphasizes game design patterns: camera systems, more complex AI, physics‑like behavior, and data collection in games.

### T14.G5.01 – Implement a scrolling camera for larger worlds

- **Short name:** Make the camera follow the player
- **Description:** Students implement a simple camera/viewport system where the player remains roughly centered on screen and the background scrolls to simulate movement through a larger world. This introduces coordinate transformation concepts.
- **Challenge format:** Coding, guided construction. Starter project includes a player sprite, a wide backdrop, and outline camera logic. Students implement: `camera x = player x - center offset` to track the player. Auto‑grading verifies that the player stays roughly centered and that the world shifts appropriately.
- **CSTA:** E5‑PRO‑PF‑01 (Develop code from student‑created algorithms that include sequence, events, iteration, selection, and variables).

### T14.G5.02 – Create enemy waves or spawning patterns

- **Short name:** Spawn waves of enemies
- **Description:** Students implement more complex enemy spawning: enemies spawn in waves (groups), with varying patterns, timings, and behaviors. This moves beyond simple looping to conditional spawning.
- **Challenge format:** Coding, guided construction. Starter project includes a spawner variable tracking the current wave and a list or counter for enemies. Students implement logic to spawn enemy groups at intervals, increase difficulty (e.g., more enemies in later waves), and detect when all enemies are defeated. Auto‑grading verifies wave progression and enemy counts.
- **CSTA:** E5‑PRO‑PF‑01, E5‑ALG‑AF‑01 (Create visual or textual representations of algorithms that include sequence, events, iteration, selection, and variables).

### T14.G5.03 – Track game statistics (kills, time, accuracy)

- **Short name:** Collect data during gameplay
- **Description:** Students add variables to track gameplay metrics beyond score (e.g., enemies defeated, accuracy percentage, time elapsed, distance traveled) and display or save these statistics for analysis or post‑game summary.
- **Challenge format:** Coding, guided construction. Starter project includes game loop and collision detection. Students add variables for each metric, update them appropriately during gameplay, and display them at the end. Auto‑grading verifies that metrics are calculated correctly and displayed accurately.
- **CSTA:** E5‑PRO‑PF‑01, E5‑PRO‑DH‑02 (Use different types of variables to store, compare, and modify data).

### T14.G5.04 – Implement power‑ups and temporary effects

- **Short name:** Add collectible power‑ups
- **Description:** Students create collectible items that grant temporary bonuses (e.g., invincibility, speed boost, rapid fire), using a timer or flag to track when the effect expires. This teaches state management and timed effects.
- **Challenge format:** Coding, guided construction. Starter project includes a player, a power‑up sprite, and a movement loop. Students add a `power up active` variable and timer; when a power‑up is collected, set the timer and modify player behavior (e.g., `if power up active, speed = 10` else `speed = 5`). Auto‑grading simulates power‑up collection and verifies timed effects.
- **CSTA:** E5‑PRO‑PF‑01.

---

## Grade 6

In middle school, games become more architecturally complex; students focus on designing and implementing systems rather than simple mechanics.

### T14.G6.01 – Design a game state machine

- **Short name:** Manage multiple game states
- **Description:** Students explicitly design and implement a state machine (e.g., using a `game state` variable) to manage transitions between title, menu, playing, paused, and game over states. This formalizes the concept of game states introduced in Grade 3.
- **Challenge format:** Coding, guided design challenge. Students draw or pseudo‑code the state diagram, then implement it using a variable and a main script that dispatches to different behavior based on the state value. Auto‑grading checks that states transition correctly and that state‑specific behaviors execute in the right state.
- **CSTA:** MS‑PRO‑PF‑01 (Analyze how a segment of code works by identifying and describing the roles of key components).

### T14.G6.02 – Implement pixel‑perfect or grid‑based collision

- **Short name:** Refine collision detection accuracy
- **Description:** Students move beyond simple rectangular collision boxes to implement more precise detection: pixel‑perfect collision (checking if visible pixels overlap) or grid‑based collision (checking tile occupancy). This improves game feel and fairness.
- **Challenge format:** Coding, guided construction. Starter project includes collision detection using a custom algorithm (e.g., checking distance thresholds or a collision list/grid). Students refine the logic to improve accuracy. Auto‑grading tests edge cases and verifies that collisions are detected at the correct boundaries.
- **CSTA:** MS‑PRO‑PF‑01, MS‑PRO‑DH‑04 (Represent data, using appropriate data structures, including variables and collection types).

### T14.G6.03 – Use data structures to manage game objects

- **Short name:** Store and update game objects in a list
- **Description:** Instead of hardcoding individual enemy sprites, students use a list to dynamically store game object data (positions, states, velocities). This scales the game architecture: adding more enemies becomes adding to a list rather than duplicating code.
- **Challenge format:** Coding, guided construction. Starter project includes a list structure and loop outline. Students populate the list with object data (e.g., positions), then implement a loop to update and render all objects. Auto‑grading verifies that the list correctly stores and updates game object state.
- **CSTA:** MS‑PRO‑PF‑01, MS‑PRO‑DH‑04.

### T14.G6.04 – Debug game logic systematically

- **Short name:** Find and fix game behavior bugs
- **Description:** Students apply debugging techniques to game‑specific issues: a sprite moves unexpectedly, collisions trigger at wrong times, or scoring is incorrect. They use print/say blocks, trace execution, and isolate failures.
- **Challenge format:** Coding, debugging challenge. Starter project includes a game with one or two intentional bugs (e.g., collision condition is inverted, or enemy spawning loop has off‑by‑one error). Students identify the issue and fix it, with auto‑grading verifying that the corrected behavior matches the specification.
- **CSTA:** MS‑PRO‑TR‑11 (Use standard practices to test, debug, document, and peer‑review code).

---

## Grade 7

Grade 7 emphasizes algorithmic efficiency and advanced mechanics: physics approximation, pathfinding, and large‑scale game data.

### T14.G7.01 – Simulate physics: gravity and jumping

- **Short name:** Add gravity and jumping to platformer
- **Description:** Students implement a simple physics system: a character has velocity in the y‑direction, gravity continuously increases downward velocity, and jumping (pressing a key) sets upward velocity if the character is on the ground. This introduces continuous numerical simulation.
- **Challenge format:** Coding, guided construction. Starter project includes a player sprite and ground sprite. Students implement variables for `velocity y` and `gravity`, update them each frame inside the game loop, and detect ground collision to reset `jumping` state. Auto‑grading simulates gameplay and verifies realistic jump and fall behavior.
- **CSTA:** MS‑PRO‑PF‑01, MS‑ALG‑AF‑01 (Optimize visual representations of algorithms).

### T14.G7.02 – Implement simple pathfinding (waypoints or A*)

- **Short name:** Make an enemy navigate intelligently
- **Description:** Students implement a pathfinding system where enemies move toward a goal or follow a predetermined path. Simple variants use waypoints; more advanced variants approximate A‑star behavior by moving toward the player while avoiding obstacles.
- **Challenge format:** Coding, guided construction. Starter project includes enemy and player sprites, and a waypoints list or grid. Students implement a loop that calculates the next position to move toward (waypoint or player) and updates the enemy position. Auto‑grading verifies that the enemy reaches goals or follows paths correctly.
- **CSTA:** MS‑PRO‑PF‑01, MS‑ALG‑AF‑01.

### T14.G7.03 – Optimize collision checking to avoid lag

- **Short name:** Make collision detection efficient
- **Description:** When a game has many objects, checking all pairs can lag. Students learn to optimize: only check collisions for nearby objects (using quadtrees or spatial hashing concepts), cache results, or reduce check frequency. Even a conceptual understanding of the problem builds algorithmic thinking.
- **Challenge format:** Mixed coding and concept. Starter project includes a game with many objects and noticeable lag. Students implement an optimization (e.g., only check collisions for enemies within a distance of the player, or check every other frame). Auto‑grading measures performance improvement and verifies correctness.
- **CSTA:** MS‑PRO‑PF‑01, MS‑ALG‑PS‑05 (Demonstrate the correctness of algorithms for given inputs).

### T14.G7.04 – Analyze and balance game difficulty

- **Short name:** Tune game difficulty parameters
- **Description:** Students play and analyze their game, identifying difficulty parameters (enemy speed, health, respawn rate, reward amounts), and deliberately adjust them to achieve a specific difficulty curve. They might gather data on success rates or time to completion and use it to guide balance.
- **Challenge format:** Concept and coding. Students build or modify a game, then document difficulty parameters and test outcomes. They write a short reflection explaining their balancing choices. Auto‑grading checks that parameters are adjusted coherently and documentation is clear.
- **CSTA:** MS‑PRO‑TR‑11, MS‑ALG‑PS‑07 (Hypothesize about internal processes and functions of opaque systems).

---

## Grade 8

Grade 8 prepares students for advanced game development by focusing on modularity, data management, and understanding game engine concepts.

### T14.G8.01 – Architect a game using modular custom blocks

- **Short name:** Design game code with reusable functions
- **Description:** Students deliberately design their game architecture using custom blocks (procedures/functions) to encapsulate game systems: collision handler, spawn system, update physics, render, etc. This introduces software engineering principles.
- **Challenge format:** Coding, architectural challenge. Students build a game by defining custom blocks for each system, with clear parameters and separation of concerns. Auto‑grading checks code structure (presence of relevant custom blocks), modularity (each block has a focused purpose), and behavior correctness.
- **CSTA:** MS‑PRO‑PD‑08 (Create modular programs that incorporate sequence, selection, and iteration).

### T14.G8.02 – Implement a particle system (visual effects)

- **Short name:** Create visual feedback with particles
- **Description:** Students implement a simple particle system: many small visual elements (e.g., sparks, smoke) that emit, move, fade, and disappear, creating visual feedback for events (explosions, hits). This combines loops, timing, and array/list management.
- **Challenge format:** Coding, guided construction. Starter project includes particle data (position, velocity, lifetime) and a loop to create and update particles. Students fill in the emission logic (when/how many particles spawn) and the update loop (move particles, decrease lifetime, remove dead ones). Auto‑grading verifies that particles emit on events and behave correctly.
- **CSTA:** MS‑PRO‑PD‑08, MS‑PRO‑DH‑04 (Represent data, using appropriate data structures).

### T14.G8.03 – Design game levels using data structures

- **Short name:** Create levels from tile maps or data
- **Description:** Instead of manually placing each game object, students define levels using data structures (lists of lists, or a string representing a tile map) and a parser that converts the data into actual game objects. This teaches data‑driven design and scales level creation.
- **Challenge format:** Coding, guided construction. Starter project includes a level data structure (e.g., a 2D array of tile IDs) and an outline parser. Students implement the parser to create platforms, obstacles, and collectibles based on the data. Auto‑grading verifies that levels are created correctly and multiple levels can be defined separately.
- **CSTA:** MS‑PRO‑DH‑04, MS‑PRO‑DH‑06 (Use iteration to access, update, and process elements in a collection).

### T14.G8.04 – Document and analyze a complete game system

- **Short name:** Explain game architecture and design choices
- **Description:** Students document their game: architecture diagram showing how systems connect, pseudocode or flowcharts for key algorithms, and written explanations of design choices (why they chose certain collision detection, what difficulty parameters they used, how enemy AI works). This reinforces reflection and communication of complex ideas.
- **Challenge format:** Documentation and reflection. Students create a design document or project report that includes architecture overview, system descriptions, and analysis of design decisions. Auto‑grading checks completeness, clarity, and alignment with the actual code.
- **CSTA:** MS‑PRO‑PM‑16 (Document a program, using comments, descriptive names, and structured guides).

---
