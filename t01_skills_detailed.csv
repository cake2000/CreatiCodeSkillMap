ID,Grade,Skill Title,Description,CSTA,Num Dependencies,Internal Deps,External Deps,All Dependencies
T01.GK.01,GK,Put pictures in order for getting ready for bed,"**Student task:** Look at 3 pictures. Put them in order: first, next, last. **Example:** Put on pajamas, brush teeth, get in bed. _Implementation note: Drag‑drop sequence (3 items). CSTA: EK‑ALG‑AF‑01.__",EK‑ALG‑AF‑01,0,0,0,
T01.GK.02,GK,Put pictures in order for coming to class,"**Student task:** Look at 4 pictures. Put them in the right order. **Example:** Come in, hang up backpack, sit down, listen. _Implementation note: Drag‑drop 4 items. CSTA: EK‑ALG‑AF‑01.__",EK‑ALG‑AF‑01,0,0,0,
T01.GK.03,GK,Find the first and last pictures,**Student task:** Look at pictures in order. Touch the first picture. Touch the last picture. _Implementation note: Click first/last pictures. CSTA: EK‑ALG‑AF‑01.__,EK‑ALG‑AF‑01,1,1,0,* T01.GK.01: Put pictures in order for getting ready for bed
T01.GK.04,GK,Pick the pictures that make sense,"**Student task:** Look at two sets of pictures. Which one makes sense? **Example:** Wash hands → dry hands → eat vs eat → wash hands → dry hands. _Implementation note: Two sequences, choose one. CSTA: EK‑ALG‑AF‑01, EK‑ALG‑IM‑04.__","EK‑ALG‑AF‑01, EK‑ALG‑IM‑04",1,1,0,* T01.GK.01: Put pictures in order for getting ready for bed
T01.GK.05,GK,Move the picture that's in the wrong place,"**Student task:** Look at the pictures. One picture is in the wrong place. Move it to the right place. _Implementation note: Drag the ""wrong"" card into correct position. CSTA: EK‑ALG‑AF‑01, EK‑ALG‑PS‑03.__","EK‑ALG‑AF‑01, EK‑ALG‑PS‑03",1,1,0,* T01.GK.03: Find the first and last pictures
T01.GK.06,GK,What comes next?,"**Student task:** Look at the first two pictures. What should come last? _Implementation note: MCQ, choose final picture. CSTA: EK‑ALG‑AF‑01.__",EK‑ALG‑AF‑01,1,1,0,* T01.GK.01: Put pictures in order for getting ready for bed
T01.GK.07,GK,Find the pattern that repeats,"**Student task:** Watch the actions. Which two actions happen over and over? **Example:** hop–clap–hop–clap _Implementation note: Visual pattern MCQ. CSTA: EK‑ALG‑AF‑01, EK‑ALG‑PS‑03.__","EK‑ALG‑AF‑01, EK‑ALG‑PS‑03",1,1,0,* T01.GK.03: Find the first and last pictures
T01.GK.08,GK,Count how many times,"**Student task:** Watch the character perform a repeated action (e.g., jump, clap, spin). Count how many times by selecting from picture‑based answer choices that show the actions performed 1, 2, 3, or 4 times (using pictures of action sequences, not numerals, to support non‑readers). _Implementation note: Short animation (2–4 seconds) + picture‑based count choices with visual representations of quantities. CSTA: EK‑ALG‑AF‑01.__",EK‑ALG‑AF‑01,1,1,0,* T01.GK.07: Find the pattern that repeats
T01.G1.01,G1,Put pictures in order to plant a seed,"**Student task:** Look at 4 pictures. Put them in the right order to plant a seed. **Example:** Get pot, add soil, put seed in, water it. _Implementation note: Drag‑drop (4 items). CSTA: E1‑ALG‑AF‑01.___",E1‑ALG‑AF‑01,1,1,0,* T01.GK.02: Put pictures in order for coming to class
T01.G1.02,G1,Put pictures in order to make breakfast,"**Student task:** Look at 5 pictures. Put them in the right order to make breakfast. **Example:** Get bowl, pour cereal, pour milk, eat, wash bowl. _Implementation note: Drag‑drop (5 items). CSTA: E1‑ALG‑AF‑01.___",E1‑ALG‑AF‑01,0,0,0,
T01.G1.03,G1,Add a missing last step to a routine,"Students see a 3‑step routine about a familiar everyday task (e.g., making a sandwich: get bread, add peanut butter, add jelly) and choose the correct 4th step from picture options (eat, clean up, put away ingredients). _Implementation note: MCQ picture choice with 3–4 plausible options; contexts include meal prep, getting ready, classroom routines. CSTA: E1‑ALG‑AF‑01.__",E1‑ALG‑AF‑01,1,1,0,* T01.GK.06: What comes next?
T01.G1.04,G1,Predict the next step in a story sequence,"Students see 3 story panels showing a narrative sequence (e.g., character sees ball, walks toward ball, reaches for ball) and choose what happens next from picture options, focusing on cause‑and‑effect in stories rather than procedural routines. _Implementation note: MCQ visuals with story context (not everyday tasks). CSTA: E1‑ALG‑AF‑01, E1‑ALG‑PS‑03._","E1‑ALG‑AF‑01, E1‑ALG‑PS‑03",1,1,0,* T01.GK.06: What comes next?
T01.G1.05,G1,Find the missing step in an algorithm,"Students see a 4‑step sequence with one blank and choose which picture fills the gap. _Implementation note: Click‑select from options. CSTA: E1‑ALG‑AF‑01, E1‑ALG‑PS‑03._","E1‑ALG‑AF‑01, E1‑ALG‑PS‑03",1,1,0,* T01.G1.03: Add a missing last step to a routine
T01.G1.06,G1,Fix a routine with one wrong step,"Students identify a clearly wrong step (e.g., “eat” before “cook”) and replace it with a correct picture. _Implementation note: Select wrong step, then replacement. CSTA: E1‑ALG‑AF‑01.__",E1‑ALG‑AF‑01,1,1,0,* T01.GK.05: Move the picture that's in the wrong place
T01.G1.07,G1,Decide if two algorithms finish with the same result,"Students compare two routines and decide whether both achieve the same goal. _Implementation note: Side‑by‑side sequences with Yes/No or ""Which work?"" question. CSTA: E1‑ALG‑AF‑01, E1‑ALG‑PS‑03._","E1‑ALG‑AF‑01, E1‑ALG‑PS‑03",1,1,0,* T01.GK.04: Pick the pictures that make sense
T01.G1.08,G1,Choose the algorithm that uses fewer steps,Students pick between two correct routines that differ in length; they choose the shorter correct one. _Implementation note: Choose shorter correct sequence. CSTA: E1‑ALG‑IM‑04._,E1‑ALG‑IM‑04,1,1,0,* T01.G1.07: Decide if two algorithms finish with the same result
T01.G1.09,G1,Match an algorithm to its goal,"Students match 3–4 short picture‑based routines (4–5 steps each) to goal labels, choosing from a list of 5–6 options that include some similar or overlapping goals, requiring careful attention to the specific steps in each routine. _Implementation note: Matching lines between sequences and goals; auto‑graded. CSTA: E1‑ALG‑AF‑01.__",E1‑ALG‑AF‑01,0,0,0,
T01.G1.10,G1,"Match pictures to ""if/then"" rules","**Student task:** Look at pictures. Match them to ""If this, then that"" sentences. **Example:** ""If it rains, then use an umbrella."" _Implementation note: MCQ match picture ↔ sentence. CSTA: E1‑ALG‑AF‑01 (conceptual branching)._",E1‑ALG‑AF‑01 (conceptual branching),1,1,0,* T01.GK.04: Pick the pictures that make sense
T01.G2.01,G2,Find actions that repeat in everyday tasks,"**Student task:** Look at pictures showing an everyday task. Which action happens over and over? **Example:** In cleaning up toys, ""pick up toy"" happens many times. _Implementation note: Highlight or MCQ. CSTA: E2‑ALG‑AF‑01.__",E2‑ALG‑AF‑01,2,1,1,* T01.GK.07: Find the pattern that repeats | * T04.G1.03: Find repeated steps in an instruction list
T01.G2.02,G2,"Use ""repeat"" to make directions shorter","**Student task:** Look at two sets of directions. Pick the one that uses ""repeat ___ times"" to say the same thing in fewer words. **Example:** ""Walk 3 steps, walk 3 steps, walk 3 steps"" vs ""Repeat 'walk 3 steps' 3 times"" _Implementation note: MCQ (long explicit vs ""repeat"" version). CSTA: E2‑ALG‑AF‑01, E2‑ALG‑PS‑03.__","E2‑ALG‑AF‑01, E2‑ALG‑PS‑03",1,1,0,* T01.G2.01: Find actions that repeat in everyday tasks
T01.G2.03,G2,Replace repeated steps with a repeat instruction,"**Student task:** Look at a long list of repeated steps. Rewrite it using ""repeat ___ times"" to make it shorter and clearer. **Example:** ""Clap, clap, clap, clap"" becomes ""Repeat 'clap' 4 times"" _Implementation note: Choose or assemble compressed description with ""repeat."" CSTA: E2‑ALG‑AF‑01, E2‑ALG‑PS‑03.__","E2‑ALG‑AF‑01, E2‑ALG‑PS‑03",1,1,0,"* T01.G2.02: Use ""repeat"" to make directions shorter"
T01.G2.04,G2,Match if/then rules to pictures,"Students match simple “If it is ___, then do ___” rules to images (rainy/sunny, door open/closed). _Implementation note: Visual MCQ. CSTA: E2‑ALG‑AF‑01._",E2‑ALG‑AF‑01,1,1,0,"* T01.G1.10: Match pictures to ""if/then"" rules"
T01.G2.05,G2,Complete a simple if/then algorithm,Students fill in missing condition or action in an if/then pair for a daily scenario. _Implementation note: Fill‑in with picture or word cards. CSTA: E2‑ALG‑AF‑01._,E2‑ALG‑AF‑01,1,1,0,* T01.G2.04: Match if/then rules to pictures
T01.G2.06,G2,Choose the best if/then rule for a situation,Students choose which of several if/then statements fits a picture story. _Implementation note: MCQ; auto‑graded. CSTA: E2‑ALG‑AF‑01._,E2‑ALG‑AF‑01,1,1,0,* T01.G2.05: Complete a simple if/then algorithm
T01.G2.07,G2,Trace an algorithm that uses an if/then choice,"Students follow short number/picture algorithms with if/then and identify the final result. _Implementation note: Tracing + MCQ result. CSTA: E2‑ALG‑AF‑01, E2‑ALG‑PS‑03._","E2‑ALG‑AF‑01, E2‑ALG‑PS‑03",1,1,0,* T01.G2.06: Choose the best if/then rule for a situation
T01.G2.08,G2,"Trace an algorithm that uses ""repeat ___ times""","Students compute total actions or final position for routines with ""repeat 3 times."" _Implementation note: Tracing + MCQ. CSTA: E2‑ALG‑AF‑01, E2‑ALG‑PS‑03._","E2‑ALG‑AF‑01, E2‑ALG‑PS‑03",1,1,0,* T01.G2.03: Replace repeated steps with a repeat instruction
T01.G2.09,G2,Fix a wrong repeat count in an algorithm,"Students adjust a repeat count that causes too many or too few repetitions. _Implementation note: Increase/decrease repeat number; auto‑graded via final outcome. CSTA: E2‑ALG‑AF‑01, E2‑ALG‑PS‑03._","E2‑ALG‑AF‑01, E2‑ALG‑PS‑03",1,1,0,"* T01.G2.08: Trace an algorithm that uses ""repeat ___ times"""
T01.G2.10,G2,Fix a wrong or missing if/then branch,Students correct an if/then rule that doesn't match a picture situation. _Implementation note: MCQ or card swap. CSTA: E2‑ALG‑AF‑01._,E2‑ALG‑AF‑01,1,1,0,* T01.G2.07: Trace an algorithm that uses an if/then choice
T01.G2.11,G2,Trace maze directions on a simple grid,"Students see a character on a small grid and a sequence of ""forward/left/right"" arrows, then choose where the character ends up. _Implementation note: Path tracing with MCQ final position; auto‑graded by ending cell. CSTA: E2‑ALG‑AF‑01, E2‑ALG‑PS‑03._","E2‑ALG‑AF‑01, E2‑ALG‑PS‑03",0,0,0,
T01.G2.12,G2,Choose directions that reach the goal,"Students see a start and goal on a grid and pick which of several arrow sequences reaches the goal without hitting a wall. _Implementation note: MCQ (choose arrow sequence); auto‑graded via simulation. CSTA: E2‑ALG‑AF‑01, E2‑ALG‑PS‑03._","E2‑ALG‑AF‑01, E2‑ALG‑PS‑03",1,1,0,* T01.G2.11: Trace maze directions on a simple grid
T01.G2.13,G2,Write directions to navigate a simple grid,"Students create instructions by dragging and dropping “forward/left/right” arrow cards to move a character from start to finish. _Implementation note: Drag arrow cards; auto‑graded via simulation. CSTA: E2‑ALG‑AF‑01, E2‑ALG‑PS‑03._","E2‑ALG‑AF‑01, E2‑ALG‑PS‑03",1,1,0,* T01.G2.12: Choose directions that reach the goal
T01.G2.14,G2,Fix maze directions that miss the goal,"Students correct a set of directions that doesn't reach the goal or hits a wall. _Implementation note: Edit arrow sequence; auto‑graded via new simulation. CSTA: E2‑ALG‑AF‑01, E2‑ALG‑PS‑03._","E2‑ALG‑AF‑01, E2‑ALG‑PS‑03",1,1,0,* T01.G2.13: Write directions to navigate a simple grid
T01.G2.15,G2,Match picture instructions to visual block commands,"Students match simple picture‑based instruction sequences (e.g., arrow cards showing ""forward, forward, turn right"") to equivalent visual block‑based commands (e.g., blocks showing ""move forward,"" ""move forward,"" ""turn right""), recognizing that pictures and blocks can represent the same algorithm with the same outcome. _Implementation note: Drag‑and‑drop matching with 3–4 sequence pairs; auto‑graded. Focus on 1‑to‑1 correspondence between picture symbols and block icons. CSTA: E2‑ALG‑AF‑01._",E2‑ALG‑AF‑01,1,1,0,* T01.G2.13: Write directions to navigate a simple grid
T01.G3.01,G3,Complete a simple script with missing blocks,"**Student task:** Look at a script that's almost finished. Add 1 or 2 missing blocks to make it work. **Context:** Start with a mostly built project. Script should do 3-5 simple actions. _Implementation note: Guided coding in a starter project (mostly pre‑built); auto‑graded via final behavior. CSTA: E3‑ALG‑AF‑01, E3‑PRO‑PF‑01.__","E3‑ALG‑AF‑01, E3‑PRO‑PF‑01",1,0,1,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence
T01.G3.02,G3,Match a story description to a code sequence,"Students choose which of several scripts matches a natural‑language description. _Implementation note: MCQ, code snippets. CSTA: E3‑ALG‑AF‑01, E3‑ALG‑PS‑03._","E3‑ALG‑AF‑01, E3‑ALG‑PS‑03",1,0,1,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence
T01.G3.03,G3,Identify repeated blocks in a script (no loops),"Students highlight which blocks repeat in a short script from a familiar, simple project (e.g., sprite drawing a square, character performing a dance, robot moving in a pattern). The project should have a clear, visual goal that students can understand before examining the code. _Implementation note: Highlight or click region in code; project examples include geometric drawing, simple animation, basic movement patterns. CSTA: E3‑ALG‑AF‑01._",E3‑ALG‑AF‑01,2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T04.G2.01: Identify the repeating unit in a longer pattern
T01.G3.04,G3,Predict how many times repeated blocks run,"Students count how many times an action happens based on repeated blocks (e.g., 4× `move 10`) in a concrete behavior (like a character walking), connecting T04's abstract repeat units to meaningful movement or actions. _Implementation note: MCQ; auto‑graded. CSTA: E3‑ALG‑AF‑01._",E3‑ALG‑AF‑01,2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T04.G2.01: Identify the repeating unit in a longer pattern
T01.G3.05,G3,Replace repeated blocks with a repeat loop,"Students refactor repeated blocks into a `repeat` loop with the correct count in a small project script, using loop patterns first explored in T04.G3.01–G3.02 to improve a real algorithm. _Implementation note: Coding refactor; auto‑graded by structure + behavior. CSTA: E3‑ALG‑AF‑01, E3‑PRO‑PF‑01._","E3‑ALG‑AF‑01, E3‑PRO‑PF‑01",1,0,1,* T04.G3.01: Identify where a loop could replace repeated blocks
T01.G3.06,G3,Trace a repeat loop to find total movement,Students trace a script with a `repeat` loop to determine how far a sprite moves or how many actions occur. _Implementation note: Tracing + MCQ. CSTA: E3‑ALG‑AF‑01._,E3‑ALG‑AF‑01,2,0,2,"* T04.G3.02: Match a ""repeat N"" loop to repeated behavior | * T07.G3.01: Use a counted repeat loop"
T01.G3.07,G3,Adjust a repeat count to match a pattern,"Students change the repeat number so a pattern (e.g., a square, a full spin) completes exactly. _Implementation note: Edit loop count; auto‑graded via final orientation/pattern. CSTA: E3‑ALG‑AF‑01, E3‑PRO‑PF‑01._","E3‑ALG‑AF‑01, E3‑PRO‑PF‑01",2,0,2,"* T04.G3.02: Match a ""repeat N"" loop to repeated behavior | * T07.G3.01: Use a counted repeat loop"
T01.G3.08,G3,Add a simple if/then to a script,"Students insert an `if touching [color/sprite]` block to trigger an action. _Implementation note: Coding, scaffolded; auto‑graded by behavior. CSTA: E3‑ALG‑AF‑01, E3‑PRO‑PF‑01._","E3‑ALG‑AF‑01, E3‑PRO‑PF‑01",1,0,1,* T08.G3.01: Use a simple if in a script
T01.G3.09,G3,Match an if/then script to a behavior description,"Students pick which script with if/then matches a described behavior (""When you touch the goal, say 'Yay!'.""). _Implementation note: MCQ; auto‑graded. CSTA: E3‑ALG‑AF‑01._",E3‑ALG‑AF‑01,1,0,1,* T08.G3.01: Use a simple if in a script
T01.G3.10,G3,Trace a script with a single if/then,"Students predict whether the if/then block will run in a given situation. _Implementation note: Tracing scenario + MCQ. CSTA: E3‑ALG‑AF‑01, E3‑ALG‑PS‑03._","E3‑ALG‑AF‑01, E3‑ALG‑PS‑03",1,0,1,* T08.G3.01: Use a simple if in a script
T01.G3.11,G3,Explain in words what a short program does,"Students select or write a one‑sentence description of a short script's algorithm. _Implementation note: Code‑reading MCQ/short answer. CSTA: E3‑ALG‑AF‑01, E3‑ALG‑PS‑03._","E3‑ALG‑AF‑01, E3‑ALG‑PS‑03",1,0,1,* T07.G3.02: Trace a script with a simple loop
T01.G3.12,G3,Predict the final state of a simple algorithm,Students trace a script (possibly with a loop) to predict final position or direction. _Implementation note: Grid/orientation MCQ. CSTA: E3‑ALG‑AF‑01._,E3‑ALG‑AF‑01,1,0,1,* T14.G3.01: Move a sprite with arrow keys (4 directions)
T01.G3.13,G3,Debug a program with steps in the wrong order,"Students rearrange blocks in a sequence script to match a given intended behavior. _Implementation note: Coding re‑order; auto‑graded via behavior. CSTA: E3‑ALG‑AF‑01, E3‑PRO‑TR‑03._","E3‑ALG‑AF‑01, E3‑PRO‑TR‑03",1,0,1,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence
T01.G3.14,G3,Debug a loop that repeats the wrong number of times,"Students fix a `repeat` loop that runs too many or too few times by adjusting the loop count so the behavior matches the description. _Implementation note: Coding edit (loop count); auto‑graded via final behavior. CSTA: E3‑ALG‑AF‑01, E3‑PRO‑TR‑03._","E3‑ALG‑AF‑01, E3‑PRO‑TR‑03",1,0,1,* T07.G3.01: Use a counted repeat loop
T01.G3.15,G3,Debug an if/then that doesn't trigger when it should,"Students fix a simple if/then condition so an action (like saying ""Yay!"" at the goal) happens at the right time. _Implementation note: Coding edits; auto‑graded with multiple tests. CSTA: E3‑ALG‑AF‑01, E3‑PRO‑TR‑03._","E3‑ALG‑AF‑01, E3‑PRO‑TR‑03",1,0,1,* T08.G3.01: Use a simple if in a script
T01.G4.01,G4,Plan steps for a coded maze or goal‑reach task,"Students write numbered steps in words for ""reach the flag without touching red walls."" _Implementation note: Arrange/choose steps. CSTA: E4‑ALG‑AF‑01._",E4‑ALG‑AF‑01,0,0,0,
T01.G4.02,G4,Implement a written plan in code,"Students turn a given plan into a CreatiCode script and test it. _Implementation note: Coding; auto‑grading checks match between plan and behavior. CSTA: E4‑ALG‑AF‑01, E4‑PRO‑PF‑01._","E4‑ALG‑AF‑01, E4‑PRO‑PF‑01",2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script
T01.G4.03,G4,Identify repeated patterns in longer scripts,Students highlight repeated sequences (not just single blocks) in longer scripts. _Implementation note: Highlight blocks; auto‑grading checks region. CSTA: E4‑ALG‑AF‑01._,E4‑ALG‑AF‑01,3,0,3,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script
T01.G4.04,G4,Replace repeated patterns with loops,"Students refactor repeated patterns into loops that contain multiple blocks. _Implementation note: Coding refactor; auto‑graded by behavior & fewer blocks. CSTA: E4‑ALG‑AF‑01, E4‑ALG‑PS‑03._","E4‑ALG‑AF‑01, E4‑ALG‑PS‑03",1,0,1,* T07.G3.01: Use a counted repeat loop
T01.G4.05,G4,Compare two versions of a script: with and without loops,"Students compare a long ""no loops"" script and a shorter ""with loops"" version and choose which is better and why. _Implementation note: Side‑by‑side code comparison with MCQ explanation. CSTA: E4‑ALG‑IM‑04._",E4‑ALG‑IM‑04,3,0,3,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script
T01.G4.06,G4,Recognize variables in a program,Students identify which names in a script are variables and what they store. _Implementation note: Code‑reading MCQ/highlight. CSTA: E4‑PRO‑DH‑02._,E4‑PRO‑DH‑02,3,0,3,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G4.07,G4,Trace a simple counter variable,"Students follow a script that initializes a variable and increments it in a loop, then predict its final value. _Implementation note: Tracing + MCQ. CSTA: E4‑ALG‑AF‑01, E4‑PRO‑DH‑02._","E4‑ALG‑AF‑01, E4‑PRO‑DH‑02",3,0,3,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G4.08,G4,Add a variable to count events in a program,"Students add a variable (e.g., `steps`, `coins`) and increment it at the right place in an existing script. _Implementation note: Coding; auto‑grading checks updates and display. CSTA: E4‑ALG‑AF‑01, E4‑PRO‑DH‑02._","E4‑ALG‑AF‑01, E4‑PRO‑DH‑02",3,0,3,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G4.09,G4,Use a variable to track a simple game state (lives or points),"Students extend a game to use a variable for lives or points, decreasing or increasing it based on events. _Implementation note: Coding; auto‑graded on correct updates. CSTA: E4‑ALG‑AF‑01, E4‑PRO‑DH‑02._","E4‑ALG‑AF‑01, E4‑PRO‑DH‑02",2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G4.10,G4,Trace a multi‑step algorithm with loops and variables,"Students trace code with a loop and variable updates to find final values or positions. _Implementation note: Code‑reading + MCQ. CSTA: E4‑ALG‑AF‑01, E4‑ALG‑PS‑03._","E4‑ALG‑AF‑01, E4‑ALG‑PS‑03",2,0,2,* T07.G3.01: Use a counted repeat loop | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G4.11,G4,Debug an off‑by‑one counting bug,"Students fix a counter that ends too high or too low by adjusting initialization or loop bounds. _Implementation note: Coding edits; auto‑graded with multiple tests. CSTA: E4‑ALG‑AF‑01, E4‑PRO‑TR‑03._","E4‑ALG‑AF‑01, E4‑PRO‑TR‑03",2,0,2,* T07.G3.01: Use a counted repeat loop | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G4.12,G4,Explain why one algorithm solution is better than another,"Students compare two working algorithms that achieve the same goal and explain which is better based on provided criteria: (a) fewer steps/shorter, (b) easier to understand/clearer, or (c) uses better structures like loops. _Implementation note: MCQ for selecting best algorithm + choosing explanation from provided reasons addressing clarity, efficiency, or structure. CSTA: E4‑ALG‑IM‑04._",E4‑ALG‑IM‑04,0,0,0,
T01.G5.01,G5,Match a word description to a flowchart,"Students match everyday‑language descriptions of algorithms to flowcharts, applying the flowchart symbols and reading skills introduced in T02 (Grades 3–4) to real‑world tasks. _Implementation note: MCQ matching, using familiar contexts (games, classroom routines). CSTA: E5‑ALG‑AF‑01._",E5‑ALG‑AF‑01,1,0,1,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence
T01.G5.02.01,G5,Convert a simple flowchart into code,"Students implement a simple flowchart (5–7 steps with 1–2 decision diamonds and 0–1 loop structures) as block‑based code for a small CreatiCode project. Focus on mapping flowchart symbols (rectangles → action blocks, diamonds → if/then, loop connectors → repeat) to code constructs. _Implementation note: Coding task; auto‑graded on behavior matching flowchart logic and basic structural correspondence between shapes and blocks. Project examples: simple game turn, animated sequence with choices. CSTA: E5‑ALG‑AF‑01, E5‑PRO‑PF‑01._","E5‑ALG‑AF‑01, E5‑PRO‑PF‑01",3,0,3,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script
T01.G5.02.02,G5,Convert simple pseudocode into code,"Students implement simple pseudocode (structured text with REPEAT, IF/THEN, SET variable) as block‑based code for a small CreatiCode project. Pseudocode uses conventions introduced in T02 (structured English with keywords in caps). Focus on translating text descriptions of actions into equivalent block commands. _Implementation note: Coding task; auto‑graded on behavior and correspondence to pseudocode intent. Project examples: score tracker, animated routine with conditions. CSTA: E5‑ALG‑AF‑01, E5‑PRO‑PF‑01._","E5‑ALG‑AF‑01, E5‑PRO‑PF‑01",4,0,4,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G5.03,G5,Convert a short program into pseudocode,"Students rewrite a short program as structured pseudocode showing loops, if/then, and variables, using the pseudocode conventions introduced in T02 and focusing on clarity for a human reader who is thinking about the real task. _Implementation note: Guided pseudocode; rubric/auto‑grading focused on structure and faithfulness to behavior. CSTA: E5‑ALG‑AF‑01, E5‑ALG‑PS‑03._","E5‑ALG‑AF‑01, E5‑ALG‑PS‑03",4,0,4,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G5.04,G5,Trace a search algorithm using loops and variables,"Students trace a simple ""find the largest"" or ""count matches"" algorithm and track how a variable changes. _Implementation note: Tracing table; auto‑graded. CSTA: E5‑ALG‑PS‑03, E5‑PRO‑DH‑02._","E5‑ALG‑PS‑03, E5‑PRO‑DH‑02",3,0,3,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G5.05,G5,Determine whether an algorithm is correct for all inputs,"Students apply test cases to decide if an algorithm always gives the right answer. _Implementation note: Choose ""always works"" vs ""fails sometimes"" with evidence. CSTA: E5‑ALG‑PS‑03._",E5‑ALG‑PS‑03,2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script
T01.G5.06,G5,Compare two algorithms for step counts (efficiency),"Students estimate or count loop iterations and compare efficiency. _Implementation note: Tables + MCQ; auto‑graded. CSTA: E5‑ALG‑PS‑03, E5‑ALG‑IM‑04._","E5‑ALG‑PS‑03, E5‑ALG‑IM‑04",3,0,3,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G5.07,G5,Debug an algorithm that mis‑handles a simple edge case,"Students fix a bug where an algorithm fails on empty input or a special case. _Implementation note: Coding edits; auto‑graded tests. CSTA: E5‑ALG‑PS‑03, E5‑PRO‑TR‑03._","E5‑ALG‑PS‑03, E5‑PRO‑TR‑03",2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script
T01.G5.08,G5,Add checks to handle edge cases,Students extend an algorithm to include extra if/then checks for invalid or special inputs. _Implementation note: Coding; test both regular and edge cases. CSTA: E5‑ALG‑PS‑03._,E5‑ALG‑PS‑03,2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script
T01.G5.09,G5,Explain why an algorithm is correct using loops and variables,"Students explain why a loop + variable algorithm (e.g., max, count) is guaranteed to work. _Implementation note: Structured explanation; auto‑graded patterns. CSTA: E5‑ALG‑PS‑03._",E5‑ALG‑PS‑03,3,0,3,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G5.10,G5,Rewrite a long algorithm using loops or helper steps,"Students reduce a long algorithm to a shorter one using loops or helper steps without changing behavior. _Implementation note: Pseudocode/code refactor; rubric/auto‑graded. CSTA: E5‑ALG‑AF‑01, E5‑ALG‑PS‑03._","E5‑ALG‑AF‑01, E5‑ALG‑PS‑03",2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop
T01.G6.01,G6,Compare efficiency of linear and binary search,"Students qualitatively compare linear and binary search on small lists, identifying that binary search typically uses fewer comparisons by eliminating half the remaining options with each step. (Focus on *why* binary is faster, not exact counts.) _Implementation note: Table; auto‑graded. CSTA: MS‑ALG‑AF‑02._",MS‑ALG‑AF‑02,1,0,1,* T04.G2.01: Identify the repeating unit in a longer pattern
T01.G6.02,G6,Compare how step counts grow with input size,"Students interpret tables/graphs to see which algorithm scales better. _Implementation note: MCQ + explanation. CSTA: MS‑ALG‑AF‑02, MS‑ALG‑PS‑05._","MS‑ALG‑AF‑02, MS‑ALG‑PS‑05",0,0,0,
T01.G6.03,G6,Spot unnecessary work in an algorithm,Students highlight lines where an algorithm keeps working after the result is found. _Implementation note: Code highlight; auto‑graded. CSTA: MS‑ALG‑AF‑01._,MS‑ALG‑AF‑01,2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G6.04,G6,Revise an algorithm to do less work,"Students remove redundant checks/loops without changing output. _Implementation note: Pseudocode/coding edit; auto‑graded on correctness + fewer steps. CSTA: MS‑ALG‑AF‑01, MS‑ALG‑PS‑05._","MS‑ALG‑AF‑01, MS‑ALG‑PS‑05",2,0,2,* T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script
T01.G6.05,G6,Identify who is favored or harmed by a decision algorithm,"Students analyze a simple decision algorithm for fairness across groups. _Implementation note: Scenario MCQ + short explanation. CSTA: MS‑ALG‑IM‑08. AI4K12: Ethical design (D), Societal impacts (E)._",MS‑ALG‑IM‑08,0,0,0,
T01.G6.06,G6,Suggest a change to make a decision algorithm more fair,"Students propose specific changes to reduce bias or harm. _Implementation note: Structured response; auto‑graded by alignment with identified issue. CSTA: MS‑ALG‑IM‑09. AI4K12: Ethical design (D), Societal impacts (E)._",MS‑ALG‑IM‑09,0,0,0,
T01.G6.07,G6,Design a flowchart for a multi‑step program,"Students design a flowchart for a game turn (ask, check, update score, continue/stop), building on the flowchart symbols, loops, and decisions practiced in T02 up through Grade 6. _Implementation note: Flowchart design tied to a concrete game scenario; rubric. CSTA: MS‑ALG‑AF‑01._",MS‑ALG‑AF‑01,3,0,3,* T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G6.08,G6,Implement code from a detailed flowchart,"Students map each shape in a detailed, multi‑step flowchart to code constructs in a CreatiCode project, focusing on correctness and readability rather than learning new notation. _Implementation note: Coding; auto‑graded structure + tests, assumes prior diagram‑to‑code practice from T02.G6.05. CSTA: MS‑ALG‑AF‑01, MS‑PRO‑PF‑01._","MS‑ALG‑AF‑01, MS‑PRO‑PF‑01",2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G7.01,G7,Identify the pattern in a given program,"Students categorize code as search, sort, accumulation, or simulation. _Implementation note: MCQ; auto‑graded. CSTA: MS‑ALG‑AF‑01._",MS‑ALG‑AF‑01,2,0,2,* T06.G7.01: Create a simple state machine with broadcasts | * T09.G7.04: Understand local vs global variable scope
T01.G7.02,G7,Choose a pattern to solve a problem,"Students pick which algorithm pattern is best for a described task. _Implementation note: MCQ; auto‑graded. CSTA: MS‑ALG‑AF‑01, MS‑ALG‑PS‑06._","MS‑ALG‑AF‑01, MS‑ALG‑PS‑06",0,0,0,
T01.G7.03,G7,Write pseudocode for a search or accumulation algorithm,"Students write structured pseudocode for ""find max"" or ""count items that match."" _Implementation note: Guided pseudocode; auto‑graded structure. CSTA: MS‑ALG‑AF‑01, MS‑PRO‑PF‑02._","MS‑ALG‑AF‑01, MS‑PRO‑PF‑02",2,0,2,* T04.G2.01: Identify the repeating unit in a longer pattern | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G7.04,G7,Compare efficiency of two algorithms qualitatively,"Students reason which algorithm scales better as inputs grow. _Implementation note: Scenario + MCQ + explanation. CSTA: MS‑ALG‑AF‑02, MS‑ALG‑PS‑05._","MS‑ALG‑AF‑02, MS‑ALG‑PS‑05",0,0,0,
T01.G7.05,G7,Design a set of edge‑case tests for an algorithm,"Students pick tests (including edge cases) that give high confidence the algorithm works. _Implementation note: Choose tests from list; auto‑graded for coverage. CSTA: MS‑ALG‑PS‑05, MS‑PRO‑TR‑11.","MS‑ALG‑PS‑05, MS‑PRO‑TR‑11",0,0,0,
T01.G7.06,G7,Run an algorithm on edge cases and find failures,Students test algorithms on tricky inputs and flag those that fail. _Implementation note: MCQ/interactive; auto‑graded. CSTA: MS‑ALG‑PS‑05._,MS‑ALG‑PS‑05,0,0,0,
T01.G7.07,G7,Explain why an algorithm fails on a specific edge case,"Students explain which step causes the failure and why. _Implementation note: Structured explanation; auto‑graded patterns. CSTA: MS‑ALG‑PS‑05, MS‑PRO‑TR‑11.","MS‑ALG‑PS‑05, MS‑PRO‑TR‑11",0,0,0,
T01.G7.08,G7,Rewrite a naive algorithm using a better pattern,"Students replace repeated naive logic with a cleaner pattern (single loop, flag, etc.). _Implementation note: Pseudocode/coding refactor; rubric. CSTA: MS‑ALG‑AF‑01, MS‑ALG‑PS‑06._","MS‑ALG‑AF‑01, MS‑ALG‑PS‑06",2,0,2,* T04.G2.01: Identify the repeating unit in a longer pattern | * T07.G3.01: Use a counted repeat loop
T01.G8.01,G8,Design one‑step update rules for a simple simulation,"Students specify how state variables change in one timestep of a simulation. _Implementation note: Code/pseudocode blanks; auto‑graded. CSTA: MS‑ALG‑AF‑01, DAA‑DI. AI4K12: Modeling (B)._","MS‑ALG‑AF‑01, DAA‑DI",3,0,3,* T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G8.02,G8,Interpret the behavior of a simulation algorithm over time,"Students explain what happens to variables after several steps. _Implementation note: Code + graph reading; MCQ/short answer. CSTA: MS‑ALG‑AF‑02, DAA‑DI. AI4K12: Modeling (B)._","MS‑ALG‑AF‑02, DAA‑DI",1,0,1,* T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G8.03,G8,Compare two simulations with slightly different rules,"Students explain how changed rules affect outcomes. _Implementation note: Side‑by‑side comparison + explanation. CSTA: MS‑ALG‑AF‑02, DAA‑DI. AI4K12: Modeling (B)._","MS‑ALG‑AF‑02, DAA‑DI",0,0,0,
T01.G8.04,G8,Identify base case and recursive step in an algorithm description,"Students highlight base case and recursive step in a **natural‑language** description of a recursive process (e.g., ""to count the blocks in a stack, count the top block, then count the rest""), keeping recursion **concept‑only** (no code blocks). _Implementation note: MCQ/highlight; auto‑graded. CSTA: MS‑ALG‑PS‑07._",MS‑ALG‑PS‑07,2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G8.05,G8,Trace a conceptual recursive algorithm on small inputs,"Students step through a **diagram or story version** of recursion (e.g., factorial, sum of list) for small inputs, marking each call/return to show how the answer is built, without writing or reading recursive code. _Implementation note: Tracing table; auto‑graded. CSTA: MS‑ALG‑PS‑07._",MS‑ALG‑PS‑07,2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G8.06,G8,Analyze who is helped or harmed by a real‑world algorithm,"Students identify stakeholders and impacts of a real‑world algorithm. _Implementation note: Scenario with MCQ + short answers. CSTA: MS‑ALG‑IM‑08. AI4K12: Ethical design (D), Societal impacts (E)._",MS‑ALG‑IM‑08,0,0,0,
T01.G8.07,G8,Propose changes to make a real‑world algorithm more fair,"Students propose specific mitigations based on identified harms. _Implementation note: Structured responses; auto‑graded alignment. CSTA: MS‑ALG‑IM‑09. AI4K12: Ethical design (D), Societal impacts (E)._",MS‑ALG‑IM‑09,0,0,0,
T01.G8.08,G8,Refactor a medium‑sized program for clarity,"Students reorganize code into helper blocks, remove duplication, and add meaningful names. _Implementation note: Coding refactor; auto‑graded via behavior + structure. CSTA: MS‑PRO‑TR‑11.",MS‑PRO‑TR‑11,2,0,2,* T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor
T01.G8.09,G8,Refactor a medium‑sized program for efficiency,"Students make local changes (e.g., break loops early, avoid unnecessary recomputation) to reduce work. _Implementation note: Coding edits; auto‑graded for unchanged outputs and fewer steps. CSTA: MS‑ALG‑PS‑05, MS‑PRO‑TR‑11.","MS‑ALG‑PS‑05, MS‑PRO‑TR‑11",1,0,1,* T07.G3.01: Use a counted repeat loop
T01.G8.10,G8,Facilitate capstone retrospectives with stakeholders,"Learners run retrospectives for their final projects, gather peer/teacher feedback, and publish action items for future teams.",,3801,102,3699,"* T01.G7.08: Rewrite a naive algorithm using a better pattern | * T01.GK.01: Put pictures in order for getting ready for bed | * T02.GK.01: Recognize picture steps for a task | * T01.GK.01: Put pictures in order for getting ready for bed | * T02.GK.02: Order 3–4 pictures to make a story | * T02.GK.02: Order 3–4 pictures to make a story | * T02.GK.03: Use first/next/last to describe a sequence | * T02.GK.02: Order 3–4 pictures to make a story | * T02.G1.01: Make a 3–4 step picture algorithm | * T02.G1.01: Make a 3–4 step picture algorithm | * T02.G1.01: Make a 3–4 step picture algorithm | * T02.G1.04: Find a broken picture algorithm | * T02.G1.01: Make a 3–4 step picture algorithm | * T02.G2.01: Turn a picture routine into labeled boxes | * T02.G2.02: Read a box diagram and choose the matching pictures | * T02.G2.03: Trace a simple linear instruction sequence | * T02.G2.02: Read a box diagram and choose the matching pictures | * T02.G2.05: Match a box diagram to a step sequence | * T02.G2.02: Read a box diagram and choose the matching pictures | * T02.G3.01: Identify start, action, and end symbols in flowcharts | * T02.G3.02: Turn a 3‑step routine into a basic flowchart | * T02.G3.03: Identify decision diamond symbols in flowcharts | * T02.G3.04: Trace a decision flowchart and tell the outcome | * T02.G3.02: Turn a 3‑step routine into a basic flowchart | * T02.G3.06: Match a simple flowchart to a script | * T02.G3.02: Turn a 3‑step routine into a basic flowchart | * T02.G4.01: Add a loop to an existing flowchart | * T02.G4.02: Design a flowchart for a task with repetition | * T02.G3.04: Trace a decision flowchart and tell the outcome | * T02.G4.02: Design a flowchart for a task with repetition | * T02.G3.02: Turn a 3‑step routine into a basic flowchart | * T02.G4.06: Convert a story description into simple pseudocode | * T02.G4.05: Trace a flowchart that includes a loop structure | * T02.G4.04: Trace a flowchart with multiple decision points | * T02.G5.01: Read a multi‑branch flowchart and trace a path | * T02.G4.03: Identify and use input/output symbols in flowcharts | * T02.G4.08: Fill in a simple trace table for a short flowchart | * T02.G5.03: Trace a flowchart with state tracking using a trace table | * T02.G4.05: Convert a story description into simple pseudocode | * T02.G5.05: Write pseudocode for a loop‑based algorithm | * T02.G5.02: Design a multi‑branch flowchart for a decision task | * T02.G5.04: Create a trace table for a flowchart with accumulation | * T02.G5.06: Compare two algorithms for the same task | * T02.G5.05: Write pseudocode for a loop‑based algorithm | * T02.G6.04: Convert a flowchart to pseudocode | * T02.G6.02: Trace nested flowchart structures with multiple variables | * T02.G6.02: Trace nested flowchart structures with multiple variables | * T02.G7.01: Trace a step‑by‑step simulation algorithm | * T02.G6.06: Design a flowchart for a multi‑step data processing task | * T02.G7.03: Create a flowchart for linear search or ""find max"" | * T02.G7.03.01: Convert a search algorithm flowchart to pseudocode | * T02.G6.03: Analyze different flowchart representations of the same algorithm | * T02.G7.04: Read a flowchart for a simple sort and trace one pass | * T02.G6.04: Convert a flowchart to pseudocode | * T02.G8.01: Write pseudocode for a non‑trivial algorithm | * T02.G8.02: Trace your pseudocode with multiple test cases | * T02.G6.01: Design a flowchart for a simple guessing game | * T02.G7.01: Trace a step-by-step simulation algorithm | * T03.GK.01: Identify parts that make up a whole | * T01.GK.01: Put pictures in order for getting ready for bed | * T03.GK.03: Order 3–4 pictures to show steps in a routine | * T03.GK.03: Order 3–4 pictures to show steps in a routine | * T03.GK.01: Identify parts that make up a whole | * T03.G1.01: Describe what one part of a system does | * T03.GK.03: Order 3–4 pictures to show steps in a routine | * T03.G1.03: List steps for a simple classroom routine | * T03.G1.03: List steps for a simple classroom routine | * T03.G2.01: Choose subtasks for a simple project idea | * T03.G2.02: Group subtasks by type | * T03.G2.03: Arrange subtasks into a reasonable order | * T03.G2.02: Group subtasks by type | * T03.G2.05: Identify what a simple game or story can do | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T03.G3.01: Identify features in a small game description | * T07.G3.01: Use a counted repeat loop | * T03.G3.02: Group features into ""must‑have"" vs ""nice‑to‑have"" | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T03.G3.03: Create a 3‑panel storyboard for a project | * T03.G3.04: Match storyboard panels to project scenes | * T03.G3.05: Choose a step‑by‑step plan for a small project | * T09.G3.02: Use a variable in a conditional (if block) | * T03.G3.02: Group features into ""must‑have"" vs ""nice‑to‑have"" | * T03.G3.06: Link each subtask to a logical component or responsibility | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T03.G4.01: Break a medium‑size project into components | * T03.G3.07: Identify different jobs needed to make a project | * T03.G4.03: Assign project tasks to team roles | * T03.G3.05: Choose a step‑by‑step plan for a small project | * T03.G4.04: Create a simple task list with owners and order | * T03.G3.05: Choose a step‑by‑step plan for a small project | * T03.G4.01: Break a medium‑size project into components | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T03.G4.01: Break a medium‑size project into components | * T02.G4.01: Add a loop to an existing flowchart | * T03.G4.01: Break a medium‑size project into components | * T03.G4.05: Spot a missing or unnecessary task in a plan | * T03.G4.01: Break a medium‑size project into components | * T03.G4.06: Update a plan after testing feedback | * T03.G4.05: Spot a missing or unnecessary task in a plan | * T03.G4.01: Break a medium‑size project into components | * T03.G5.01: Create a feature list and subtask breakdown | * T03.G5.01: Create a feature list and subtask breakdown | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T03.G5.01: Create a feature list and subtask breakdown | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T03.G5.01: Create a feature list and subtask breakdown | * T03.G6.03: Break a project into milestones (v1/v2/v3) | * T03.G4.06: Update a plan after testing feedback | * T03.G5.01: Create a feature list and subtask breakdown | * T03.G6.01: Propose modules for a medium project | * T02.G3.01: Identify start, action, and end symbols in flowcharts | * T04.G5.01: Identify the repeating unit in a longer pattern | * T03.G7.01: Draw an architecture diagram for a multi‑component project | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T03.G6.01: Propose modules for a medium project | * T03.G5.05: Compare two project plans for the same idea | * T03.G7.03: Compare two decompositions of the same project | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T03.G6.01: Propose modules for a medium project | * T03.G5.02: Draw a high‑level project map | * T03.G7.05: Design a test plan based on a project breakdown | * T03.G5.03: Identify task dependencies in a project plan | * T03.G7.01: Draw an architecture diagram for a multi‑component project | * T03.G8.01: Outline a formal project specification | * T03.G7.03: Compare two decompositions of the same project | * T03.G8.03: Rank project ideas by complexity and timeline | * T03.G6.03: Break a project into milestones (v1/v2/v3) | * T03.G7.04: Propose an alternative decomposition to fix a planning problem | * T06.G6.01: Trace event execution paths in a multi‑event program | * T03.G8.05: Propose a refactoring plan for a complex project | * T03.G6.04: Adjust milestones after discovering a constraint | * T04.GK.01: Identify a simple repeating pattern | * T04.GK.02: Extend a repeating pattern by one tile | * T04.GK.02: Extend a repeating pattern by one tile | * T04.GK.02: Extend a repeating pattern by one tile | * T04.G1.01: Match a picture pattern to a movement pattern | * T01.GK.07: Find the pattern that repeats | * T04.G1.03: Find repeated steps in an instruction list | * T04.G1.02: Plan a short repeating animation pattern | * T04.G1.03: Find repeated steps in an instruction list | * T04.G2.01: Identify the repeating unit in a longer pattern | * T01.G2.02: Use ""repeat"" to make directions shorter | * T04.G2.03: Compare a long explicit description vs a compressed ""repeat"" description | * T04.G2.04: Replace repeated steps with a ""repeat ___ times"" phrase | * T04.G2.05: Match a ""repeat box"" diagram to repeated steps | * T07.G3.01: Use a counted repeat loop | * T04.G2.03: Compare a long explicit description vs a compressed ""repeat"" description | * T07.G3.02: Trace a script with a simple loop | * T03.G3.02: Group features into “must‑have” vs “nice‑to‑have” | * T04.G3.03: Recognize a simple project template | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T04.G3.04: Customize a template by changing repeated elements | * T08.G3.01: Use a simple if in a script | * T04.G3.05: Fix a loop that repeats too many or too few times | * T07.G3.03: Build a forever loop for simple animation | * T04.G2.01: Identify the repeating unit in a longer pattern | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T04.G2.05: Match a ""repeat box"" diagram to repeated steps | * T07.G3.01: Use a counted repeat loop | * T04.G3.01: Identify where a loop could replace repeated blocks | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T04.G3.03: Recognize a simple project template | * T07.G3.01: Use a counted repeat loop | * T04.G3.04: Customize a template by changing repeated elements | * T08.G3.01: Use a simple if in a script | * T04.G3.07: Match algorithm descriptions to code pattern shapes | * T04.G3.07: Match algorithm descriptions to code pattern shapes | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T04.G3.07: Match algorithm descriptions to code pattern shapes | * T04.G4.05: Identify when a known pattern can solve a new problem | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T04.G3.04: Customize a template by changing repeated elements | * T04.G4.05: Identify when a known pattern can solve a new problem | * T04.G4.07: Recognize a simple counter pattern in code | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T04.G4.05: Identify when a known pattern can solve a new problem | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T04.G4.05: Identify when a known pattern can solve a new problem | * T08.G3.01: Use a simple if in a script | * T04.G4.05: Identify when a known pattern can solve a new problem | * T08.G3.01: Use a simple if in a script | * T04.G4.05: Identify when a known pattern can solve a new problem | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T04.G3.03: Recognize a simple project template | * T04.G4.03: Recognize ""if"" patterns that handle special cases | * T04.G5.01: Recognize a counter update pattern | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T04.G4.04: Match multiple code snippets that share the same pattern | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T04.G4.04: Match multiple code snippets that share the same pattern | * T04.G5.01: Recognize a counter update pattern | * T01.G3.01: Complete a simple script with missing blocks | * T07.G3.01: Use a counted repeat loop | * T04.G6.03: Turn repeated code into a custom block | * T08.G3.01: Use a simple if in a script | * T04.G5.06: Identify changeable vs fixed parts in a template | * T04.G5.05: Compare solutions that use a pattern vs those that don't | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T04.G5.07: Apply a counter pattern to solve a counting problem | * T04.G6.01: Group snippets by underlying algorithm pattern | * T04.G6.01: Group snippets by underlying algorithm pattern | * T07.G5.01: Use a counted repeat loop | * T08.G5.01: Use a simple if in a script | * T04.G6.01: Group snippets by underlying algorithm pattern | * T08.G5.01: Use a simple if in a script | * T04.G5.01: Recognize a counter update pattern | * T04.G5.02: Recognize an accumulator (sum/concatenate) pattern | * T04.G6.01: Group snippets by underlying algorithm pattern | * T04.G7.03.01: Identify problems that require multiple patterns | * T04.G7.03.02: Outline a solution combining two patterns | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T04.G7.03.01: Identify problems that require multiple patterns | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T04.G7.04.01: Trace a composite pattern and identify each pattern used | * T04.G6.02: Identify pattern variants that look different but behave the same | * T07.G5.01: Use a counted repeat loop | * T04.G6.06: Compare two pattern‑based solutions for efficiency and clarity | * T04.G6.01: Group snippets by underlying algorithm pattern | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T04.G8.01: Recognize common code idioms in a library | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T04.G7.01: Identify the main loop patterns in a simulation or game | * T06.G6.01: Trace event execution paths in a multi‑event program | * T07.G6.01: Trace nested loops with variable bounds | * T04.G7.06: Compare pattern‑based implementations for maintainability | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T04.G6.01: Group snippets by underlying algorithm pattern | * T04.G8.05: Complete a ""pattern card"" describing a reusable solution | * T05.GK.01: Name who a tool helps | * T05.GK.02: Match a simple problem to a helpful tool | * T05.GK.02: Match a simple problem to a helpful tool | * T05.GK.03: Decide which version is easier to use | * T05.GK.02: Match a simple problem to a helpful tool | * T01.GK.03: Find the first and last pictures | * T05.G1.01: Identify what a character needs in a story | * T05.GK.03: Decide which version is easier to use | * T05.G1.02: Match a need to a design idea | * T05.G1.03: Choose a better version of a simple screen for a given user | * T05.G1.04: Suggest one change that helps a specific user | * T05.G1.01: Identify what a character needs in a story | * T05.G2.03: Recognize when a situation could be simulated | * T05.G2.01: Match different users to different preferred designs | * T08.G3.01: Use a simple if in a script | * T05.G2.01: Match different users to different preferred designs | * T05.G1.01: Identify what a character needs in a story | * T05.G2.02: Identify features that make a design more accessible | * T05.G1.04: Suggest one change that helps a specific user | * T08.G3.02: Decide when a single if is enough | * T07.G3.01: Use a counted repeat loop | * T05.G2.04: Choose what to include in a very simple simulation | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T05.G2.04: Choose what to include in a very simple simulation | * T08.G3.03: Pick the right conditional block for a scenario | * T05.G2.02: Identify features that make a design more accessible | * T05.G2.01: Match different users to different preferred designs | * T05.G3.01: Put human‑centered design steps in order | * T05.G2.01: Match different users to different preferred designs | * T05.G3.02: Identify user needs from a short interview transcript | * T05.G2.01: Match different users to different preferred designs | * T05.G3.03: Choose design changes based on simple feedback | * T05.G2.02: Identify features that make a design more accessible | * T05.G3.03: Choose design changes based on simple feedback | * T05.G2.02: Identify features that make a design more accessible | * T05.G4.01: Identify key details in a user persona | * T05.G4.02: Match designs to personas | * T05.G3.04: Decide what a simple simulation should show | * T05.G3.04: Decide what a simple simulation should show | * T05.G3.03: Choose design changes based on simple feedback | * T05.G4.02: Match designs to personas | * T05.G4.04a: Write one clear user need statement | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T05.G5.01: Write clear user needs and requirements for a small app | * T05.G5.02: Create a low‑fidelity sketch for a user story | * T01.G3.01: Complete a simple script with missing blocks | * T05.G4.05: Decide what to include vs ignore in a simulation | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T05.G3.05: Select simple rules for a simulation | * T05.G4.05: Decide what to include vs ignore in a simulation | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T05.G3.01: Put human‑centered design steps in order | * T05.G3.03: Choose design changes based on simple feedback | * T05.G4.04: Choose appropriate accessibility improvements | * T05.G4.05: Decide what to include vs ignore in a simulation | * T05.G4.02: Match designs to personas | * T05.G4.04: Choose appropriate accessibility improvements | * T05.G6.01: Apply empathy, needs, and accessibility checklist to a design | * T05.G4.02: Match designs to personas | * T05.G6.03: Analyze short interview or survey data to extract user needs | * T01.G3.01: Complete a simple script with missing blocks | * T05.G4.05: Decide what to include vs ignore in a simulation | * T05.G4.06: Explain why a simplification is reasonable | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T05.G4.05: Decide what to include vs ignore in a simulation | * T05.G4.06: Explain why a simplification is reasonable | * T05.G5.05: Plan how to test whether a design meets user needs | * T05.G5.06: Plan what to measure in a simulation experiment | * T05.G6.01: Apply empathy, needs, and accessibility checklist to a design | * T05.G5.05: Plan how to test whether a design meets user needs | * T05.G5.05a: Identify accessibility features needed in a design | * T05.G7.01: Perform a checklist-based accessibility review of a project | * T05.G5.01: Write clear user needs and requirements for a small app | * T05.G5.05: Plan how to test whether a design meets user needs | * T05.G7.03: Identify potential unintended harms from a design | * T05.G5.05: Plan how to test whether a design meets user needs | * T05.G6.04: Update a design based on specific user feedback | * T05.G7.05: Interpret usage or feedback data to find UX problems | * T05.G7.06: Choose design changes based on data patterns | * T05.G6.04: Update a design based on specific user feedback | * T05.G6.01: Apply empathy, needs, and accessibility checklist to a design | * T05.G8.01: Create a concise design brief with users, goals, and constraints | * T05.G6.05: Plan a simple CreatiCode simulation with variables, rules, and UI | * T05.G6.06: Justify what is modeled vs simplified in a simulation design | * T05.G8.03: Plan controlled simulation experiments (change one variable) | * T05.G6.01: Apply empathy, needs, and accessibility checklist to a design | * T05.G7.06: Choose design changes based on data patterns | * T05.G8.01: Create a concise design brief with users, goals, and constraints | * T05.G8.03: Plan controlled simulation experiments (change one variable) | * T01.G1.01: Put pictures in order to plant a seed | * T01.G2.02: Use ""repeat"" to make directions shorter | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T06.G3.02: Build a key‑press script that controls a sprite | * T06.G3.03: Build a sprite‑click script that triggers an action | * T06.G3.04: Match code snippets to the event that triggers them | * T08.G3.01: Use a simple if in a script | * T06.G3.05: Decide which event type to use for a behavior | * T07.G3.02: Trace a script with a simple loop | * T06.G3.06: Trace a project with a single event and predict output | * T08.G3.02: Decide when a single if is enough | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T06.G3.07: Trace a project with two simple events and predict outputs | * T07.G3.02: Trace a script with a simple loop | * T06.G3.08: Fix a script that is missing an event block | * T09.G3.02: Use a variable in a conditional (if block) | * T06.G3.09: Fix a script that uses the wrong event type | * T08.G3.01: Use a simple if in a script | * T06.G4.01: Build a sprite with several event handlers (green flag + keys) | * T06.G4.02: Trace which scripts run for different inputs | * T08.G3.01: Use a simple if in a script | * T06.G4.03: Recognize when a broadcast could connect sprites | * T06.G4.04: Build a simple broadcast and receiver pair | * T06.G4.04: Build a simple broadcast and receiver pair | * T06.G4.01: Build a sprite with several event handlers (green flag + keys) | * T06.G3.08: Fix a script that is missing an event block | * T06.G4.04: Build a simple broadcast and receiver pair | * T06.G4.05: Match a broadcast send to its receivers | * T06.G4.01: Build a sprite with several event handlers (green flag + keys) | * T06.G4.08: Use a ""when touching"" event to trigger sprite collision actions | * T06.G4.04: Build a simple broadcast and receiver pair | * T06.G4.07: Fix a missing receiver for a broadcast | * T06.G4.06: Fix a sprite that doesn't respond because the event is wrong | * T06.G4.07: Fix a missing receiver for a broadcast | * T06.G4.04: Build a simple broadcast and receiver pair | * T06.G4.07: Fix a missing receiver for a broadcast | * T01.G3.01: Complete a simple script with missing blocks | * T06.G4.06: Fix a sprite that doesn't respond because the event is wrong | * T06.G4.07: Fix a missing receiver for a broadcast | * T06.G4.06: Fix a sprite that doesn't respond because the event is wrong | * T06.G4.07: Fix a missing receiver for a broadcast | * T06.G5.01: Identify standard event patterns in a small game | * T06.G5.01: Identify standard event patterns in a small game | * T09.G4.01: Use a variable in complex expressions | * T06.G5.03: Design a simple broadcast sequence for level start/end | * T09.G4.01: Use a variable in complex expressions | * T06.G5.03: Design a simple broadcast sequence for level start/end | * T06.G5.04: Trace event and broadcast order for a scenario | * T06.G5.05: Find and fix conflicting event scripts | * T06.G6.01: Trace event execution paths in a multi‑event program | * T06.G4.04A: Use 'broadcast and wait' to sequence sprite actions | * T06.G5.05: Find and fix conflicting event scripts | * T06.G5.06: Add explanatory comments to individual event handlers | * T12.G5.01: Extract repeated code into reusable blocks | * T06.G5.03: Design a simple broadcast sequence for level start/end | * T06.G5.05: Find and fix conflicting event scripts | * T06.G5.06: Add explanatory comments to individual event handlers | * T06.G6.01: Trace event execution paths in a multi‑event program | * T16.G3.02: Create a widget and change its properties | * T06.G6.04: Design meaningful custom broadcasts and document them | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G4.01: Use a variable in complex expressions | * T08.G4.01: Use nested if/else for multi‑way decisions | * T06.G6.03: Refactor event handlers to reduce duplication and improve structure | * T06.G6.04: Design meaningful custom broadcasts and document them | * T06.G6.08: Use a variable to track simple program states | * T09.G5.01: Use variables in complex expressions | * T06.G7.01: Create a simple state machine with broadcasts | * T09.G5.01: Use variables in complex expressions | * T01.G5.01: Complete a simple script with missing blocks | * T06.G6.03: Refactor event handlers for clarity and grouping | * T06.G6.04: Design meaningful custom broadcasts and document them | * T09.G5.01: Use variables in complex expressions | * T06.G6.03: Refactor event handlers for clarity and grouping | * T06.G6.04: Design meaningful custom broadcasts and document them | * T06.G7.03: Design a broadcast protocol to decouple components | * T06.G7.01: Create a simple state machine with broadcasts | * T09.G5.01: Use variables in complex expressions | * T06.G6.01: Trace event execution paths in a multi‑event program | * T06.G7.03: Design a broadcast protocol to decouple components | * T06.G7.04: Compare tightly coupled vs broadcast‑based designs | * T06.G6.01: Trace event execution paths in a multi‑event program | * T06.G7.03: Design a broadcast protocol to decouple components | * T06.G7.04: Compare tightly coupled vs broadcast‑based designs | * T08.G6.01: Use conditionals to control simulation steps | * T02.G6.01: Design a flowchart for a simple guessing game | * T06.G6.01: Trace event execution paths in a multi‑event program | * T06.G7.03: Design a broadcast protocol to decouple components | * T06.G7.04: Compare tightly coupled vs broadcast‑based designs | * T06.G6.01: Trace event execution paths in a multi‑event program | * T06.G7.03: Design a broadcast protocol to decouple components | * T06.G7.04: Compare tightly coupled vs broadcast‑based designs | * T08.G6.01: Use conditionals to control simulation steps | * T07.K.01: Complete a repeating pattern | * T07.G1.01: Count repetitions in a pattern | * T07.G1.02: Match ""do N times"" instructions to outcomes | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T04.G1.01: Match a picture pattern to a movement pattern | * T04.G2.01: Identify the repeating unit in a longer pattern | * T01.G2.05: Complete a simple if/then algorithm | * T07.G2.01: Identify when to use ""repeat"" vs ""do once"" | * T07.G3.01: Use a counted repeat loop | * T04.G3.02: Match a ""repeat N"" loop to repeated behavior | * T07.G3.01: Use a counted repeat loop | * T04.G3.03: Recognize a simple project template | * T07.G3.03: Build a forever loop for simple animation | * T09.G3.02: Use a variable in a conditional (if block) | * T07.G3.04: Use repeat‑until to reach a simple goal | * T08.G3.03: Pick the right conditional block for a scenario | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T07.G3.03: Build a forever loop for simple animation | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T07.G3.04: Use repeat‑until to reach a simple goal | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T07.G3.05: Fix a simple repeat loop count | * T07.G4.01: Create a forever game loop for controls | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T07.G3.04: Use repeat‑until to reach a simple goal | * T08.G3.01: Use a simple if in a script | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T07.G3.04: Use repeat‑until to reach a simple goal | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T07.G3.04: Use repeat‑until to reach a simple goal | * T08.G3.01: Use a simple if in a script | * T07.G4.03: Use a loop counter variable | * T07.G4.06: Trace code that combines a loop and a condition | * T07.G3.01: Use a counted repeat loop | * T07.G4.01: Create a forever game loop for controls | * T07.G4.05: Debug complex loop conditions and boundaries | * T07.G4.06: Trace code that combines a loop and a condition | * T07.G4.05: Debug complex loop conditions and boundaries | * T07.G4.06: Trace code that combines a loop and a condition | * T07.G4.03: Use a loop counter variable | * T07.G4.06: Trace code that combines a loop and a condition | * T07.G4.05: Debug complex loop conditions and boundaries | * T07.G4.07: Trace simple nested loops with fixed bounds | * T07.G4.03: Use a loop counter variable and for loops | * T07.G5.03: Use loops to compute aggregates | * T07.G5.04: Nested loops for advanced patterns or tilings | * T09.G4.01: Use variables to store and update game state | * T07.G4.03: Use a loop counter variable and for loops | * T07.G4.04: Identify and convert simple repeated code into loops | * T07.G5.04: Nested loops for advanced patterns or tilings | * T07.G5.02: Build a list with a loop | * T07.G5.03: Use loops to compute aggregates | * T09.G4.01: Use variables to store and update game state | * T07.G4.05: Debug complex loop conditions and boundaries | * T07.G5.01: Simulate repeated experiments with a loop | * T07.G5.04: Nested loops for advanced patterns or tilings | * T08.G3.01: Use a simple if in a script | * T07.G5.03: Use loops to compute aggregates | * T07.G5.04: Nested loops for advanced patterns or tilings | * T09.G4.01: Use variables to store and update game state | * T07.G5.03: Use loops to compute aggregates | * T07.G5.04: Nested loops for advanced patterns or tilings | * T08.G3.01: Use a simple if in a script | * T07.G5.01: Simulate repeated experiments with a loop | * T07.G5.03: Use loops to compute aggregates | * T07.G6.05: Trace nested loops using a trace table | * T07.G5.02: Build a list with a loop | * T07.G6.03: Loop‑based search in a list | * T07.G6.04: Avoid and fix infinite loops | * T07.G5.02: Build a list with a loop | * T07.G6.03: Loop‑based search in a list | * T10.G5.01: Create and populate a list with items | * T07.G6.05: Trace nested loops using a trace table | * T07.G6.06: Trace nested loops that generate visual patterns | * T07.G6.07: Use loops to update values iteratively | * T07.G6.05: Trace nested loops using a trace table | * T07.G6.06: Trace nested loops that generate visual patterns | * T08.G6.01: Use conditionals to control simulation steps | * T07.G6.05: Trace nested loops using a trace table | * T07.G6.07: Use loops to update values iteratively | * T08.G6.01: Use conditionals to control simulation steps | * T07.G6.05: Trace nested loops using a trace table | * T07.G6.07: Use loops to update values iteratively | * T08.G6.01: Use conditionals to control simulation steps | * T09.G5.01: Use a variable to track state across interactions | * T07.G6.01: Trace nested loops with variable bounds | * T07.G7.03: Compare loop algorithms by counting steps | * T07.G7.04: Loop patterns for counting and accumulation | * T01.G6.01: Count comparisons in linear and binary search | * T07.G6.01: Trace nested loops with variable bounds | * T07.G7.03: Compare loop algorithms by counting steps | * T07.G7.04: Loop patterns for counting and accumulation | * T08.G6.01: Use conditionals to control simulation steps | * T07.G8.02: Design iterative algorithms with loops | * T09.G6.01: Model real-world quantities using variables and formulas | * T07.G8.02: Design iterative algorithms with loops | * T08.G6.01: Use conditionals to control simulation steps | * T07.G8.02: Design iterative algorithms with loops | * T09.G6.01: Model real-world quantities using variables and formulas | * T07.G6.01: Trace nested loops with variable bounds | * T07.G7.03: Compare loop algorithms by counting steps | * T07.G7.04: Loop patterns for counting and accumulation | * T09.G6.01: Model real-world quantities using variables and formulas | * T07.G6.01: Trace nested loops with variable bounds | * T07.G7.03: Compare loop algorithms by counting steps | * T07.G7.04: Loop patterns for counting and accumulation | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T08.GK.01: Match pictures to ""if it rains"" rules | * T08.GK.02: Choose what happens next based on yes/no | * T08.G1.01: Sort cards by if-then rules | * T08.G1.02: Predict the outcome of an if-then rule | * T08.G1.03: Choose between two actions based on a condition | * T08.G2.01: Follow branching paths based on yes/no questions | * T08.G2.02: Create a simple if-then-else rule for a scenario | * T07.G3.01: Use a counted repeat loop | * T08.G2.03: Identify which rule applies in a situation | * T08.G3.01: Use a simple if in a script | * T08.G3.02: Decide when a single if is enough | * T07.G3.02: Trace a script with a simple loop | * T08.G3.03: Pick the right conditional block for a scenario | * T07.G3.03: Build a forever loop for simple animation | * T08.G3.04: Trace code with a single if/else | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong comparison operator | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.05: Fix a condition that uses the wrong comparison operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G4.01: Combine two conditions with AND | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.05: Fix a condition that uses the wrong comparison operator | * T08.G4.03: Trace code with compound conditionals | * T08.G4.04: Nest if/else statements | * T08.G4.01: Combine two conditions with AND | * T08.G4.02: Combine two conditions with OR | * T08.G4.05: Use else-if for multiple exclusive conditions | * T06.G3.02: Build a key‑press script that controls a sprite | * T08.G3.05: Fix a condition that uses the wrong comparison operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T08.G4.01: Combine two conditions with AND | * T08.G4.02: Combine two conditions with OR | * T08.G4.03: Trace code with compound conditionals | * T08.G3.04: Trace code with a single if/else | * T08.G4.05: Use else-if for multiple exclusive conditions | * T08.G4.05: Use else-if for multiple exclusive conditions | * T08.G4.06: Convert nested if to cleaner logic | * T08.G4.09: Trace code with a sequence of if/else blocks | * T08.G4.01: Combine two conditions with AND | * T08.G4.02: Combine two conditions with OR | * T08.G4.03: Trace code with compound conditionals | * T08.G5.02: Use NOT to invert conditions | * T08.G4.08: Analyze and fix a compound logic bug | * T08.G5.01: Design multi-branch decision logic | * T08.G5.03: Combine three or more conditions | * T08.G5.01: Design multi-branch decision logic | * T08.G4.06: Convert nested if to cleaner logic | * T08.G5.01: Design multi-branch decision logic | * T08.G4.07: Use if to control state changes | * T06.G4.01: Build scripts triggered by multiple event types | * T08.G5.03: Combine three or more conditions | * T08.G5.04: Trace complex decision logic | * T08.G5.03: Combine three or more conditions | * T08.G5.04: Trace complex decision logic | * T08.G4.07: Use if to control state changes | * T08.G5.03: Combine three or more conditions | * T08.G5.04: Trace complex decision logic | * T08.G4.08: Analyze and fix a compound logic bug | * T08.G5.01: Design multi-branch decision logic | * T08.G5.02: Use NOT to invert conditions | * T08.G6.02: Implement simple state machines using conditionals | * T08.G6.03: Debug multi-condition logic | * T08.G5.01: Design multi-branch decision logic | * T08.G6.02: Implement simple state machines using conditionals | * T08.G6.03: Debug multi-condition logic | * T04.G6.01: Group snippets by underlying algorithm pattern | * T08.G6.01: Use conditionals to control simulation steps | * T08.G7.01: Reason about fairness using conditions | * T08.G7.02: Design tests for condition-heavy code | * T06.G6.01: Trace event execution paths in a multi‑event program | * T08.G6.01: Use conditionals to control simulation steps | * T08.G7.01: Reason about fairness using conditions | * T08.G7.02: Design tests for condition-heavy code | * T01.GK.01: Put pictures in order for getting ready for bed | * T09.GK.01: Recognize that a label can hold a number | * T09.GK.02: Identify which label changed after an action | * T03.G1.01: Describe what one part of a system does | * T09.G1.01: Change a displayed number by clicking a button | * T09.G1.02: Use a picture-based counter to track items collected | * T09.G2.01: Set a starting value for a counter before a game begins | * T08.G2.01: Follow branching paths based on yes/no questions | * T09.G2.02: Compare a counter to a target number to trigger an event | * T03.G2.01: Choose subtasks for a simple project idea | * T09.G3.01.01: Create a new variable with a descriptive name | * T09.G3.01.02: Set a variable to an initial value at program start | * T09.G3.01.03: Change a variable value by 1 using the change block | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T09.G3.02: Use change and reduce blocks to modify a variable | * T08.G3.02: Decide when a single if is enough | * T09.G3.03: Use a variable in a simple conditional (if block) | * T09.G3.04: Debug a single missing or wrong variable block | * T08.G3.04: Trace code with a single if/else | * T09.G3.02: Use change and reduce blocks to modify a variable | * T09.G3.05: Trace code with variables to predict outcomes | * T09.G4.01: Use addition and subtraction in variable expressions | * T09.G4.02: Use multiplication and division in expressions | * T06.G3.02: Build a key‑press script that controls a sprite | * T09.G3.03: Use a variable in a simple conditional (if block) | * T07.G3.01: Use a counted repeat loop | * T09.G3.02: Use change and reduce blocks to modify a variable | * T09.G3.03: Use a variable in a simple conditional (if block) | * T09.G3.05: Trace code with variables to predict outcomes | * T09.G3.03: Use a variable in a simple conditional (if block) | * T09.G3.04: Debug a single missing or wrong variable block | * T09.G3.01.02: Set a variable to an initial value at program start | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T07.G3.01: Use a counted repeat loop | * T09.G3.04: Debug a single missing or wrong variable block | * T09.G4.05: Use a variable as a loop counter | * T09.G4.03: Combine two arithmetic operators in a single expression | * T09.G4.09: Debug variable initialization and update frequency errors | * T09.G4.04: Store and use user input in a variable | * T09.G4.07: Use a flag variable to track state (0/1 or true/false) | * T09.G5.02: Create and use string variables | * T09.G4.09: Debug variable initialization and update frequency errors | * T09.G4.05: Use a variable as a loop counter | * T09.G4.09: Debug variable initialization and update frequency errors | * T09.G3.05: Trace code with variables to predict outcomes | * T09.G4.05: Use a variable as a loop counter | * T09.G5.01: Use multiple variables together in a single expression | * T09.G5.06: Trace a counter through loop iterations to predict final value | * T09.G4.06: Use comparison operators (=, ≠, >, <, ≥, ≤) in conditionals | * T09.G5.05: Use the accumulator pattern to compute running totals | * T09.G5.05: Use the accumulator pattern to compute running totals | * T09.G5.07: Trace code with multiple interacting variables | * T09.G5.01: Use multiple variables together in a single expression | * T09.G5.07: Trace code with multiple interacting variables | * T09.G6.02: Apply operator precedence rules (PEMDAS) in expressions | * T09.G6.02: Apply operator precedence rules (PEMDAS) in expressions | * T09.G5.03: Join strings using concatenation | * T09.G6.04: Use string length and case conversion operations | * T09.G5.05: Use the accumulator pattern to compute running totals | * T09.G6.02: Apply operator precedence rules (PEMDAS) in expressions | * T09.G5.04: Use variables as settings to control program behavior | * T09.G4.09: Debug variable initialization and update frequency errors | * T09.G5.07: Trace code with multiple interacting variables | * T09.G6.01: Model real-world quantities using variables and formulas | * T09.G6.06: Use temporary variables for multi-step calculations | * T09.G6.03: Use exponents (^) in expressions | * T09.G5.05: Use the accumulator pattern to compute running totals | * T09.G6.06: Use temporary variables for multi-step calculations | * T09.G5.08: Track high score using variable comparison | * T09.G6.07: Debug off-by-one and comparison operator errors | * T09.G5.04: Use variables as settings to control program behavior | * T09.G6.01: Model real-world quantities using variables and formulas | * T09.G7.04: Understand local vs global variable scope | * T09.G6.07: Debug off-by-one and comparison operator errors | * T09.G7.01: Model dynamic systems where variables change over time | * T09.G7.03: Use compound conditions (AND, OR, NOT) with variables | * T09.G7.06: Predict behavior changes from modifying variable values | * T09.G8.01.01: Use variables to track index position in linear search | * T09.G8.01.02: Use flag variables in search algorithms to track found status | * T09.G6.03: Use exponents (^) in expressions | * T09.G7.06: Predict behavior changes from modifying variable values | * T09.G7.01.01: Use mathematical functions (abs, round, floor, ceiling, sqrt) in expressions | * T09.G7.01.01: Use mathematical functions (abs, round, floor, ceiling, sqrt) in expressions | * T09.G7.04: Understand local vs global variable scope | * T09.G7.05: Save and load variables to/from files | * T09.G7.04: Understand local vs global variable scope | * T09.G7.06: Predict behavior changes from modifying variable values | * T09.G6.03: Use exponents (^) in expressions | * T09.G7.02: Compute average using sum and count variables | * T09.G7.03: Use compound conditions (AND, OR, NOT) with variables | * T09.G7.02: Compute average using sum and count variables | * T09.G8.01.01: Use variables to track index position in linear search | * T10.GK.01: Sort picture cards into groups | * T10.GK.02: Count items in each group | * T10.GK.01: Sort picture cards into groups | * T01.GK.03: Find the first and last pictures | * T10.GK.01: Sort picture cards into groups | * T10.GK.01: Sort picture cards into groups | * T10.GK.02: Count items in each group | * T10.GK.01: Sort picture cards into groups | * T10.GK.04: Add an item to the right group | * T10.GK.02: Count items in each group | * T10.GK.06: Look at a simple picture table | * T10.GK.06: Look at a simple picture table | * T10.G1.03: Read information from a picture table | * T10.GK.03: Find which group has more | * T10.G1.03: Read information from a picture table | * T01.GK.07: Find the pattern that repeats | * T10.G1.01: Sort items using two rules | * T10.G1.03: Read information from a picture table | * T10.G2.01: Build a simple data table from a list | * T10.G2.01: Build a simple data table from a list | * T10.G2.01: Build a simple data table from a list | * T01.G1.01: Put pictures in order to plant a seed | * T10.G2.01: Build a simple data table from a list | * T10.G2.05: Find all rows that match a rule | * T10.G2.01: Build a simple data table from a list | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T10.G3.01: Create a list and add items to it | * T10.G3.01: Create a list and add items to it | * T10.G3.02: Read items from a list by position (index starts at 1) | * T10.G3.03: Get the length of a list | * T07.G3.01: Use a counted repeat loop | * T10.G3.01: Create a list and add items to it | * T10.G3.02: Read items from a list by position (index starts at 1) | * T10.G3.01: Create a list and add items to it | * T08.G3.01: Use a simple if in a script | * T10.G3.05: Loop through each item in a list | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T10.G3.03: Get the length of a list | * T08.G3.01: Use a simple if in a script | * T10.G3.01: Create a list and add items to it | * T10.G3.05: Loop through each item in a list | * T08.G3.01: Use a simple if in a script | * T10.G3.01: Create a list and add items to it | * T10.G3.02: Read items from a list by position (index starts at 1) | * T10.G3.02: Read items from a list by position (index starts at 1) | * T10.G3.03: Get the length of a list | * T10.G3.02: Read items from a list by position (index starts at 1) | * T10.G3.01: Create a list and add items to it | * T10.G3.01: Create a list and add items to it | * T10.G3.02: Read items from a list by position (index starts at 1) | * T10.G3.01: Create a list and add items to it | * T10.G3.01: Create a list and add items to it | * T10.G3.03: Get the length of a list | * T10.G3.05: Loop through each item in a list | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T10.G4.07: Find the maximum or minimum item in a list manually | * T08.G4.01: Use if-else to choose between two actions | * T10.G4.01: Find an item's position in a list (linear search) | * T10.G4.02: Store and retrieve parallel list data | * T10.G4.03: Insert an item at a specific position in a list | * T10.G4.04: Replace an item in a list | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T10.G3.01: Create a list and add items to it | * T10.G3.05: Loop through each item in a list | * T10.G3.01: Create a list and add items to it | * T09.G4.01: Store and compare text strings in variables | * T10.G4.12: Split a text string into a list | * T09.G4.01: Store and compare text strings in variables | * T10.G4.02: Store and retrieve parallel list data | * T10.G5.01: Understand table structure (rows, columns, cells) | * T10.G5.02: Create a table and add columns | * T10.G5.03: Add rows of data to a table | * T10.G5.04: Read a cell value from a table | * T10.G5.04: Read a cell value from a table | * T07.G3.01: Use a counted repeat loop | * T10.G5.06: Get the row count and find a row by value | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T10.G5.07: Loop through table rows to compute aggregates | * T10.G4.06: Use built-in blocks to get list statistics | * T10.G5.06: Get the row count and find a row by value | * T10.G5.03: Add rows of data to a table | * T10.G5.06: Get the row count and find a row by value | * T10.G5.03: Add rows of data to a table | * T10.G3.01: Create a list and add items to it | * T10.G4.05: Use built-in blocks to sort a list | * T10.G5.04: Read a cell value from a table | * T10.G5.07: Loop through table rows to compute aggregates | * T08.G4.01: Use if-else to choose between two actions | * T10.G5.03: Add rows of data to a table | * T10.G5.06: Get the row count and find a row by value | * T10.G5.04: Read a cell value from a table | * T10.G5.08: Use built-in table aggregate blocks | * T10.G6.02: Filter table rows based on a condition | * T10.G4.08: Filter items from a list based on a condition | * T10.G3.06: Check if a list contains a specific item | * T10.G3.06: Check if a list contains a specific item | * T10.G4.08: Filter items from a list based on a condition | * T10.G6.05: Group data and compute aggregates per group | * T10.G5.02: Create a table and add columns | * T10.G5.04: Read a cell value from a table | * T10.G5.02: Create a table and add columns | * T09.G5.01: Create multiple related variables for complex state | * T10.G5.08: Use built-in table aggregate blocks | * T10.G6.05: Group data and compute aggregates per group | * T10.G5.05: Update a cell value in a table | * T10.G5.07: Loop through table rows to compute aggregates | * T08.G5.01: Use compound conditions with and/or/not | * T10.G7.05: Clean and transform table data | * T10.G5.09: Delete rows from a table | * T08.G5.01: Use compound conditions with and/or/not | * T10.G6.05: Group data and compute aggregates per group | * T10.G6.01: Sort a table by a column | * T08.G5.01: Use compound conditions with and/or/not | * T10.G4.08: Filter items from a list based on a condition | * T09.G6.02: Use text operations (join, split, substring, case conversion) | * T10.G7.02: Import external data into a table | * T10.G5.03: Add rows of data to a table | * T10.G7.07: Analyze a dataset to find patterns or outliers | * T10.G5.08: Use built-in table aggregate blocks | * T07.G5.01: Use conditional loops for searching | * T10.G6.04: Use table lookup to find related data | * T10.G4.10: Swap two items in a list | * T07.G6.01: Trace nested loops with variable bounds | * T10.G8.02: Implement bubble sort algorithm step by step | * T10.G4.07: Find the maximum or minimum item in a list manually | * T10.G7.03: Design a table schema for a real-world scenario | * T10.G5.07: Loop through table rows to compute aggregates | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G7.07: Analyze a dataset to find patterns or outliers | * T10.G6.01: Sort a table by a column | * T10.G8.01: Use nested loops to compare data across two tables | * T10.G7.03: Design a table schema for a real-world scenario | * T10.G8.03: Implement selection sort algorithm step by step | * T10.G4.02: Store and retrieve parallel list data | * T09.G7.01: Compare computational efficiency of different approaches | * T10.G8.02: Implement bubble sort algorithm step by step | * T09.G7.01: Compare computational efficiency of different approaches | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.02: Trace a script with a simple loop | * T01.G3.12: Predict the final state of a simple algorithm | * T11.G3.01: Understand when to use custom blocks vs loops | * T08.G3.02: Decide when a single if is enough | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T11.G3.02: Use a pre-made custom block with parameters | * T09.G3.02: Use a variable in a conditional (if block) | * T08.G3.03: Pick the right conditional block for a scenario | * T11.G3.03: Identify repeated or grouped actions that could become custom blocks | * T09.G3.04: Debug a single missing or wrong variable block | * T07.G3.04: Use repeat‑until to reach a simple goal | * T11.G3.04: Understand the concept of return values | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T11.G3.05: Explore the ""Make a Block"" interface in CreatiCode | * T11.G3.04: Understand the concept of return values | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T11.G3.04: Understand the concept of return values | * T11.G3.04: Understand the concept of return values | * T11.G3.02: Use a pre-made custom block with parameters | * T11.G4.04: Describe the purpose of each custom block in a script | * T11.G4.05: Trace execution through a script with custom blocks | * T11.G4.05: Trace execution through a script with custom blocks | * T11.G4.06: Understand the argument block for accessing parameters | * T11.G5.01: Decompose a problem into logical custom block boundaries | * T11.G4.04: Describe the purpose of each custom block in a script | * T11.G4.05: Trace execution through a script with custom blocks | * T11.G4.03: Use a reporter block's result in a calculation or condition | * T11.G4.05: Trace execution through a script with custom blocks | * T11.G5.03: Choose between adding a parameter vs. creating a separate block | * T11.G5.04: Analyze a modular program structure | * T11.G5.05: Define a custom block with two or more parameters | * T11.G5.04: Analyze a modular program structure | * T11.G5.05: Define a custom block with two or more parameters | * T11.G5.04: Analyze a modular program structure | * T11.G5.03: Choose between adding a parameter vs. creating a separate block | * T11.G5.06: Define a custom reporter block that returns a value | * T11.G6.03: Refactor spaghetti code into organized custom blocks | * T11.G6.04: Evaluate and critique custom block designs | * T11.G6.02: Create modular programs with multiple custom blocks | * T11.G6.03: Refactor spaghetti code into organized custom blocks | * T11.G6.04: Evaluate and critique custom block designs | * T11.G6.01: Design custom blocks with clear, predictable interfaces | * T11.G6.03: Refactor spaghetti code into organized custom blocks | * T11.G6.04: Evaluate and critique custom block designs | * T11.G5.07: Debug a script with incorrect custom block calls | * T11.G6.03: Refactor spaghetti code into organized custom blocks | * T11.G6.04: Evaluate and critique custom block designs | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T11.G7.02: Design a set of related custom blocks for a subsystem | * T11.G7.03: Understand encapsulation and information hiding | * T11.G7.02: Design a set of related custom blocks for a subsystem | * T11.G7.03: Understand encapsulation and information hiding | * T11.G7.04: Trace and debug multi-level custom block calls | * T10.G7.01: Use lists of lists (2D lists) to store tabular data | * T11.G7.02: Design a set of related custom blocks for a subsystem | * T11.G7.03: Understand encapsulation and information hiding | * T11.G7.03: Understand encapsulation and information hiding | * T11.G7.04: Trace and debug multi-level custom block calls | * T11.G8.02: Refactor a large program into a hierarchical block structure | * T01.GK.03: Find the first and last pictures | * T12.G1.01: Find the main set of instructions | * T03.GK.01: Identify parts that make up a whole | * T12.G1.01: Find the main set of instructions | * T01.G1.01: Put pictures in order to plant a seed | * T12.G1.02: Give a clear title to a set of steps | * T01.G1.01: Put pictures in order to plant a seed | * T03.G1.02: Group related parts into categories | * T03.G1.03: List steps for a simple classroom routine | * T07.G3.02: Trace a script with a simple loop | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T12.G2.01: Add a note to explain a section of a plan | * T09.G3.02: Use a variable in a conditional (if block) | * T12.G3.01: Add a comment to explain a block in a script | * T07.G3.03: Build a forever loop for simple animation | * T08.G3.01: Use a simple if in a script | * T08.G3.03: Pick the right conditional block for a scenario | * T10.G3.02: Find and count items in a list with a condition | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T12.G3.03: Simplify nested or repeated blocks for readability | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T12.G3.02: Create a header comment for a script | * T12.G3.03: Simplify nested or repeated blocks for readability | * T12.G3.04: Explain the structure of a multi-script project | * T12.G3.05: Create and use a simple custom block | * T12.G3.04: Explain the structure of a multi-script project | * T12.G3.05: Create and use a simple custom block | * T12.G4.02: Choose descriptive names for custom blocks | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T12.G3.04: Explain the structure of a multi-script project | * T12.G3.05: Create and use a simple custom block | * T12.G4.02: Choose descriptive names for custom blocks | * T12.G4.01: Document a program with embedded comments | * T12.G4.04: Analyze and improve variable scope and naming | * T12.G3.01: Add a comment to explain a block in a script | * T12.G4.04: Analyze and improve variable scope and naming | * T12.G4.01: Document a program with embedded comments | * T12.G4.03: Refactor identical repeated code into a custom block | * T12.G4.02: Choose descriptive names for custom blocks | * T12.G4.04: Analyze and improve variable scope and naming | * T12.G4.05: Add input parameters to a custom block | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script | * T12.G5.03: Organize a project with 3+ features into labeled sections or scripts | * T12.G5.04: Review another student's code and suggest at least 2 organizational improvements | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T12.G5.02: Add inline comments explaining how code works and why choices were made | * T12.G4.02: Choose descriptive names for custom blocks | * T12.G4.04: Analyze and improve variable scope and naming | * T12.G5.04: Review another student's code and suggest at least 2 organizational improvements | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T12.G5.01: Write a project description explaining what the program does | * T12.G5.04: Review another student's code and suggest at least 2 organizational improvements | * T08.G5.01: Use a simple if in a script | * T12.G5.05: Use return values in custom blocks | * T12.G6.01: Analyze a program's structure using a checklist and suggest specific improvements | * T08.G5.01: Use a simple if in a script | * T12.G5.01: Write a project description explaining what the program does | * T12.G6.02: Use comments to explain algorithm logic | * T08.G5.01: Use a simple if in a script | * T12.G6.01: Analyze a program's structure using a checklist and suggest specific improvements | * T12.G6.03: Follow a provided style guide for naming conventions | * T07.G5.01: Use a counted repeat loop | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T12.G6.02: Use comments to explain algorithm logic | * T12.G6.04: Document code for collaborative maintenance | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T12.G7.03: Create a code review checklist for clarity | * T12.G7.04: Document design decisions in code | * T06.G6.01: Trace event execution paths in a multi‑event program | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T12.G7.02: Compare two code versions and identify readability differences | * T12.G7.04: Document design decisions in code | * T06.G6.01: Trace event execution paths in a multi‑event program | * T08.G6.01: Use conditionals to control simulation steps | * T12.G7.01: Decompose complex logic into custom blocks with clear responsibilities | * T12.G7.04: Document design decisions in code | * T06.G6.01: Trace event execution paths in a multi‑event program | * T12.G7.02: Compare two code versions and identify readability differences | * T12.G8.02: Create comprehensive documentation for a complex project | * T12.G7.03: Create a code review checklist for clarity | * T12.G8.01: Apply consistent style across a large project | * T13.GK.01: Spot a missing or wrong action | * T01.GK.03: Find the first and last pictures | * T13.GK.01: Spot a missing or wrong action | * T01.GK.03: Find the first and last pictures | * T01.GK.02: Put pictures in order for coming to class | * T04.GK.02: Extend a repeating pattern by one tile | * T01.GK.01: Put pictures in order for getting ready for bed | * T01.G1.06: Fix a routine with one wrong step | * T01.G1.05: Find the missing step in an algorithm | * T03.G1.03: List steps for a simple classroom routine | * T04.G2.01: Identify the repeating unit in a longer pattern | * T01.G2.01: Find actions that repeat in everyday tasks | * T03.G1.03: List steps for a simple classroom routine | * T01.G1.09: Match an algorithm to its goal | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T13.G2.02: Trace a set of steps and predict behavior | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T13.G2.02: Trace a set of steps and predict behavior | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T13.G2.03: Fix a repeated step that happens too many or too few times | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T13.G2.02: Trace a set of steps and predict behavior | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T13.G2.04: Add a simple check to see if steps worked | * T13.G3.01: Test a simple block-based script | * T13.G3.01.02: Trace a block script step-by-step before running it | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T13.G3.02: Fix a wrong block in a sequence | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T13.G3.01: Test a simple block-based script | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T13.G3.04: Try again and adjust when program doesn't work | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T13.G3.02: Fix a wrong block in a sequence | * T08.G3.01: Use a simple if in a script | * T13.G3.01: Test a simple block-based script | * T13.G4.05.01: Create a simple test plan with test cases | * T08.G3.01: Use a simple if in a script | * T13.G4.03: Design an alternative approach and compare results | * T13.G3.04: Try again and adjust when program doesn't work | * T06.G3.01: Build a green-flag script that runs a 3–5 block sequence | * T13.G3.02: Fix a wrong block in a sequence | * T13.G4.01: Debug a conditional inside a loop | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T13.G4.08: Distinguish between different types of bugs | * T08.G3.01: Use a simple if in a script | * T13.G4.02: Identify and manually test edge cases | * T13.G4.05.02: Run tests and record results | * T13.G4.01: Debug a conditional inside a loop | * T13.G4.06: Compare two programs solving the same task | * T13.G5.02: Add input validation to handle invalid entries | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T13.G5.06: Debug complex two-level nested structures | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T13.G4.01: Debug a conditional inside a loop | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T13.G4.07: Record what went wrong and how you fixed it | * T13.G5.01: Debug programs using tracing and logging | * T13.G4.07: Record what went wrong and how you fixed it | * T13.G5.01: Debug programs using tracing and logging | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T13.G5.01: Debug programs using tracing and logging | * T13.G5.05: Debug deeply nested structures (three+ levels) | * T08.G3.01: Use a simple if in a script | * T13.G5.01: Debug programs using tracing and logging | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T13.G5.02: Add input validation to handle invalid entries | * T13.G4.07: Record what went wrong and how you fixed it | * T13.G5.04: Modify a program to improve reliability and correctness | * T13.G5.01: Debug programs using tracing and logging | * T13.G6.02: Use a systematic debugging process | * T08.G5.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T13.G6.03: Design systematic boundary tests | * T08.G5.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T13.G6.01: Trace complex code with multiple variables | * T08.G5.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T13.G6.04: Document known limitations and potential bugs | * T08.G5.01: Use a simple if in a script | * T13.G6.02: Use a systematic debugging process | * T13.G6.04: Document known limitations and potential bugs | * T08.G5.01: Use a simple if in a script | * T13.G5.02: Add input validation to handle invalid entries | * T13.G6.03: Design systematic boundary tests | * T13.G6.02: Use a systematic debugging process | * T13.G6.03: Design systematic boundary tests | * T09.G6.01: Model real-world quantities using variables and formulas | * T13.G6.01: Trace complex code with multiple variables | * T13.G7.01: Write comprehensive test cases for an algorithm | * T06.G6.01: Trace event execution paths in a multi‑event program | * T08.G6.01: Use conditionals to control simulation steps | * T13.G6.01: Trace complex code with multiple variables | * T06.G6.01: Trace event execution paths in a multi‑event program | * T08.G6.01: Use conditionals to control simulation steps | * T13.G7.05: Anticipate runtime errors and add defensive checks | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T13.G7.02: Debug logic errors in complex programs | * T11.G5.01: Create a custom block with parameters | * T13.G6.01: Trace complex code with multiple variables | * T13.G7.02: Debug logic errors in complex programs | * T14.GK.02: Recognize a score in simple games | * T14.GK.03: Identify when a game starts and ends | * T01.GK.03: Find the first and last pictures | * T14.GK.03: Identify when a game starts and ends | * T14.G1.01: Identify the player, goal, and obstacles | * T14.GK.04: Match rewards to goals | * T01.GK.04: Pick the pictures that make sense | * T14.G1.01: Identify the player, goal, and obstacles | * T14.GK.01: Match controls to character actions | * T01.GK.01: Put pictures in order for getting ready for bed | * T14.GK.04: Match rewards to goals | * T01.G1.01: Put pictures in order to plant a seed | * T14.G1.02: Apply simple game rules | * T01.G1.04: Predict the next step in a story sequence | * T14.G1.05: Distinguish helpers from hazards | * T01.G1.01: Put pictures in order to plant a seed | * T14.G1.01: Identify the player, goal, and obstacles | * T01.G1.04: Predict the next step in a story sequence | * T14.G1.04: Predict the best next move | * T01.G1.10: Match pictures to ""if/then"" rules | * T14.G1.03: Compare game difficulty | * T14.G2.04: Sequence a safe route | * T01.G3.05: Replace repeated blocks with a repeat loop | * T07.G3.02: Trace a script with a simple loop | * T14.G2.04: Sequence a safe route | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G2.03: Recognize level progression | * T07.G3.03: Build a forever loop for simple animation | * T08.G3.02: Decide when a single if is enough | * T09.G3.02: Use a variable in a conditional (if block) | * T06.G3.06: Trace a project with a single event and predict output | * T10.G3.01: Loop through and process each item in a list | * T11.G3.01: Understand when to use custom blocks vs loops | * T14.G3.06: Create a start screen | * T12.G3.01: Write a comment explaining a complex block | * T08.G3.03: Pick the right conditional block for a scenario | * T09.G3.04: Debug a single missing or wrong variable block | * T07.G3.04: Use repeat‑until to reach a simple goal | * T11.G3.02: Use a pre-made custom block with parameters | * T08.G3.04: Trace code with a single if/else | * T14.G3.04: Detect touching a goal | * T07.G3.03: Build a forever loop for simple animation | * T08.G3.01: Use a simple if in a script | * T14.G3.01: Move a sprite with arrow keys (4 directions) | * T06.G3.02: Build a key‑press script that controls a sprite | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G3.01: Move a sprite with arrow keys (4 directions) | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.02: Move a projectile | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G3.01: Move a sprite with arrow keys (4 directions) | * T14.G3.03: Keep sprite on screen | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G3.01: Move a sprite with arrow keys (4 directions) | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G3.11: Create collectible items | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G3.08: Trigger Game Over | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G3.08: Trigger Game Over | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G3.08: Trigger Game Over | * T14.G3.04: Detect touching a goal | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G3.01: Move a sprite with arrow keys (4 directions) | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G3.08: Trigger Game Over | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G3.01: Move a sprite with arrow keys (4 directions) | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G3.08: Trigger Game Over | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G3.08: Trigger Game Over | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G3.10: Visual effects on interaction | * T14.G4.07: Create a Lives variable | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T14.G4.01: Spawn a projectile | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.07: Create a Lives variable | * T14.G5.01: Configure gravity and weight parameters | * T06.G3.02: Build a key‑press script that controls a sprite | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.03: Clean up projectiles | * T14.G5.01: Configure gravity and weight parameters | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.10: Switch backdrops for levels | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.10: Switch backdrops for levels | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.10: Switch backdrops for levels | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.10: Switch backdrops for levels | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.08: Create a Timer | * T14.G4.02: Move a projectile | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.06: Create a Score variable | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.12: Temporary power-ups | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G4.13: Pause and resume the game | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G5.03: Fix ground collisions | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G5.06: Pin HUD to the screen | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G5.04: Script viewport pans | * T14.G5.05: Lock viewport to the player | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G5.04: Script viewport pans | * T14.G5.05: Lock viewport to the player | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T14.G6.01: Character state machine | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G6.04: Stream level chunks with viewport reporters | * T07.G6.05: Fix a loop that runs too many or too few times | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T14.G6.01: Character state machine | * T07.G6.05: Fix a loop that runs too many or too few times | * T08.G5.01: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T10.G5.01: Store and retrieve named data with a list | * T07.G5.01: Loop over a list or range | * T08.G5.01: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G5.08: Timed waves | * T14.G4.01: Spawn a projectile | * T14.G4.03: Clean up projectiles | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T12.G5.01: Explain code changes to a peer | * T10.G5.01: Store and retrieve named data with a list | * T14.G4.09: Detect level complete | * T14.G4.10: Switch backdrops for levels | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T14.G7.01: Spatial partitioning (grid) | * T06.G6.01: Trace event execution paths in a multi‑event program | * T07.G6.01: Trace nested loops with variable bounds | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T14.G7.04: Monitor clone performance | * T07.G6.01: Trace nested loops with variable bounds | * T08.G6.01: Use conditionals to control simulation steps | * T14.G6.01: Character state machine | * T06.G6.01: Trace event execution paths in a multi‑event program | * T07.G6.01: Trace nested loops with variable bounds | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T14.G7.05: Difficulty curves | * T06.G6.01: Trace event execution paths in a multi‑event program | * T07.G6.01: Trace nested loops with variable bounds | * T08.G6.01: Use conditionals to control simulation steps | * T14.G7.03: Balanced enemy spawning | * T07.G6.01: Trace nested loops with variable bounds | * T08.G6.01: Use conditionals to control simulation steps | * T01.GK.01: Put pictures in order for getting ready for bed | * T03.GK.02: Match parts to whole objects | * T01.GK.02: Put pictures in order for coming to class | * T01.GK.02: Put pictures in order for coming to class | * T01.G1.01: Put pictures in order to plant a seed | * T01.G1.10: Match pictures to ""if/then"" rules | * T01.G1.04: Predict the next step in a story sequence | * T01.G1.07: Decide if two algorithms finish with the same result | * T15.G2.01: Fast vs. Slow animation | * T15.G3.00.01: Understand sprite appearance | * T15.G3.00.02: Change sprite size | * T15.G3.00.03: Draw on sprite costumes | * T01.G3.01: Complete a simple script with missing blocks | * T15.G3.01: Change sprite position | * T01.G3.05: Replace repeated blocks with a repeat loop | * T15.G3.02: Simple size animation | * T01.G3.10: Trace a script with a single if/then | * T15.G3.01: Change sprite position | * T01.G3.01: Complete a simple script with missing blocks | * T15.G3.04: Say something | * T15.G3.05: Think bubble | * T15.G3.04: Say something | * T15.G3.04: Say something | * T15.G3.06: Sequence dialogue | * T06.G3.01: Build a green-flag script that runs a 3-5 block sequence | * T15.G3.08: Click to talk | * T15.G3.04: Say something | * T15.G3.10: Enhanced say with styling | * T15.G3.11: Display labels for titles | * T15.G3.02: Simple size animation | * T07.G3.05: Fix a simple repeat loop count | * T15.G4.01: Animate with size changes | * T15.G2.02: Identify scene transitions | * T15.G4.02: Scene management with broadcasts | * T15.G4.03: Hide and Show characters | * T15.G3.04: Say something | * T15.G4.04: Create text input widget | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T15.G4.05: Read widget value into variable | * T08.G3.01: Use a simple if in a script | * T15.G4.06: Simple branching with buttons | * T15.G3.07: Wait between actions | * T15.G4.07: Coordinate two sprites (Wait) | * T06.G3.01: Build a green-flag script that runs a 3-5 block sequence | * T15.G4.08: Parallel actions | * T06.G3.09: Fix a behavior that runs at the wrong time | * T15.G5.01: Coordinate scene changes with broadcasts | * T15.G5.02: Broadcast specific actions | * T07.G3.05: Fix a simple repeat loop count | * T15.G5.01: Coordinate scene changes with broadcasts | * T15.G4.05: Read widget value into variable | * T15.G5.05: Join text strings | * T07.G3.01: Use a counted repeat loop | * T15.G4.06: Simple branching with buttons | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T15.G5.07: Track story choices | * T08.G3.01: Use a simple if in a script | * T15.G3.00.03: Draw on sprite costumes | * T15.G5.01: Coordinate scene changes with broadcasts | * T15.G5.09: Draw shapes on costumes | * T15.G5.08: Conditional endings | * T09.G4.01: Use variables to track multiple states simultaneously | * T15.G6.01: Animation state machine | * T10.G4.01: Use lists for dynamic data storage | * T15.G6.02: List-based Dialogue | * T11.G4.01: Define and call a simple custom block (no parameters) | * T15.G5.10: Draw text on costumes | * T09.G5.01: Use variables to store and display text strings | * T15.G6.04: Multiple language narration | * T15.G6.03: Cutscene controller | * T15.G5.01: Coordinate scene changes with broadcasts | * T15.G6.01: Animation state machine | * T15.G6.02: List-based Dialogue | * T15.G7.03: Dialogue system with speaker tags | * T10.G6.01: Use nested lists or tables for structured data | * T15.G8.01: Design story node data structure | * T15.G8.01.01: Display choices from story node | * T15.G7.03: Dialogue system with speaker tags | * T16.G7.03: Design an accessible interface for users with different abilities | * T15.G8.01.02: Navigate story nodes by choice | * T09.G6.01: Model real-world quantities using variables and formulas | * T15.G8.03: Encode story state for saving | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T01.G3.01: Complete a simple script with missing blocks | * T16.G3.01: Add a button widget to the stage | * T06.G3.02: Build a key‑press script that controls a sprite | * T16.G3.01: Add a button widget to the stage | * T16.G3.03: Add a label widget to display text | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T16.G3.03: Add a label widget to display text | * T16.G3.05: Add a textbox widget for user input | * T09.G3.02: Use a variable in a conditional (if block) | * T16.G3.02: Handle a button click event | * T08.G3.01: Use a simple if in a script | * T16.G3.07: Show and hide widgets | * T16.G3.08: Position and resize widgets | * T06.G3.09: Fix a behavior that runs at the wrong time | * T16.G4.01: Style widget text properties | * T16.G4.01: Style widget text properties | * T16.G3.08: Position and resize widgets | * T16.G4.02: Style widget appearance | * T10.G3.01: Loop through and process each item in a list | * T16.G4.03: Add a dropdown menu widget | * T08.G3.04: Trace code with a single if/else | * T16.G4.02: Style widget appearance | * T16.G4.05: Add a slider widget for numeric input | * T09.G3.05: Trace code with variables to predict outcomes | * T16.G4.02: Style widget appearance | * T08.G3.04: Trace code with a single if/else | * T16.G4.07: Add checkbox and radio button widgets | * T16.G3.07: Show and hide widgets | * T16.G4.07: Add checkbox and radio button widgets | * T16.G4.06: Read and respond to slider value changes | * T16.G4.08: Build a simple settings panel | * T08.G4.01: Use nested conditions (if within if) | * T16.G4.02: Style widget appearance | * T16.G3.02: Handle a button click event | * T16.G3.01: Add a button widget to the stage | * T16.G4.02: Style widget appearance | * T16.G4.08: Build a simple settings panel | * T09.G3.05: Trace code with variables to predict outcomes | * T16.G4.07: Add checkbox and radio button widgets | * T08.G3.05: Fix a condition that uses the wrong operator | * T16.G5.02: Design a form with multiple inputs and validation | * T16.G4.01: Style widget text properties | * T10.G3.01: Loop through and process each item in a list | * T09.G3.05: Trace code with variables to predict outcomes | * T16.G4.06: Read and respond to slider value changes | * T08.G3.05: Fix a condition that uses the wrong operator | * T09.G3.05: Trace code with variables to predict outcomes | * T16.G5.04: Implement a responsive HUD that reacts to game state | * T16.G3.04: Update label text dynamically | * T16.G5.04.01: Add and update a progress bar widget | * T16.G4.09: Respond to hover events on widgets | * T07.G4.03: Use ""repeat until"" to control animation duration | * T16.G5.01: Create a multi‑screen app with a navigation interface | * T16.G4.09: Respond to hover events on widgets | * T16.G5.05: Embed and control a video widget | * T06.G4.03: Use broadcast and ""when I receive"" for communication | * T16.G3.05: Add a textbox widget for user input | * T16.G4.01: Style widget text properties | * T16.G5.06: Add a rich textbox for formatted content | * T16.G4.08: Build a simple settings panel | * T16.G4.02.01: Add an image widget to the stage | * T16.G4.06: Read and respond to slider value changes | * T16.G5.03: Build a leaderboard or high‑score display | * T16.G6.01: Evaluate an interface for usability | * T16.G5.03: Build a leaderboard or high‑score display | * T16.G4.02: Style widget appearance | * T16.G6.03: Use color and contrast to improve readability | * T16.G3.07: Show and hide widgets | * T16.G6.03: Use color and contrast to improve readability | * T08.G4.03: Trace nested conditions to predict outcomes | * T16.G5.01: Create a multi‑screen app with a navigation interface | * T16.G4.01: Style widget text properties | * T16.G3.08: Position and resize widgets | * T16.G5.05: Embed and control a video widget | * T16.G4.02.01: Add an image widget to the stage | * T16.G5.01: Create a multi‑screen app with a navigation interface | * T16.G4.03: Add a dropdown menu widget | * T16.G6.03: Use color and contrast to improve readability | * T16.G5.02: Design a form with multiple inputs and validation | * T16.G6.04: Create an interface that works on different screen sizes | * T16.G5.02: Design a form with multiple inputs and validation | * T16.G6.03: Use color and contrast to improve readability | * T16.G6.04: Create an interface that works on different screen sizes | * T16.G6.04: Create an interface that works on different screen sizes | * T16.G5.01: Create a multi‑screen app with a navigation interface | * T16.G5.03: Build a leaderboard or high‑score display | * T10.G5.01: Search and sort a list | * T16.G7.04: Create a help or tutorial interface | * T16.G7.03: Design an accessible interface for users with different abilities | * T09.G6.01: Model real-world quantities using variables and formulas | * T16.G7.02: Implement a search or filter interface | * T16.G7.01: Build a data collection interface (survey or questionnaire) | * T09.G6.01: Model real-world quantities using variables and formulas | * T16.G7.03: Design an accessible interface for users with different abilities | * T16.G6.02: Design an interface based on user feedback | * T16.G8.03: Analyze UI design patterns and their effectiveness | * T16.G6.02: Design an interface based on user feedback | * T17.K.01: Observe sprite position changes (picture-based) | * T17.K.02: Match sprite to position after motion (picture-based) | * T17.G1.01: Identify fast vs slow motion (picture-based) | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T17.G2.01: Predict sprite direction from motion blocks (picture choices) | * T17.G3.01: Observe position changes from motion blocks | * T07.G3.01: Use a counted repeat loop | * T17.G3.02: Predict direction and distance of sprite motion | * T09.G3.05: Trace code with variables to predict outcomes | * T17.G4.01: Simulate falling with repeated motion | * T07.G3.05: Fix a simple repeat loop count | * T09.G3.05: Trace code with variables to predict outcomes | * T17.G4.02: Explain speed as position change over time | * T09.G4.03: Use multiple variables in a single script | * T17.G5.02: Track gravity with velocity variables | * T08.G3.01: Use a simple if in a script | * T17.G5.02: Track gravity with velocity variables | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T17.G4.02: Explain speed as position change over time | * T17.G5.05: Initialize a 2D physics world | * T17.G5.06: Attach a dynamic body to a sprite | * T17.G5.06.A: Practice creating multiple dynamic bodies | * T17.G5.06.01: Select basic body shapes (Box, Circle, Capsule) | * T17.G5.06.01: Select basic body shapes (Box, Circle, Capsule) | * T17.G5.05: Initialize a 2D physics world | * T06.G4.01: Use multiple event handlers in the same sprite | * T17.G5.06: Attach a dynamic body to a sprite | * T17.G5.08: Apply an impulse to jump or push | * T17.G5.08.01: Distinguish forces from impulses | * T17.G5.06: Attach a dynamic body to a sprite | * T09.G3.05: Trace code with variables to predict outcomes | * T17.G5.06: Attach a dynamic body to a sprite | * T17.G5.06: Attach a dynamic body to a sprite | * T17.G5.06: Attach a dynamic body to a sprite | * T17.G5.07: Build fixed boundaries for floors and walls | * T05.G4.05: Plan a simulation with defined inputs and outputs | * T17.G5.04: Code a manual bounce with energy loss | * T17.G5.11: Debug missing physics setup | * T08.G3.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T17.G5.10: Trace simple 2D physics motion | * T09.G3.05: Trace code with variables to predict outcomes | * T17.G6.01: Configure surface friction parameters | * T17.G5.06: Attach a dynamic body to a sprite | * T17.G5.08: Apply an impulse to jump or push | * T17.G6.02.01: Set velocity directly for physics bodies | * T17.G5.06: Attach a dynamic body to a sprite | * T17.G6.02.01: Set velocity directly for physics bodies | * T07.G3.05: Fix a simple repeat loop count | * T17.G6.02.02: Compare dynamic vs movable body types | * T06.G4.01: Use multiple event handlers in the same sprite | * T17.G5.10: Trace simple 2D physics motion | * T17.G6.04: Detect collisions for scoring or triggers | * T17.G6.04: Detect collisions for scoring or triggers | * T17.G6.04: Detect collisions for scoring or triggers | * T08.G4.01: Write a condition that uses and/or | * T17.G6.04.03: Identify collision management needs | * T17.G6.05: Use collision groups to filter interactions | * T17.G5.10: Trace simple 2D physics motion | * T17.G5.11: Debug missing physics setup | * T17.G5.06: Attach a dynamic body to a sprite | * T17.G6.01: Configure surface friction parameters | * T17.G6.02: Control restitution (bounce) parameters | * T17.G5.05: Initialize a 2D physics world | * T17.G6.01: Configure surface friction parameters | * T08.G3.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T17.G5.10: Trace simple 2D physics motion | * T08.G5.01: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T17.G6.08: Compare simulations to real-world motion | * T17.G7.01: Launch a configurable projectile | * T17.G5.08.01: Distinguish forces from impulses | * T17.G6.07: Debug unstable physics behavior | * T17.G6.08: Compare simulations to real-world motion | * T17.G7.02: Combine multiple forces simultaneously | * T17.G5.08.02: Apply impulse at a position for rotation | * T17.G7.02: Combine multiple forces simultaneously | * T17.G6.07: Debug unstable physics behavior | * T17.G6.08: Compare simulations to real-world motion | * T17.G7.03: Simulate drag with manual force calculations | * T17.G6.07: Debug unstable physics behavior | * T17.G6.08: Compare simulations to real-world motion | * T17.G7.04: Build chains or stacks of physics objects | * T17.G6.07: Debug unstable physics behavior | * T17.G6.08: Compare simulations to real-world motion | * T10.G5.01: Add and remove items from a list | * T17.G7.05: Read velocity and mass reporters | * T08.G5.01: Fix a condition that uses the wrong operator | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T17.G6.08: Compare simulations to real-world motion | * T17.G6.07: Debug unstable physics behavior | * T17.G6.08: Compare simulations to real-world motion | * T07.G6.01: Trace nested loops with variable bounds | * T08.G6.01: Use conditionals to control simulation steps | * T17.G7.06: Model a real-world physics scenario | * T09.G6.01: Model real-world quantities using variables and formulas | * T17.G7.06: Model a real-world physics scenario | * T17.G8.02: Implement fixed joints for connected objects | * T17.G8.02.01: Implement revolute joints for hinges | * T08.G6.01: Use conditionals to control simulation steps | * T17.G7.07: Evaluate whether a simulation meets requirements | * T07.G6.01: Trace nested loops with variable bounds | * T17.G7.06: Model a real-world physics scenario | * T17.G7.07: Evaluate whether a simulation meets requirements | * T17.G8.04: Optimize a physics scene for performance | * T17.G7.06: Model a real-world physics scenario | * T09.G6.01: Model real-world quantities using variables and formulas | * T17.G7.06: Model a real-world physics scenario | * T18.GK.01: Explore 3D shapes in the real world | * T18.G1.01: Match 3D shapes to their names | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T03.G2.01: Choose subtasks for a simple project idea | * T18.G3.01: Interpret 3D axis directions | * T18.G3.02: Match camera views to 3D layouts | * T07.G3.02: Trace a script with a simple loop | * T03.G3.03: Create a 3‑panel storyboard for a project | * T18.G3.03: Initialize a 3D scene with default lighting | * T18.G3.04: Add primitive shapes with 3D blocks | * T18.G3.04: Add primitive shapes with 3D blocks | * T18.G3.05: Position shapes using x/y/z coordinates | * T07.G3.03: Build a forever loop for simple animation | * T18.G3.06: Change shape colors or textures | * T18.G3.07: Move a 3D player with keyboard input | * T07.G3.04: Use repeat‑until to reach a simple goal | * T18.G3.08: Trace a short 3D script to predict positions | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T18.G4.01: Compose a multi-part 3D scene with primitives | * T18.G4.02: Configure ambient and directional lighting | * T18.G4.02: Configure ambient and directional lighting | * T18.G4.01: Compose a multi-part 3D scene with primitives | * T18.G3.07: Move a 3D player with keyboard input | * T18.G4.01: Compose a multi-part 3D scene with primitives | * T18.G4.04: Place imported or premade 3D models | * T18.G4.01: Compose a multi-part 3D scene with primitives | * T18.G4.04: Place imported or premade 3D models | * T07.G3.01: Use a counted repeat loop | * T18.G3.07: Move a 3D player with keyboard input | * T08.G3.01: Use a simple if in a script | * T18.G4.05.01: Use distance sensors to detect obstacles | * T18.G4.05.02: Understand collision detection types (raycast vs overlap vs physics) | * T18.G3.07: Move a 3D player with keyboard input | * T18.G4.04: Place imported or premade 3D models | * T18.G4.07: Control model animations | * T18.G4.01: Compose a multi-part 3D scene with primitives | * T18.G4.01: Compose a multi-part 3D scene with primitives | * T18.G5.01: Initialize a 3D physics world | * T18.G4.01: Compose a multi-part 3D scene with primitives | * T18.G5.02.01: Pick 3D objects with mouse or touch | * T18.G5.02: Attach static and dynamic physics bodies | * T18.G4.01: Compose a multi-part 3D scene with primitives | * T18.G5.04: Use nested loops to arrange 3D objects in grids | * T18.G5.04.01: Use copy by matrix for object arrays | * T18.G3.06: Change shape colors or textures | * T18.G4.03: Create a following or orbiting camera | * T18.G3.03: Initialize a 3D scene with default lighting | * T18.G4.02.02: Add point lights to illuminate objects | * T18.G5.02: Attach static and dynamic physics bodies | * T18.G3.03: Initialize a 3D scene with default lighting | * T18.G4.01: Compose a multi-part 3D scene with primitives | * T18.G5.02: Attach static and dynamic physics bodies | * T18.G5.03: Detect physics collisions to collect items | * T18.G3.07: Move a 3D player with keyboard input | * T18.G5.03: Detect physics collisions to collect items | * T18.G5.08: Apply forces and impulses to physics bodies | * T18.G5.04: Use nested loops to arrange 3D objects in grids | * T18.G5.04: Use nested loops to arrange 3D objects in grids | * T11.G4.01: Create a custom block with inputs | * T18.G4.03: Create a following or orbiting camera | * T09.G4.01: Capture user text or number input into a variable | * T18.G5.07: Add particle emitters for visual effects | * T08.G4.01: Use if‑else or else‑if chains | * T18.G5.08: Apply forces and impulses to physics bodies | * T18.G6.01: Set up collision groups for selective interaction | * T18.G5.04: Use nested loops to arrange 3D objects in grids | * T10.G5.01: Use a list to store multiple values | * T18.G6.06: Use constraints to connect physics bodies | * T18.G5.08: Apply forces and impulses to physics bodies | * T18.G7.01: Implement waypoint-based NPC movement | * T09.G5.02: Use arithmetic expressions with multiple operations | * T18.G7.02: Design collision response for bouncing or sliding | * T18.G6.06: Use constraints to connect physics bodies | * T18.G5.09: Adjust camera distance and angles dynamically | * T10.G5.01: Use a list to store multiple values | * T18.G4.07.01: Add and control avatar animations | * T08.G5.01: Use if‑else to handle two cases | * T18.G7.04: Implement a physics-based puzzle mechanic | * T10.G6.02: Use 2D lists (lists of lists) | * T18.G7.05: Script camera transitions for cutscenes | * T18.G8.01: Load level layouts from list data | * T18.G8.01: Load level layouts from list data | * T18.G6.05: Trigger advanced visual effects on events | * T18.G8.03: Analyze and optimize a 3D game for performance | * T18.G7.04: Implement a physics-based puzzle mechanic | * T18.G7.02: Design collision response for bouncing or sliding | * T18.G6.06: Use constraints to connect physics bodies | * T06.G4.01: Use broadcast to coordinate sprite actions | * T08.G4.01: Use conditionals with multiple outcomes | * T14.G5.01: Detect when sprites touch or overlap | * T19.G5.01: Create a local 2-player game on one keyboard | * T06.G3.09: Fix a behavior that runs at the wrong time | * T09.G3.05: Trace code with variables to predict outcomes | * T19.G6.00A: Understand what ""multiplayer"" means in CreatiCode games | * T19.G6.00B: Understand the host-client model and game rooms in multiplayer games | * T19.G6.00B: Understand the host-client model in multiplayer games | * T19.G6.00B: Understand the host-client model in multiplayer games | * T14.G5.01: Detect when sprites touch or overlap | * T19.G6.00C: Understand sprite replication in multiplayer games | * T19.G6.00F: Understand what ""synchronization"" means in multiplayer games | * T19.G6.00B: Understand the host-client model in multiplayer games | * T08.G3.01: Use a simple if in a script | * T19.G6.01A: Create a simple multiplayer game room | * T19.G6.00B: Understand the host-client model and game rooms in multiplayer games | * T19.G6.00B: Understand the host-client model and game rooms in multiplayer games | * T10.G4.01: Find an item's position in a list (linear search) | * T19.G6.01B: Join a multiplayer game room | * T10.G4.01: Find an item's position in a list (linear search) | * T19.G6.01B: Join a multiplayer game room | * T08.G3.01: Use a simple if in a script | * T19.G6.01B: Join a multiplayer game room | * T19.G6.00C: Understand sprite replication in multiplayer games | * T19.G6.00D: Understand Dynamic vs Static sprites in multiplayer games | * T19.G6.00E: Understand collision shapes (Rectangle vs Circle) in multiplayer games | * T19.G6.01B: Join a multiplayer game room | * T19.G6.02B: Register sprites with the game server | * T19.G6.01G: Test a multiplayer game with two browser windows | * T19.G6.02B: Register sprites with the game server | * T19.G6.02C: Initialize sprites when they join using ""when added to game"" | * T19.G6.05: Synchronize player movement using synchronized speed blocks | * T19.G6.03A: Create a simple collaborative or competitive 2-player game | * T19.G6.06: Configure stop vs pass collision behavior | * T19.G6.07: Handle multiplayer collisions with triggered messages | * T19.G6.00C: Understand sprite replication in multiplayer games | * T06.G4.01: Use broadcast to coordinate sprite actions | * T19.G6.04A: Choose between ""All Sprites"" and ""Exclude Replicate"" broadcast modes | * T11.G5.01: Create a custom block with inputs | * T19.G6.00F: Understand what ""synchronization"" means in multiplayer games | * T19.G6.02C: Initialize sprites when they join using ""when added to game"" | * T19.G6.01F: Check connection status and display feedback | * T14.G4.01: Compare position, velocity, and acceleration | * T19.G6.02B: Register sprites with the game server | * T14.G5.01: Detect when sprites touch or overlap | * T19.G6.05: Synchronize player movement using synchronized speed blocks | * T19.G6.06: Configure stop vs pass collision behavior | * T19.G6.02B: Register sprites with the game server | * T19.G6.04B: Broadcast multiplayer messages with parameters | * T19.G6.04B: Broadcast multiplayer messages with parameters | * T09.G3.01: Create and use a simple variable | * T19.G6.02C: Initialize sprites when they join using ""when added to game"" | * T19.G6.01E: List players in a game room | * T19.G6.04B: Broadcast multiplayer messages with parameters | * T19.G6.02B: Register sprites with the game server | * T19.G6.07: Handle multiplayer collisions with triggered messages | * T19.G6.08: Create shared world objects that stay synchronized | * T19.G6.04B: Broadcast multiplayer messages with parameters | * T19.G6.01E: List players in a game room | * T08.G4.01: Use conditionals with multiple outcomes | * T19.G6.00G: Understand what lag and latency mean in multiplayer games | * T19.G6.08: Create shared world objects that stay synchronized | * T19.G6.09: Display a synchronized scoreboard for multiplayer sessions | * T19.G6.10: Handle player join and leave events | * T19.G6.04B: Broadcast multiplayer messages with parameters | * T19.G6.05: Synchronize player movement using synchronized speed blocks | * T19.G6.04B: Broadcast multiplayer messages with parameters | * T19.G6.10: Handle player join and leave events | * T07.G5.01: Use a loop to repeat a task an exact number of times | * T19.G6.09: Display a synchronized scoreboard for multiplayer sessions | * T19.G6.10: Handle player join and leave events | * T19.G6.01A: Create a simple multiplayer game room | * T19.G6.01G: Test a multiplayer game with two browser windows | * T19.G6.05: Synchronize player movement using synchronized speed blocks | * T13.G6.01: Trace complex code with multiple variables | * T19.G7.04: Scale game logic to handle variable player counts | * T19.G7.00A: Use roles to identify player types | * T07.G6.01: Trace nested loops with variable bounds | * T19.G7.03: Choose what data to synchronize versus keep local | * T19.G7.04: Scale game logic to handle variable player counts | * T08.G6.01: Use conditionals to control simulation steps | * T19.G6.09: Display a synchronized scoreboard for multiplayer sessions | * T09.G6.01: Model real-world quantities using variables and formulas | * T19.G7.07: Debug why sprites aren't synchronizing | * T19.G7.03: Choose what data to synchronize versus keep local | * T06.G6.01: Trace event execution paths in a multi‑event program | * T13.G6.01: Trace complex code with multiple variables | * T19.G7.03: Choose what data to synchronize versus keep local | * T19.G7.04: Scale game logic to handle variable player counts | * T02.G6.01: Design a flowchart for a simple guessing game | * T06.G6.01: Trace event execution paths in a multi‑event program | * T19.G6.01B: Join a multiplayer game room | * T19.G6.04B: Broadcast multiplayer messages with parameters | * T19.G6.00D: Understand Dynamic vs Static sprites in multiplayer games | * T19.G7.03: Choose what data to synchronize versus keep local | * T19.G6.04B: Broadcast multiplayer messages with parameters | * T19.G8.07: Optimize network traffic in multiplayer games | * T09.G6.01: Model real-world quantities using variables and formulas | * T04.GK.01: Identify a simple repeating pattern | * T01.GK.01: Put pictures in order for getting ready for bed | * T04.GK.01: Identify a simple repeating pattern | * T04.GK.01: Identify a simple repeating pattern | * T01.GK.01: Put pictures in order for getting ready for bed | * T03.GK.02: Match parts to whole objects | * T01.GK.01: Put pictures in order for getting ready for bed | * T01.GK.01: Put pictures in order for getting ready for bed | * T01.G1.04: Predict the next step in a story sequence | * T05.G1.01: Identify what a character needs in a story | * T01.G1.04: Predict the next step in a story sequence | * T20.G2.01: Use repeat cards in an art recipe | * T01.G2.02: Use ""repeat"" to make directions shorter | * T01.G1.04: Predict the next step in a story sequence | * T20.G2.03: Build layered pattern recipes | * T07.G3.01: Use a counted repeat loop | * T20.G2.01: Use repeat cards in an art recipe | * T20.G3.01: Translate art recipe cards into blocks | * T08.G3.01: Use a simple if in a script | * T20.G3.02: Program a repeating border with loops | * T07.G3.01: Use a counted repeat loop | * T20.G3.03: Trace a pen loop and predict output | * T07.G3.01: Use a counted repeat loop | * T20.G3.04: Tile a grid with nested loops | * T09.G3.02: Use a variable in a conditional (if block) | * T07.G3.03: Build a forever loop for simple animation | * T20.G3.05: Add simple randomness for variety | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T07.G3.01: Use a counted repeat loop | * T07.G3.05: Fix a simple repeat loop count | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T20.G3.05.01: Use variables to change pattern size | * T07.G3.01: Use a counted repeat loop | * T07.G3.05: Fix a simple repeat loop count | * T11.G4.01: Create a custom block with inputs | * T20.G3.05: Add simple randomness for variety | * T07.G3.05: Fix a simple repeat loop count | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T20.G4.01: Implement incremental loops for spirals | * T09.G3.02: Use a variable in a conditional (if block) | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T20.G3.05: Add simple randomness for variety | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T07.G3.05: Fix a simple repeat loop count | * T08.G3.01: Use a simple if in a script | * T20.G3.05: Add simple randomness for variety | * T10.G4.01: Create a list and add items through code | * T10.G4.02: Use a loop to iterate through a list | * T20.G4.01: Implement incremental loops for spirals | * T07.G3.05: Fix a simple repeat loop count | * T10.G4.01: Create a list and add items through code | * T10.G4.02: Use a loop to iterate through a list | * T20.G4.05.01: Map list values to drawing positions | * T20.G5.01: Implement simple data-driven visualization | * T10.G5.01: Use nested lists to represent structured data | * T07.G3.05: Fix a simple repeat loop count | * T20.G4.01: Implement incremental loops for spirals | * T07.G3.05: Fix a simple repeat loop count | * T20.G4.05: Recolor art with simple input events | * T07.G3.05: Fix a simple repeat loop count | * T20.G4.02: Implement tessellation with custom blocks | * T20.G4.01: Implement incremental loops for spirals | * T20.G5.02: Animate a pattern with a counter variable | * T07.G3.05: Fix a simple repeat loop count | * T20.G5.01: Implement simple data-driven visualization | * T07.G5.01: Use a counted repeat loop | * T09.G5.01: Model a character trait or game stat with a variable | * T20.G5.04: Create fractal-like nested patterns | * T07.G5.01: Use a counted repeat loop | * T11.G5.01: Identify repeated code that could become a custom block | * T20.G5.04: Create fractal-like nested patterns | * T07.G5.01: Use a counted repeat loop | * T08.G5.01: Use a simple if in a script | * T09.G5.01: Model a character trait or game stat with a variable | * T20.G5.02: Animate a pattern with a counter variable | * T07.G5.01: Use a counted repeat loop | * T08.G5.01: Use a simple if in a script | * T10.G5.01: Use nested lists to represent structured data | * T20.G5.01: Implement simple data-driven visualization | * T07.G5.01: Use a counted repeat loop | * T09.G5.01: Model a character trait or game stat with a variable | * T20.G5.04: Create fractal-like nested patterns | * T20.G5.04.01: Create simple 3D artistic patterns | * T20.G6.05: Apply math transformations to art | * T20.G5.04.01: Create simple 3D artistic patterns | * T20.G6.05: Apply math transformations to art | * T20.G5.03: Make art respond to mouse or keys | * T20.G5.04.01: Create simple 3D artistic patterns | * T07.G6.05: Fix a loop that runs too many or too few times | * T08.G6.01: Use conditionals to control simulation steps | * T20.G6.01: Trace and explain an art algorithm | * T07.G6.05: Fix a loop that runs too many or too few times | * T08.G6.01: Use conditionals to control simulation steps | * T20.G6.02: Refactor repetitive art into loops/custom blocks | * T07.G6.05: Fix a loop that runs too many or too few times | * T09.G6.01: Model real-world quantities using variables and formulas | * T20.G6.03: Use variables and conditionals to branch designs | * T07.G6.05: Fix a loop that runs too many or too few times | * T20.G6.01: Trace and explain an art algorithm | * T20.G6.05: Apply math transformations to art | * T20.G6.03: Use variables and conditionals to branch designs | * T20.G7.03: Study parameter impact on aesthetics | * T07.G6.05: Fix a loop that runs too many or too few times | * T09.G6.01: Model real-world quantities using variables and formulas | * T20.G6.05: Apply math transformations to art | * T20.G5.04.01: Create simple 3D artistic patterns | * T20.G6.05: Apply math transformations to art | * T20.G7.03: Study parameter impact on aesthetics | * T20.G7.04.01: Create particle-based generative art | * T20.G5.04.01: Create simple 3D artistic patterns | * T20.G7.05.01: Create 3D generative sculptures with particle effects | * T20.G6.05.02: Create 3D curve and line art | * T10.G6.01: Sort a table by a column | * T06.G6.01: Trace event execution paths in a multi‑event program | * T07.G6.01: Trace nested loops with variable bounds | * T08.G6.01: Use conditionals to control simulation steps | * T10.G7.01: Implement algorithms using complex nested data structures | * T20.G6.04: Implement multi-field data visualization | * T20.G7.01: Compare efficiency of art algorithms | * T06.G6.01: Trace event execution paths in a multi‑event program | * T07.G6.01: Trace nested loops with variable bounds | * T09.G6.01: Model real-world quantities using variables and formulas | * T20.G7.04: Analyze real generative artworks | * T06.G6.01: Trace event execution paths in a multi‑event program | * T07.G6.01: Trace nested loops with variable bounds | * T09.G6.01: Model real-world quantities using variables and formulas | * T20.G7.04: Analyze real generative artworks | * T07.G6.01: Trace nested loops with variable bounds | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T20.G7.01: Compare efficiency of art algorithms | * T06.G6.01: Trace event execution paths in a multi‑event program | * T07.G6.01: Trace nested loops with variable bounds | * T09.G6.01: Model real-world quantities using variables and formulas | * T20.G7.05: Implement rule-based iterative art systems | * T20.G7.05.01: Create 3D generative sculptures with particle effects | * T20.G8.04: Optimize rendering for performance | * T21.GK.01: Tell which pictures look like AI made them | * T21.GK.02: Match the picture to the words that describe it | * T21.GK.03: Pick the helper that can talk back | * T21.G1.01: Choose words to tell the computer what to draw | * T21.G1.02: Decide if AI words are safe to share | * T21.G3.01: Tell whether media was AI-generated or recorded | * T21.G3.01: Tell whether media was AI-generated or recorded | * T21.G3.01: Tell whether media was AI-generated or recorded | * T21.G3.01: Tell whether media was AI-generated or recorded | * T21.G4.02: Describe AI media you've experienced | * T21.G4.01: Choose safe and specific prompts for images | * T21.G4.03: Identify strengths and limits of AI image generation | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T21.G4.01: Choose safe and specific prompts for images | * T21.G5.02: Generate a single AI image using a simple prompt | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T21.G3.01: Tell whether media was AI-generated or recorded | * T21.G3.01: Tell whether media was AI-generated or recorded | * T21.G4.01: Choose safe and specific prompts for images | * T21.G4.03: Identify strengths and limits of AI image generation | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T21.G5.06: Ask ChatGPT a simple question and display the response | * T21.G4.01: Choose safe and specific prompts for images | * T21.G5.01: Decide AI vs hand-made for a single asset type | * T21.G5.01: Decide AI vs hand-made for a single asset type | * T21.G5.02: Generate a single AI image using a simple prompt | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T10.G3.03: Add and remove items from a list | * T21.G5.02: Generate a single AI image using a simple prompt | * T10.G3.03: Add and remove items from a list | * T21.G5.02: Generate a single AI image using a simple prompt | * T06.G4.01: Use broadcast to coordinate sprite actions | * T21.G5.04: Understand how speech-to-text works | * T08.G4.01: Add else to handle the opposite case | * T21.G5.05: Explain why AI content needs safety review | * T21.G5.02: Generate a single AI image using a simple prompt | * T21.G6.06: Check user input with AI content moderation | * T21.G5.06: Ask ChatGPT a simple question and display the response | * T21.G5.07: Understand ChatGPT parameters (temperature and length) | * T21.G5.07: Understand ChatGPT parameters (temperature and length) | * T21.G5.06: Ask ChatGPT a simple question and display the response | * T06.G4.01: Use broadcast to coordinate sprite actions | * T10.G3.03: Add and remove items from a list | * T06.G4.01: Use broadcast to coordinate sprite actions | * T10.G4.01: Use a list to solve a problem with many similar items | * T07.G5.01: Use a counted repeat loop | * T09.G5.01: Use variables to make a program more general or clear | * T10.G5.03: Add and remove items from a list | * T21.G6.03: Build a prompt test bench inside CreatiCode | * T21.G6.04: Iterate when an AI output fails requirements | * T09.G5.01: Use variables to make a program more general or clear | * T10.G5.03: Add and remove items from a list | * T21.G6.04: Iterate when an AI output fails requirements | * T21.G6.08: Use ChatGPT to generate story text or dialogue | * T09.G5.01: Use variables to make a program more general or clear | * T10.G5.03: Add and remove items from a list | * T21.G6.03: Build a prompt test bench inside CreatiCode | * T21.G6.04: Iterate when an AI output fails requirements | * T06.G5.01: Fix a behavior that runs at the wrong time | * T08.G5.01: Use a simple if in a script | * T09.G5.01: Use variables to make a program more general or clear | * T10.G5.03: Add and remove items from a list | * T21.G6.04: Iterate when an AI output fails requirements | * T06.G5.01: Fix a behavior that runs at the wrong time | * T09.G5.01: Use variables to make a program more general or clear | * T10.G5.03: Add and remove items from a list | * T21.G5.03: Use AI text-to-speech to read text aloud | * T21.G6.04: Iterate when an AI output fails requirements | * T21.G6.08: Use ChatGPT to generate story text or dialogue | * T10.G5.03: Add and remove items from a list | * T21.G6.05: Use AI speech recognition to capture user voice input | * T21.G5.02: Generate a single AI image using a simple prompt | * T21.G6.08: Use ChatGPT to generate story text or dialogue | * T21.G7.07: Use ChatGPT vision to analyze images | * T21.G6.08: Use ChatGPT to generate story text or dialogue | * T21.G6.08: Use ChatGPT to generate story text or dialogue | * T21.G6.10: Use system instructions to guide ChatGPT behavior | * T08.G5.01: Use a simple if in a script | * T10.G5.03: Add and remove items from a list | * T21.G6.12: Track 2D body parts for gesture recognition | * T08.G5.01: Use a simple if in a script | * T09.G5.01: Use variables to make a program more general or clear | * T21.G6.12: Track 2D body parts for gesture recognition | * T08.G5.01: Use a simple if in a script | * T10.G5.03: Add and remove items from a list | * T21.G6.12: Track 2D body parts for gesture recognition | * T21.G4.03: Identify strengths and limits of AI image generation | * T21.G7.12: Understand what neural networks are and how they learn | * T21.G7.13: Design a neural network architecture | * T07.G5.01: Use a counted repeat loop | * T10.G5.03: Add and remove items from a list | * T21.G7.13a: Compile and configure a neural network | * T21.G7.13b: Train a neural network and observe learning | * T21.G7.13b: Train a neural network and observe learning | * T21.G7.14: Save and load trained neural network models | * T21.G7.12: Understand what neural networks are and how they learn | * T10.G5.03: Add and remove items from a list | * T21.G7.15: Understand K-Nearest Neighbors (KNN) classification | * T10.G5.03: Add and remove items from a list | * T21.G6.08: Use ChatGPT to generate story text or dialogue | * T06.G6.01: Trace event execution paths in a multi‑event program | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G6.06: Check user input with AI content moderation | * T21.G7.01: Create a reusable prompt template library | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G6.06: Check user input with AI content moderation | * T21.G7.01: Create a reusable prompt template library | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G7.02: Use ChatGPT to expand creative briefs before generating art | * T21.G7.05: Synchronize AI visuals with AI narration for a single scene | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G8.02: Implement an approval pipeline for AI assets | * T21.G7.06: Use continuous speech recognition for live dictation | * T21.G8.01: Build a user-facing generative art widget with guardrails | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G7.08: Manage multiple ChatGPT conversation threads | * T10.G6.01: Sort a table by a column | * T21.G6.08: Use ChatGPT to generate story text or dialogue | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T21.G7.09: Use hand detection for gesture-based controls | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G7.10: Build a pose-based interactive game | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G7.13b: Train a neural network and observe learning | * T21.G7.14: Save and load trained neural network models | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G7.13b: Train a neural network and observe learning | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G8.10: Build a neural network for number recognition | * T08.G6.01: Use conditionals to control simulation steps | * T10.G6.01: Sort a table by a column | * T21.G7.16: Create a KNN classifier from training data | * T10.G6.01: Sort a table by a column | * T21.G6.08: Use ChatGPT to generate story text or dialogue | * T10.G6.01: Sort a table by a column | * T21.G8.14: Create a semantic search database | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T21.G8.06: Build a multi-turn ChatGPT conversation system | * T21.G8.15: Search with semantic similarity | * T10.G6.01: Sort a table by a column | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T21.G8.07: Combine ChatGPT with web search for fact-checking | * T21.G8.17: Use web search to gather information | * T22.GK.01: Recognize a talking helper vs a silent toy | * T22.GK.02: Practice asking a picture helper a friendly question | * T22.G1.01: Sort good questions from confusing questions | * T22.G1.01: Sort good questions from confusing questions | * T22.G1.02: Identify what a chatbot might not know | * T22.G2.01: Role-play asking a helper for information | * T08.G3.01: Use a simple if in a script | * T22.G2.01: Role-play asking a helper for information | * T22.G2.02: Decide which questions are okay to ask a helper | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T06.G3.09: Fix a behavior that runs at the wrong time | * T09.G3.05: Trace code with variables to predict outcomes | * T22.G3.01: Identify chatbot behavior from fixed button replies | * T06.G3.09: Fix a behavior that runs at the wrong time | * T09.G3.05: Trace code with variables to predict outcomes | * T22.G3.01: Identify chatbot behavior from fixed button replies | * T22.G4.01: Write clear, polite questions for a helper bot | * T22.G5.01: Flag risky vs safe chatbot prompts | * T22.G4.01: Write clear, polite questions for a helper bot | * T22.G5.02: Observe chatbot strengths and weaknesses through testing | * T22.G5.1.5: Use a chatbot block to get AI responses | * T22.G5.02: Observe chatbot strengths and weaknesses through testing | * T09.G4.01: Build a simple string variable for name entry | * T22.G5.01: Flag risky vs safe chatbot prompts | * T22.G5.03: Experiment with prompt phrasing to improve responses | * T06.G4.01: Program multiple events to run independently | * T08.G4.01: Use nested conditions or multi-branch selection | * T09.G4.01: Build a simple string variable for name entry | * T09.G4.04: Trace multi-step expressions with parentheses | * T22.G5.01: Flag risky vs safe chatbot prompts | * T22.G5.04: Identify ChatGPT block parameters in starter code | * T06.G4.01: Program multiple events to run independently | * T08.G4.01: Use nested conditions or multi-branch selection | * T09.G4.04: Trace multi-step expressions with parentheses | * T22.G5.01: Flag risky vs safe chatbot prompts | * T22.G6.01: Trace how a chatbot script processes each turn | * T06.G4.01: Program multiple events to run independently | * T08.G4.01: Use nested conditions or multi-branch selection | * T09.G4.04: Trace multi-step expressions with parentheses | * T22.G5.01: Flag risky vs safe chatbot prompts | * T22.G6.01: Trace how a chatbot script processes each turn | * T16.G3.01: Add a button widget to the stage | * T16.G3.05: Add a textbox widget for user input | * T22.G5.1.5: Use a chatbot block to get AI responses | * T16.G3.03: Add a label widget to display text | * T22.G6.02: Adjust temperature for response creativity | * T22.G6.03: Handle streaming mode and long requests | * T22.G6.01: Trace how a chatbot script processes each turn | * T22.G6.02: Adjust temperature for response creativity | * T22.G6.03: Handle streaming mode and long requests | * T22.G6.02: Adjust temperature for response creativity | * T22.G6.03: Handle streaming mode and long requests | * T22.G6.06.01: Create and configure a pre-built chat window | * T22.G6.02: Adjust temperature for response creativity | * T22.G6.03: Handle streaming mode and long requests | * T22.G6.06.02: Manage chat messages with append and update blocks | * T22.G6.01: Trace how a chatbot script processes each turn | * T22.G6.02: Adjust temperature for response creativity | * T22.G6.03: Handle streaming mode and long requests | * T06.G4.08: Fix event timing issues in multi-event programs | * T08.G4.01: Use nested conditions or multi-branch selection | * T09.G4.04: Trace multi-step expressions with parentheses | * T22.G4.01: Write clear, polite questions for a helper bot | * T22.G5.01: Flag risky vs safe chatbot prompts | * T22.G6.01: Trace how a chatbot script processes each turn | * T22.G6.01: Trace how a chatbot script processes each turn | * T22.G6.04.02: Build a conversation log with dynamic updates | * T22.G6.02: Adjust temperature for response creativity | * T22.G6.03: Handle streaming mode and long requests | * T22.G6.07: Debug off-topic responses by rewriting prompts | * T22.G6.02: Adjust temperature for response creativity | * T22.G6.03: Handle streaming mode and long requests | * T22.G6.07: Debug off-topic responses by rewriting prompts | * T22.G7.01: Use system messages to set bot behavior | * T06.G5.01: Coordinate scripts across sprites using broadcasts | * T08.G5.01: Use conditionals with comparison operators | * T09.G5.04: Use variables to control animation timing | * T22.G6.04.02: Build a conversation log with dynamic updates | * T22.G6.07: Debug off-topic responses by rewriting prompts | * T22.G6.08: Use multiple chatbot sessions with the select chatbot block | * T22.G6.04.02: Build a conversation log with dynamic updates | * T22.G6.07: Debug off-topic responses by rewriting prompts | * T22.G7.02: Author a persona using system messages and few-shot turns | * T06.G5.01: Coordinate scripts across sprites using broadcasts | * T08.G5.01: Use conditionals with comparison operators | * T09.G5.04: Use variables to control animation timing | * T21.G6.06: Check user input with AI content moderation | * T22.G5.01: Flag risky vs safe chatbot prompts | * T22.G6.04.02: Build a conversation log with dynamic updates | * T22.G6.07: Debug off-topic responses by rewriting prompts | * T22.G6.04.02: Build a conversation log with dynamic updates | * T22.G6.07: Debug off-topic responses by rewriting prompts | * T22.G7.02: Author a persona using system messages and few-shot turns | * T22.G6.04.02: Build a conversation log with dynamic updates | * T22.G6.07: Debug off-topic responses by rewriting prompts | * T22.G7.02: Author a persona using system messages and few-shot turns | * T21.G6.07: Use image moderation to check visual content | * T22.G7.05: Add moderation guardrails and escalation paths | * T22.G7.06: Attach images and files to chatbot conversations | * T22.G6.02: Adjust temperature for response creativity | * T22.G7.01: Use system messages to set bot behavior | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T22.G7.02: Author a persona using system messages and few-shot turns | * T22.G7.03: Manage chat history and reset logic | * T22.G7.05: Add moderation guardrails and escalation paths | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T22.G6.08: Use multiple chatbot sessions with the select chatbot block | * T22.G7.02: Author a persona using system messages and few-shot turns | * T22.G7.03: Manage chat history and reset logic | * T22.G7.05: Add moderation guardrails and escalation paths | * T22.G7.09: User-test the chatbot for inclusivity and clarity | * T03.G6.01: Propose modules for a medium project | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T22.G7.02: Author a persona using system messages and few-shot turns | * T22.G7.05: Add moderation guardrails and escalation paths | * T06.G6.01: Trace event execution paths in a multi‑event program | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T22.G7.05: Add moderation guardrails and escalation paths | * T22.G7.09: User-test the chatbot for inclusivity and clarity | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T22.G7.02: Author a persona using system messages and few-shot turns | * T22.G7.05: Add moderation guardrails and escalation paths | * T22.G8.01: Add retrieval-augmented generation (RAG) to a chatbot | * T23.GK.01: Match pictures of sensing | * T23.GK.02: Point to where a device ""looks"" or ""listens"" | * T01.GK.03: Find the first and last pictures | * T23.GK.02: Point to where a device ""looks"" or ""listens"" | * T03.GK.02: Match parts to whole objects | * T23.GK.01: Match pictures of sensing | * T01.GK.04: Pick the pictures that make sense | * T23.G1.01: Find sensors on everyday devices | * T23.G1.03: Choose what a sensor can notice | * T23.G2.01: Pick the right sensor for a job | * T01.G1.01: Put pictures in order to plant a seed | * T07.G3.01: Use a counted repeat loop | * T23.G2.01: Pick the right sensor for a job | * T06.G3.05: Decide which event type to use for a behavior | * T23.G3.02: Describe sound as a wavy line of loud/soft | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.05: Fix a condition that uses the wrong operator | * T23.G3.01: Describe a picture as a grid of tiny colors | * T23.G2.02: Spot when sensor data might be unclear | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.05: Fix a condition that uses the wrong operator | * T23.G3.01: Describe a picture as a grid of tiny colors | * T23.G3.02: Describe sound as a wavy line of loud/soft | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G3.05: Fix a condition that uses the wrong operator | * T23.G3.01: Describe a picture as a grid of tiny colors | * T08.G3.05: Fix a condition that uses the wrong operator | * T23.G4.01: Trace how lighting changes pixel data | * T08.G3.05: Fix a condition that uses the wrong operator | * T23.G4.03: Identify noise and simple fixes | * T23.G3.03: Tell whether a behavior uses sensing and guessing | * T08.G3.05: Fix a condition that uses the wrong operator | * T23.G4.02: Choose a good setup for mic or camera | * T23.G3.03: Tell whether a behavior uses sensing and guessing | * T08.G3.05: Fix a condition that uses the wrong operator | * T23.G4.03: Identify noise and simple fixes | * T23.G3.03: Tell whether a behavior uses sensing and guessing | * T10.G5.04: Read a cell value from a table | * T23.G5.01: Compare what people see vs what pixels show | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G5.02: Explain why an AI might mis-hear or mis-see | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G6.01.01: Capture a single spoken phrase with basic speech recognition | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G6.01.02: Select speech recognition language and observe accuracy differences | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G5.02: Explain why an AI might mis-hear or mis-see | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G6.01.02: Select speech recognition language and observe accuracy differences | * T23.G4.02: Choose a good setup for mic or camera | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T22.G6.01: Trace how a chatbot script processes each turn | * T23.G6.01.02: Select speech recognition language and observe accuracy differences | * T23.G6.02.01: Convert text to speech with basic settings | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T22.G6.01: Trace how a chatbot script processes each turn | * T23.G6.01.02: Select speech recognition language and observe accuracy differences | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G5.05: Identify what data hand, body, and face detection provides | * T10.G5.04: Read a cell value from a table | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G6.04.01: Set up hand detection and view debug output | * T10.G5.04: Read a cell value from a table | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G6.04.02: Read and display finger curl angles from hand detection | * T10.G5.04: Read a cell value from a table | * T08.G3.01: Use a simple if in a script | * T23.G6.04.02: Read and display finger curl angles from hand detection | * T08.G3.01: Use a simple if in a script | * T09.G5.05: Use the accumulator pattern to compute running totals | * T23.G4.03: Identify noise and simple fixes | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G5.03: Choose safe ways to handle sensor data | * T10.G5.04: Read a cell value from a table | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G6.04.02: Read and display finger curl angles from hand detection | * T23.G5.05: Identify what data hand, body, and face detection provides | * T10.G5.04: Read a cell value from a table | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G6.08.01: Set up 2D body pose detection and read keypoint positions | * T10.G5.04: Read a cell value from a table | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G5.05: Identify what data hand, body, and face detection provides | * T10.G5.04: Read a cell value from a table | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G6.09.01: Set up face detection and view detected faces | * T10.G5.04: Read a cell value from a table | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T23.G6.08.02: Detect body poses and trigger actions | * T23.G6.02: Map speech commands to UI widgets | * T23.G6.05: Drive UI elements with live hand detection | * T23.G6.08.02: Detect body poses and trigger actions | * T23.G5.02: Explain why an AI might mis-hear or mis-see | * T10.G5.04: Read a cell value from a table | * T11.G5.02: Define a custom block with one parameter | * T23.G6.05: Drive UI elements with live hand detection | * T09.G5.05: Use the accumulator pattern to compute running totals | * T23.G6.02: Map speech commands to UI widgets | * T23.G6.05: Drive UI elements with live hand detection | * T23.G6.10: Use 3D pose detection for depth-aware body tracking | * T23.G6.06: Smooth noisy sensor data and recover from dropouts | * T23.G6.06: Smooth noisy sensor data and recover from dropouts | * T23.G5.04: Identify when AI sensing might be unfair | * T23.G6.07: Add consent and privacy controls for sensor use | * T23.G5.04: Identify when AI sensing might be unfair | * T23.G6.06: Smooth noisy sensor data and recover from dropouts | * T23.G5.02: Explain why an AI might mis-hear or mis-see | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T23.G7.01: Define a reusable gesture dictionary | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T23.G7.02: Require multimodal confirmation (voice + gesture) | * T23.G6.02: Map speech commands to UI widgets | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T23.G8.00A: Understand supervised learning for perception classification | * T23.G7.01: Define a reusable gesture dictionary | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T23.G8.02: Train and deploy a custom gesture classifier | * T08.G6.01: Use conditionals to control simulation steps | * T23.G7.02: Require multimodal confirmation (voice + gesture) | * T23.G7.03: Score a pose-based challenge with coaching tips | * T23.G6.03A: Build a two-way voice chatbot loop | * T04.G6.01: Group snippets by underlying algorithm pattern | * T08.G6.01: Use conditionals to control simulation steps | * T23.G7.05: Implement fairness safeguards for perception systems | * T23.G6.07: Add consent and privacy controls for sensor use | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T23.G7.04: Monitor detection accuracy across different users | * T23.G7.05: Implement fairness safeguards for perception systems | * T24.GK.01: Identify AI as a computer helper | * T24.GK.01: Identify AI as a computer helper | * T24.GK.02: Recognize AI-made vs human-made pictures | * T24.GK.01: Identify AI as a computer helper | * T24.GK.01: Identify AI as a computer helper | * T24.GK.03: Give simple instructions to an AI helper | * T24.GK.03: Give simple instructions to an AI helper | * T24.G1.02: Compare AI answers to expected answers | * T24.G1.01: Listen to AI-generated speech | * T24.G1.03: Understand AI needs clear instructions | * T24.G1.02: Compare AI answers to expected answers | * T24.G1.03: Understand AI needs clear instructions | * T24.G2.02: Identify what AI can and cannot do | * T24.G1.01: Listen to AI-generated speech | * T24.G2.02: Identify what AI can and cannot do | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T24.G2.01: Use AI text-to-speech to narrate a story | * T24.G2.04: Observe how AI hears spoken words | * T24.G2.03: Describe what you want AI to create | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T24.G3.02: Evaluate if AI output matches the request | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T24.G2.02: Identify what AI can and cannot do | * T24.G3.02: Evaluate if AI output matches the request | * T08.G3.01: Use a simple if in a script | * T24.G3.03: Revise a prompt to improve AI results | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T24.G3.02: Evaluate if AI output matches the request | * T24.G4.01.01: Combine keywords for better AI image searches | * T24.G3.03: Revise a prompt to improve AI results | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T24.G3.04: Recognize AI makes mistakes | * T08.G3.01: Use a simple if in a script | * T24.G4.01: Search the AI image library with keywords | * T24.G4.03: Identify safe and unsafe AI interactions | * T24.G4.03: Identify safe and unsafe AI interactions | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T24.G4.02: Write a multi-part prompt for AI | * T24.G4.05: Understand content moderation in AI systems | * T24.G4.03: Identify safe and unsafe AI interactions | * T24.G4.06: Explore AI block categories in CreatiCode | * T24.G5.01: Read and interpret XO's interface cues | * T24.G5.01: Read and interpret XO's interface cues | * T24.G5.02: Ask XO for a three-step project plan | * T24.G4.01: Search the AI image library with keywords | * T24.G5.02: Ask XO for a three-step project plan | * T24.G4.03: Identify safe and unsafe AI interactions | * T24.G5.03: Turn an XO suggestion into starter code safely | * T06.G3.01: Build a green-flag script that runs a 3-5 block sequence | * T24.G4.02: Write a multi-part prompt for AI | * T24.G4.06: Explore AI block categories in CreatiCode | * T06.G3.01: Build a green-flag script that runs a 3-5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T24.G4.02: Write a multi-part prompt for AI | * T24.G4.06: Explore AI block categories in CreatiCode | * T06.G3.01: Build a green-flag script that runs a 3-5 block sequence | * T10.G3.03: Add and remove items from a list | * T24.G3.01: Use speech-to-text to control a sprite | * T24.G4.06: Explore AI block categories in CreatiCode | * T06.G4.01: Trace event execution paths in a multi-event program | * T09.G4.04: Trace code with variables to predict outcomes | * T24.G5.03: Turn an XO suggestion into starter code safely | * T24.G5.05: Reject unsafe or off-spec XO suggestions | * T06.G4.01: Trace event execution paths in a multi-event program | * T07.G4.01: Use a counted repeat loop | * T08.G4.01: Use if‑else or else‑if chains | * T09.G4.01: Create and use a numeric variable for score or count | * T24.G5.03: Turn an XO suggestion into starter code safely | * T24.G6.01: Provide complete context when asking XO to debug | * T06.G4.01: Trace event execution paths in a multi-event program | * T09.G4.04: Trace code with variables to predict outcomes | * T24.G5.05: Reject unsafe or off-spec XO suggestions | * T24.G6.02: Verify XO's explanation against the project | * T09.G4.04: Trace code with variables to predict outcomes | * T24.G5.04: Collect themed assets from narrative descriptions | * T24.G5.05: Reject unsafe or off-spec XO suggestions | * T24.G4.02: Write a multi-part prompt for AI | * T24.G5.04: Collect themed assets from narrative descriptions | * T06.G4.01: Trace event execution paths in a multi-event program | * T09.G4.01: Create and use a numeric variable for score or count | * T10.G4.03: Add and remove items from a list | * T24.G5.05: Reject unsafe or off-spec XO suggestions | * T24.G6.04: Iterate AI images using feedback from XO | * T08.G4.01: Use if‑else or else‑if chains | * T09.G4.04: Trace code with variables to predict outcomes | * T24.G5.05: Reject unsafe or off-spec XO suggestions | * T24.G6.05: Maintain a prompt/response lab notebook using lists | * T06.G4.01: Trace event execution paths in a multi-event program | * T08.G4.01: Use if‑else or else‑if chains | * T24.G4.05: Understand content moderation in AI systems | * T24.G5.07: Use the ChatGPT block to get AI responses in code | * T24.G5.07: Use the ChatGPT block to get AI responses in code | * T08.G4.01: Use if‑else or else‑if chains | * T07.G4.01: Use a counted repeat loop | * T08.G4.01: Use if‑else or else‑if chains | * T24.G6.08.01: Manage ChatGPT sessions explicitly | * T24.G6.05: Maintain a prompt/response lab notebook using lists | * T24.G6.04: Iterate AI images using feedback from XO | * T09.G4.01: Create and use a numeric variable for score or count | * T09.G5.01: Use arithmetic and comparison operators with variables | * T10.G5.03: Add and remove items from a list | * T24.G6.05: Maintain a prompt/response lab notebook using lists | * T24.G6.06: Label risky prompts and rewrite them safely | * T06.G5.01: Build a green‑flag script that runs a 3–5 block sequence | * T08.G5.01: Use if‑else to handle two cases | * T09.G5.04: Use arithmetic and comparison operators with variables | * T24.G6.06: Label risky prompts and rewrite them safely | * T24.G7.01: Create reusable XO prompt templates in lists | * T06.G5.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G5.04: Use arithmetic and comparison operators with variables | * T24.G6.04: Iterate AI images using feedback from XO | * T24.G6.05: Maintain a prompt/response lab notebook using lists | * T24.G7.01: Create reusable XO prompt templates in lists | * T08.G5.01: Use if‑else to handle two cases | * T10.G5.03: Add and remove items from a list | * T24.G6.05: Maintain a prompt/response lab notebook using lists | * T24.G6.06: Label risky prompts and rewrite them safely | * T24.G7.01: Create reusable XO prompt templates in lists | * T09.G5.01: Use arithmetic and comparison operators with variables | * T24.G6.06: Label risky prompts and rewrite them safely | * T24.G7.02: Run an XO-led code review with evidence | * T24.G7.04: Enforce responsible-use rules for XO assistance | * T24.G7.02: Run an XO-led code review with evidence | * T24.G7.05: Use XO to coach peers with rubric-based feedback | * T10.G5.03: Add and remove items from a list | * T06.G6.01: Trace event execution paths in a multi-event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T24.G7.01: Create reusable XO prompt templates in lists | * T24.G7.04: Enforce responsible-use rules for XO assistance | * T07.G6.01: Trace nested loops with variable bounds | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T24.G7.02: Run an XO-led code review with evidence | * T24.G8.01: Automate XO requests with data-driven prompt builders | * T06.G6.01: Trace event execution paths in a multi-event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T24.G7.03: Combine XO storyboards with AI sprite generation | * T24.G7.04: Enforce responsible-use rules for XO assistance | * T24.G8.01: Automate XO requests with data-driven prompt builders | * T06.G6.01: Trace event execution paths in a multi-event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T24.G7.04: Enforce responsible-use rules for XO assistance | * T24.G8.02: Pair XO with automated tests to validate fixes | * T24.G8.03: Compare XO-generated code/image options with human-crafted versions | * T01.G6.01: Count comparisons in linear and binary search | * T07.G6.01: Trace nested loops with variable bounds | * T09.G6.01: Model real-world quantities using variables and formulas | * T24.G7.05: Use XO to coach peers with rubric-based feedback | * T24.G8.04: Implement AI usage tracking and policy enforcement (Capstone) | * T25.GK.01: Spot data in everyday objects | * T25.GK.02: Match quantities to symbols | * T25.GK.02: Match quantities to symbols | * T25.G1.01: Record data with tally marks | * T25.G1.01: Record data with tally marks | * T01.G1.10: Match pictures to ""if/then"" rules | * T25.G1.02: Design a picture table | * T01.G1.01: Put pictures in order to plant a seed | * T25.G1.03: Describe the same fact in words and numbers | * T25.G1.02: Design a picture table | * T25.G2.02: Translate between timeline, table, and sentence | * T25.G1.02: Design a picture table | * T08.G3.01: Use a simple if in a script | * T25.G2.01: Choose labels for a category chart | * T25.G3.01: Map survey responses into list variables | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T08.G3.02: Decide when a single if is enough | * T25.G3.02: Choose the right variable type | * T08.G3.03: Pick the right conditional block for a scenario | * T10.G3.01: Loop through and process each item in a list | * T25.G3.03: Break sentences into structured records | * T09.G3.02: Use a variable in a conditional (if block) | * T07.G3.03: Build a forever loop for simple animation | * T25.G3.03: Break sentences into structured records | * T25.G3.04: Explain why consistent units matter | * T25.G3.02: Choose the right variable type | * T25.G2.04: Combine two data attributes | * T25.G3.02: Choose the right variable type | * T25.G2.04: Combine two data attributes | * T25.G3.01: Map survey responses into list variables | * T25.G2.02: Translate between timeline, table, and sentence | * T25.G3.02: Choose the right variable type | * T25.G2.03: Pick the best representation for a question | * T25.G3.02: Choose the right variable type | * T25.G2.01: Choose labels for a category chart | * T25.G3.02: Choose the right variable type | * T25.G4.01: Build schema diagrams for simple apps | * T25.G3.06: Create a simple table in CreatiCode | * T10.G3.01: Loop through and process each item in a list | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T25.G3.02: Choose the right variable type | * T25.G4.01: Build schema diagrams for simple apps | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T25.G3.01: Map survey responses into list variables | * T25.G3.04: Explain why consistent units matter | * T25.G3.05: Identify when data needs cleaning | * T25.G3.01: Map survey responses into list variables | * T25.G4.03: Compare dense vs sparse representations | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T25.G4.04: Document assumptions in a data key | * T25.G3.02: Choose the right variable type | * T25.G4.01: Build schema diagrams for simple apps | * T25.G3.02: Choose the right variable type | * T25.G3.02: Choose the right variable type | * T08.G4.01: Use if/else for binary choices | * T25.G3.01: Map survey responses into list variables | * T25.G5.03: Decide when to upgrade from list to table | * T25.G3.06: Create a simple table in CreatiCode | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T25.G5.01: Model multi-type game state | * T25.G4.04: Document assumptions in a data key | * T25.G4.01: Build schema diagrams for simple apps | * T25.G5.03: Decide when to upgrade from list to table | * T25.G4.03: Compare dense vs sparse representations | * T25.G5.01: Model multi-type game state | * T25.G5.03: Decide when to upgrade from list to table | * T25.G5.04: Encode categorical values with symbols or enums | * T25.G5.02: Convert messy inputs into canonical formats | * T25.G5.06: Create and query tables using CreatiCode table blocks | * T25.G4.06: Populate tables from list data | * T25.G5.01: Model multi-type game state | * T25.G5.06: Create and query tables using CreatiCode table blocks | * T25.G5.01: Model multi-type game state | * T25.G5.03: Decide when to upgrade from list to table | * T25.G6.03: Nest structures (list of records, record of lists) | * T25.G5.01: Model multi-type game state | * T25.G5.04: Encode categorical values with symbols or enums | * T25.G6.01: Document metadata for datasets | * T25.G6.03: Nest structures (list of records, record of lists) | * T25.G5.04: Encode categorical values with symbols or enums | * T25.G6.06: Use server storage for persistence | * T25.G5.01: Model multi-type game state | * T25.G6.01: Document metadata for datasets | * T25.G6.02: Explain lossy vs lossless representation | * T25.G6.05: Query and filter table data | * T25.G6.06: Use server storage for persistence | * T25.G6.05: Query and filter table data | * T06.G6.01: Trace event execution paths in a multi‑event program | * T25.G6.01: Document metadata for datasets | * T25.G6.03: Nest structures (list of records, record of lists) | * T25.G7.01: Normalize repeating data into separate tables | * T25.G6.01: Document metadata for datasets | * T25.G7.02: Identify bias introduced by representation choices | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T25.G6.02: Explain lossy vs lossless representation | * T25.G7.04: Evaluate storage vs performance tradeoffs | * T25.G6.01: Document metadata for datasets | * T25.G7.03: Serialize and deserialize table data for persistence | * T25.G7.01: Normalize repeating data into separate tables | * T26.GK.01: Identify countable things in a picture | * T26.GK.01: Identify countable things in a picture | * T01.GK.01: Put pictures in order for getting ready for bed | * T26.GK.03: Capture yes/no answers with smile/frown cards | * T26.G1.01: Run a three-option picture survey | * T26.G1.01: Run a three-option picture survey | * T01.G1.01: Put pictures in order to plant a seed | * T26.G1.02: Keep observation logs over time | * T26.G1.01: Run a three-option picture survey | * T25.G1.02: Design a picture table | * T01.G1.01: Put pictures in order to plant a seed | * T26.G1.02: Keep observation logs over time | * T26.G1.01: Run a three-option picture survey | * T26.G2.02: Build a two-column record sheet | * T26.G2.04: Explain why sample size matters | * T01.G1.01: Put pictures in order to plant a seed | * T26.G2.01: Distinguish observational vs survey data | * T07.G3.01: Use a counted repeat loop | * T26.G3.01: Script a CreatiCode survey loop | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T26.G3.01: Script a CreatiCode survey loop | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T26.G3.03: Log sensor-style events with counters | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T26.G3.04: Separate raw data from summary data | * T08.G3.01: Use a simple if in a script | * T26.G3.01: Script a CreatiCode survey loop | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T26.G3.04: Separate raw data from summary data | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T26.G3.04: Separate raw data from summary data | * T08.G3.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T26.G4.02: Use tables to log multi-attribute events | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T26.G4.01: Create collection protocols for partners | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T26.G4.02: Use tables to log multi-attribute events | * T08.G3.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T26.G2.05: Conduct a multi-response tally survey | * T08.G4.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T26.G4.03: Track missing/invalid data with flags | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G4.02: Read and modify cells in a table | * T26.G5.01: Add print statements to track events during execution | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G4.02: Read and modify cells in a table | * T26.G5.04: Store logs in CreatiCode tables for export | * T09.G4.01: Create and use a numeric variable for score or count | * T10.G4.02: Read and modify cells in a table | * T26.G5.05: Save and load tables to/from CreatiCode cloud storage | * T10.G4.02: Read and modify cells in a table | * T23.G4.01: Detect faces and show bounding boxes | * T26.G5.04: Store logs in CreatiCode tables for export | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T26.G5.04: Store logs in CreatiCode tables for export | * T08.G4.01: Use a simple if in a script | * T09.G4.01: Create and use a numeric variable for score or count | * T09.G4.04: Trace code with variables to predict outcomes | * T10.G4.02: Read and modify cells in a table | * T26.G5.04: Store logs in CreatiCode tables for export | * T06.G4.01: Build a green-flag script that runs a 3-5 block sequence | * T09.G4.04: Trace code with variables to predict outcomes | * T10.G4.02: Read and modify cells in a table | * T26.G5.04: Store logs in CreatiCode tables for export | * T08.G4.01: Use a simple if in a script | * T09.G4.04: Trace code with variables to predict outcomes | * T10.G4.02: Read and modify cells in a table | * T26.G4.04: Reflect on privacy in collection | * T26.G6.01: Map stakeholder questions to data requirements | * T08.G4.01: Use a simple if in a script | * T09.G4.01: Create and use a numeric variable for score or count | * T09.G4.04: Trace code with variables to predict outcomes | * T10.G4.02: Read and modify cells in a table | * T26.G5.03: Validate data entry with error checks | * T10.G4.02: Read and modify cells in a table | * T26.G5.05: Save and load tables to/from CreatiCode cloud storage | * T26.G6.01: Map stakeholder questions to data requirements | * T10.G4.02: Read and modify cells in a table | * T26.G6.05: Insert data from tables into database collections | * T10.G4.02: Read and modify cells in a table | * T26.G5.04: Store logs in CreatiCode tables for export | * T10.G4.02: Read and modify cells in a table | * T26.G5.04: Store logs in CreatiCode tables for export | * T26.G6.07: Import data from Google Sheets into tables | * T10.G4.02: Read and modify cells in a table | * T26.G5.06: Record player scores and retrieve leaderboard data | * T26.G6.01: Map stakeholder questions to data requirements | * T06.G5.01: Build a green-flag script that runs a 3-5 block sequence | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G5.03: Add and remove items from a list | * T11.G5.02: Define a custom block with one parameter | * T26.G6.01: Map stakeholder questions to data requirements | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G5.03: Add and remove items from a list | * T26.G6.04: Note when measurements might be inaccurate | * T26.G7.01: Build reusable data collection modules | * T08.G5.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G5.03: Add and remove items from a list | * T26.G5.04: Store logs in CreatiCode tables for export | * T26.G6.03: Create consent and opt-out workflows with widget dialogs | * T08.G5.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G5.03: Add and remove items from a list | * T26.G5.02: Plan sampling strategies | * T26.G7.02: Monitor data quality in real time | * T26.G5.01: Add print statements to track events during execution | * T26.G5.04: Store logs in CreatiCode tables for export | * T10.G5.03: Add and remove items from a list | * T26.G6.07: Import data from Google Sheets into tables | * T26.G6.08: Export tables to Google Sheets | * T10.G5.03: Add and remove items from a list | * T26.G6.05: Insert data from tables into database collections | * T26.G6.06: Query database collections with filters and sorting | * T01.G6.01: Count comparisons in linear and binary search | * T06.G6.01: Trace event execution paths in a multi-event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T26.G7.01: Build reusable data collection modules | * T06.G6.01: Trace event execution paths in a multi-event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T26.G7.01: Build reusable data collection modules | * T26.G8.01: Design end-to-end telemetry pipelines with cloud integration | * T06.G6.01: Trace event execution paths in a multi-event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T24.G6.01: Use XO to generate code snippets | * T26.G8.01: Design end-to-end telemetry pipelines with cloud integration | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T26.G6.03: Create consent and opt-out workflows with widget dialogs | * T26.G7.04: Evaluate bias risks introduced during collection | * T10.G6.01: Sort a table by a column | * T24.G7.01: Generate text or ideas with AI prompts | * T26.G6.05: Insert data from tables into database collections | * T26.G6.06: Query database collections with filters and sorting | * T27.GK.01: Sort objects by a rule and explain it | * T27.GK.02: Compare which group has more | * T27.GK.03: Read a two-column picture chart | * T27.G1.01: Build a pictograph from tallies | * T27.G1.01: Build a pictograph from tallies | * T01.G1.01: Put pictures in order to plant a seed | * T27.G1.01: Build a pictograph from tallies | * T01.G1.01: Put pictures in order to plant a seed | * T27.G1.01: Build a pictograph from tallies | * T01.G1.10: Match pictures to ""if/then"" rules | * T27.G2.01: Create bar charts with axes labels | * T27.G1.03: Tell a one-sentence story with data | * T27.G2.02: Interpret simple line plots | * T27.G2.01: Create bar charts with axes labels | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T27.G3.01b: Create and populate data tables in CreatiCode | * T07.G3.01: Use a counted repeat loop | * T27.G3.01: Compute totals and averages from data tables | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T27.G3.01b: Create and populate data tables in CreatiCode | * T27.G3.02: Build comparison statements with evidence | * T27.G3.03: Use CreatiCode data tables to group and count | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T09.G3.05: Trace code with variables to predict outcomes | * T26.G3.04: Separate raw data from summary data | * T27.G3.04: Create side-by-side bar charts for two groups | * T27.G3.01: Compute totals and averages from data tables | * T27.G2.03: Identify outliers visually in small data sets | * T27.G4.02b: Understand median and mode concepts | * T08.G3.01: Use a simple if in a script | * T27.G4.02b: Understand median and mode concepts | * T27.G3.03: Use CreatiCode data tables to group and count | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T27.G3.03: Use CreatiCode data tables to group and count | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.05: Trace code with variables to predict outcomes | * T26.G3.04: Separate raw data from summary data | * T27.G3.03: Use CreatiCode data tables to group and count | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.05: Trace code with variables to predict outcomes | * T26.G3.04: Separate raw data from summary data | * T27.G4.01: Analyze change over time using line graphs | * T27.G4.02d: Filter table rows by condition | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T27.G4.02d: Filter table rows by condition | * T09.G3.05: Trace code with variables to predict outcomes | * T26.G3.04: Separate raw data from summary data | * T27.G4.04: Create narrative captions for charts | * T27.G4.04b: Sort tables to organize data | * T27.G3.01: Compute totals and averages from data tables | * T09.G4.01: Read multiple inputs via ask blocks and apply them in conditions | * T27.G4.01: Analyze change over time using line graphs | * T27.G4.02: Calculate percentages from grouped data | * T09.G4.01: Read multiple inputs via ask blocks and apply them in conditions | * T09.G3.05: Trace code with variables to predict outcomes | * T26.G3.04: Separate raw data from summary data | * T27.G5.02: Correlate two variables visually | * T09.G3.05: Trace code with variables to predict outcomes | * T26.G3.04: Separate raw data from summary data | * T27.G5.01: Build a simple interactive dashboard with filter widgets | * T27.G4.02d: Filter table rows by condition | * T09.G4.01: Read multiple inputs via ask blocks and apply them in conditions | * T09.G4.04: Trace code with variables to predict outcomes | * T26.G4.04: Plan a one-week observation schedule for a variable | * T27.G5.03: Compare data from two sensors or sources | * T27.G5.01b: Group data by category and compute statistics (GROUP BY) | * T09.G4.04: Trace code with variables to predict outcomes | * T08.G4.01: Use an if-else block with compound conditions | * T09.G4.04: Trace code with variables to predict outcomes | * T26.G4.04: Plan a one-week observation schedule for a variable | * T27.G6.01: Filter table rows using multiple conditions | * T27.G5.01b: Group data by category and compute statistics (GROUP BY) | * T10.G4.01: Use list length and item access in expressions | * T27.G5.02: Correlate two variables visually | * T27.G6.01: Filter table rows using multiple conditions | * T09.G4.04: Trace code with variables to predict outcomes | * T27.G6.01: Filter table rows using multiple conditions | * T06.G4.01: Sequence multiple sprite events | * T06.G4.01: Sequence multiple sprite events | * T09.G4.01: Read multiple inputs via ask blocks and apply them in conditions | * T09.G4.04: Trace code with variables to predict outcomes | * T26.G4.04: Plan a one-week observation schedule for a variable | * T27.G6.02: Compare two groups using data | * T10.G4.01: Use list length and item access in expressions | * T26.G5.04: Separate raw data from summary data | * T27.G6.03: Identify trends and patterns in time-series data | * T27.G6.04: Create structured summaries for AI input | * T27.G6.03b: Export and import data using CSV files | * T06.G5.01: Broadcast a custom message and respond in another sprite | * T08.G5.01: Use a simple if in a script | * T09.G5.01: Model real-world quantities using variables and formulas | * T26.G5.04: Separate raw data from summary data | * T27.G7.01: Build multi-chart dashboards with linked filters | * T27.G6.03: Identify trends and patterns in time-series data | * T27.G7.01: Build multi-chart dashboards with linked filters | * T10.G4.01: Use list length and item access in expressions | * T27.G7.01: Build multi-chart dashboards with linked filters | * T09.G6.01: Model real-world quantities using variables and formulas | * T08.G5.01: Use a simple if in a script | * T09.G5.01: Model real-world quantities using variables and formulas | * T26.G5.04: Separate raw data from summary data | * T27.G7.02: Compare predictions to actual outcomes | * T06.G5.01: Broadcast a custom message and respond in another sprite | * T10.G5.03: Add and remove items from a list | * T26.G5.04: Separate raw data from summary data | * T27.G7.03: Evaluate fairness metrics across user groups | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T26.G6.01: Map stakeholder questions to data requirements | * T27.G7.03: Evaluate fairness metrics across user groups | * T06.G6.01: Trace event execution paths in a multi‑event program | * T07.G6.01: Trace nested loops with variable bounds | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T26.G6.01: Map stakeholder questions to data requirements | * T27.G7.02c: Automate chart updates with variables | * T27.G8.01: Determine if differences are statistically meaningful | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T26.G6.01: Map stakeholder questions to data requirements | * T27.G8.02: Automate report generation | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T26.G6.01: Map stakeholder questions to data requirements | * T27.G8.03: Integrate data analysis into AI prompt engineering | * T01.G1.01: Put pictures in order to plant a seed | * T26.G1.01: Run a three-option picture survey | * T25.G1.01: Record data with tally marks | * T01.G1.10: Match pictures to ""if/then"" rules | * T28.G2.02: Conduct a picture-based chance experiment | * T01.G1.04: Predict the next step in a story sequence | * T28.G2.01: Sort events into certain / possible / impossible | * T07.G3.01: Use a counted repeat loop | * T28.G3.01: Interpret provided simulation output | * T28.G3.02: Explain what ""pick random"" does by testing predictions | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T28.G3.03: Record experimental data with teacher-provided blocks | * T28.G3.01: Interpret provided simulation output | * T28.G3.06: Modify a teacher-provided random generator | * T28.G3.02: Explain what ""pick random"" does by testing predictions | * T28.G3.03: Record experimental data with teacher-provided blocks | * T28.G3.06: Modify a teacher-provided random generator | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T28.G3.07: Assemble blocks to build a random generator | * T08.G3.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T28.G4.01: Build a simple random generator | * T07.G3.01: Use a counted repeat loop | * T10.G3.03: Add and remove items from a list | * T28.G4.02.01: Log trial results to a list | * T09.G3.05: Trace code with variables to predict outcomes | * T28.G4.02.02: Count frequencies of each outcome | * T28.G4.02.03: Calculate percentages from frequency counts | * T27.G3.04: Create side-by-side bar charts for two groups | * T28.G4.01: Build a simple random generator | * T09.G3.05: Trace code with variables to predict outcomes | * T28.G4.02.01: Log trial results to a list | * T03.G3.01: Navigate a sprite using coordinates | * T28.G4.02.03: Calculate percentages from frequency counts | * T28.G4.02.01: Log trial results to a list | * T10.G3.03: Add and remove items from a list | * T28.G4.02.03: Calculate percentages from frequency counts | * T28.G4.04: Debug an ""unfair"" simulation | * T28.G5.01.01: Generate compound event data (two dice) | * T27.G3.04: Create side-by-side bar charts for two groups | * T28.G4.02.03: Calculate percentages from frequency counts | * T28.G4.04: Debug an ""unfair"" simulation | * T28.G4.03: Show how sample size changes variability | * T28.G4.05: Generate and plot random coordinate pairs | * T08.G4.01: Choose actions based on user input or sensor values | * T05.G5.03: Identify variables and initial values for a simulation | * T05.G5.04: Draft simple update rules for a simulation | * T28.G4.03: Show how sample size changes variability | * T28.G4.04: Debug an ""unfair"" simulation | * T28.G4.06: Interpret probabilities as fractions and percentages | * T28.G5.05: Calculate theoretical probability for simple events | * T28.G4.03: Show how sample size changes variability | * T28.G5.01.02: Analyze compound event distributions | * T27.G4.02c: Calculate median and mode using code | * T28.G5.05: Calculate theoretical probability for simple events | * T28.G5.06: Compare experimental and theoretical probability | * T28.G5.06: Compare experimental and theoretical probability | * T28.G5.06: Compare experimental and theoretical probability | * T28.G4.03: Show how sample size changes variability | * T09.G4.04: Use variables to control animation or game state | * T09.G5.01: Modify variables based on user input or sensor events | * T03.G3.01: Navigate a sprite using coordinates | * T09.G4.04: Use variables to control animation or game state | * T09.G5.01: Modify variables based on user input or sensor events | * T28.G5.04: Document simulation plans before coding | * T28.G6.01.01: Manually test parameters and log results | * T07.G4.01: Loop until a goal condition is met | * T07.G5.01: Use a counted repeat loop | * T07.G5.01: Use a counted repeat loop | * T08.G4.01: Choose actions based on user input or sensor values | * T09.G4.04: Use variables to control animation or game state | * T09.G5.01: Modify variables based on user input or sensor events | * T28.G5.04: Document simulation plans before coding | * T28.G5.06: Compare experimental and theoretical probability | * T28.G5.04: Document simulation plans before coding | * T28.G5.03: Use Monte Carlo sampling to estimate area or probability | * T28.G5.04: Document simulation plans before coding | * T08.G4.01: Choose actions based on user input or sensor values | * T28.G5.08: Track position and state for a single sprite | * T28.G5.04: Document simulation plans before coding | * T28.G5.01.01: Generate compound event data (two dice) | * T28.G5.06: Compare experimental and theoretical probability | * T28.G5.02: Randomly assign participants to conditions | * T28.G5.11: Demonstrate the law of large numbers | * T28.G6.06: Simulate events with changing probabilities | * T28.G5.05: Calculate theoretical probability for simple events | * T28.G6.05: Model a simple agent in a grid world | * T08.G5.01: Use a simple if in a script | * T28.G6.07: Design an environment with obstacles and goals | * T09.G5.01: Modify variables based on user input or sensor events | * T28.G6.05: Model a simple agent in a grid world | * T06.G5.01: Broadcast a custom message and respond in another sprite | * T28.G6.09: Create simple two-sprite interaction | * T28.G6.08: Implement reward rules and track outcomes | * T28.G6.08: Implement reward rules and track outcomes | * T09.G5.05: Trace code with multiple variables | * T28.G6.04: Simulate noisy sensors for AI perception testing | * T28.G6.08: Implement reward rules and track outcomes | * T09.G5.05: Trace code with multiple variables | * T28.G7.03: Test for fairness using synthetic game testers | * T28.G6.10: Compare sampling methods (random, systematic, stratified) | * T28.G6.01.02: Automate parameter sweeps with nested loops | * T09.G5.05: Trace code with multiple variables | * T28.G7.01: Create a two-agent interaction simulation | * T09.G5.05: Trace code with multiple variables | * T28.G7.01: Create a two-agent interaction simulation | * T28.G7.06.01: Create multi-agent simulation | * T10.G6.01: Sort a table by a column | * T28.G6.01.02: Automate parameter sweeps with nested loops | * T28.G7.05: Communicate simulation assumptions and limitations | * T09.G6.01: Model real-world quantities using variables and formulas | * T28.G6.02: Use random seeds for reproducibility | * T28.G7.07: Identify bias in random selection methods | * T28.G6.01.02: Automate parameter sweeps with nested loops | * T28.G7.05: Communicate simulation assumptions and limitations | * T09.G6.01: Model real-world quantities using variables and formulas | * T28.G7.05: Communicate simulation assumptions and limitations | * T09.G6.01: Model real-world quantities using variables and formulas | * T28.G7.05: Communicate simulation assumptions and limitations | * T28.G8.03: Integrate simulations into AI assistant workflows | * T09.G6.01: Model real-world quantities using variables and formulas | * T28.G6.01.02: Automate parameter sweeps with nested loops | * T28.G7.05: Communicate simulation assumptions & limits | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T29.GK.01: Recognize text vs pictures | * T29.GK.01: Recognize text vs pictures | * T29.GK.02: Identify letters in text | * T29.GK.03: Recognize that text has meaning | * T29.GK.03: Recognize that text has meaning | * T29.G1.02: Count words in a sentence | * T29.G1.02: Count words in a sentence | * T29.G1.04: Identify same words in different sentences | * T29.G1.02: Count words in a sentence | * T29.G1.02: Count words in a sentence | * T29.G2.03: Distinguish sentences from word lists | * T29.G1.04: Identify same words in different sentences | * T29.G2.04: Find and replace words in sentences | * T29.G3.01: Distinguish text data from numbers and pictures | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T29.G3.02: Count word occurrences using variables | * T29.G3.03: Group words by category (emotion, action, place) | * T29.G3.04: Explain why clean text helps AI helpers | * T29.G4.01.01: Compare human vs AI summaries (conceptual) | * T08.G3.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T29.G3.04: Explain why clean text helps AI helpers | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T29.G4.02: Use split and join blocks for text manipulation | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T29.G4.02: Use split and join blocks for text manipulation | * T10.G3.03: Add and remove items from a list | * T29.G4.02: Use split and join blocks for text manipulation | * T08.G3.01: Use a simple if in a script | * T29.G4.02: Use split and join blocks for text manipulation | * T09.G3.05: Trace code with variables to predict outcomes | * T29.G4.06.01: Convert text case using lowercase/uppercase operators | * T07.G3.03: Trace code with simple loops to predict outcomes | * T10.G3.03: Add and remove items from a list | * T29.G4.03: Access individual characters using ""letter # of"" operator | * T07.G3.03: Trace code with simple loops to predict outcomes | * T29.G4.06.02: Remove punctuation using replace or character filtering | * T07.G3.03: Trace code with simple loops to predict outcomes | * T08.G3.01: Use a simple if in a script | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G3.03: Add and remove items from a list | * T29.G4.05: Test if text includes, starts with, or ends with a pattern | * T07.G3.03: Trace code with simple loops to predict outcomes | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T29.G4.02: Use split and join blocks for text manipulation | * T29.G4.08: Count words and report the most frequent | * T29.G5.01: Design table schemas for text data (chat logs) | * T11.G5.01: Create and populate a table | * T08.G4.02: Write scripts combining sequencing, loops, and conditionals | * T29.G4.08: Count words and report the most frequent | * T11.G5.01: Create and populate a table | * T29.G5.03: Build stop-word filters and keyword lists | * T11.G5.01: Create and populate a table | * T29.G5.04.01: Create positive/negative sentiment word lists | * T08.G4.01: Choose actions based on user input or sensor values | * T29.G5.02: Populate data tables from text using split | * T09.G4.04: Use variables to control animation or game state | * T29.G4.02: Use split and join blocks for text manipulation | * T29.G4.08: Count words and report the most frequent | * T29.G4.06.01: Convert text case using lowercase/uppercase operators | * T29.G5.03: Build stop-word filters and keyword lists | * T29.G4.04: Count characters and words using ""length of"" and split | * T08.G4.01: Choose actions based on user input or sensor values | * T09.G4.04: Use variables to control animation or game state | * T10.G4.03: Add, remove, and access items from a list in a script | * T29.G5.03: Build stop-word filters and keyword lists | * T11.G5.01: Create and populate a table | * T07.G4.01: Loop until a goal condition is met | * T09.G4.04: Use variables to control animation or game state | * T10.G4.03: Add, remove, and access items from a list in a script | * T29.G6.02: Compute n-gram (bigram) frequencies | * T06.G4.01: Write scripts that respond to keyboard or mouse events | * T09.G4.04: Use variables to control animation or game state | * T10.G4.03: Add, remove, and access items from a list in a script | * T29.G5.02: Populate data tables from text using split | * T29.G5.05: Build dynamic prompts with join and concatenation | * T11.G5.01: Create and populate a table | * T07.G4.01: Loop until a goal condition is met | * T09.G4.04: Use variables to control animation or game state | * T10.G4.03: Add, remove, and access items from a list in a script | * T29.G5.03: Build stop-word filters and keyword lists | * T29.G5.06: Use the analyze sentence block for parts of speech | * T29.G5.02: Populate data tables from text using split | * T29.G5.07: Trim whitespace from text input | * T29.G4.02: Use split and join blocks for text manipulation | * T29.G4.04: Count characters and words using ""length of"" and split | * T29.G6.01: Compare characters, words, and token counts | * T29.G5.03: Build stop-word filters and keyword lists | * T29.G6.02: Compute n-gram (bigram) frequencies | * T29.G6.03: Create autocomplete suggestions from bigrams | * T11.G6.01: Sort a table by a column | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G5.03: Add and remove items from a list | * T29.G5.04.02: Score text using sentiment word lists | * T29.G6.01: Compare characters, words, and token counts | * T29.G6.04: Log AI prompts/responses with ratings and timestamps | * T22.G6.01: Train a simple ML model (supervised learning) | * T09.G3.05: Trace code with variables to predict outcomes | * T10.G5.03: Add and remove items from a list | * T29.G5.04.02: Score text using sentiment word lists | * T29.G6.01: Compare characters, words, and token counts | * T29.G6.04: Log AI prompts/responses with ratings and timestamps | * T29.G4.01.02: Generate AI summaries using ChatGPT blocks | * T29.G5.05: Build dynamic prompts with join and concatenation | * T29.G6.03: Create autocomplete suggestions from bigrams | * T29.G6.04: Log AI prompts/responses with ratings and timestamps | * T29.G6.04: Log AI prompts/responses with ratings and timestamps | * T29.G5.02: Populate data tables from text using split | * T11.G6.01: Sort a table by a column | * T29.G5.04.02: Score text using sentiment word lists | * T29.G7.03: Audit text datasets for bias and coverage | * T29.G7.01: Build keyword retrieval helpers (mini-RAG) | * T29.G7.03: Audit text datasets for bias and coverage | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T29.G7.02: Engineer text features for ML classifiers | * T29.G7.03: Audit text datasets for bias and coverage | * T22.G7.01: Evaluate ML model performance with test data | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T29.G7.01: Build keyword retrieval helpers (mini-RAG) | * T29.G7.03: Audit text datasets for bias and coverage | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T29.G7.03: Audit text datasets for bias and coverage | * T29.G7.04: Critically annotate AI vs human summaries | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T30.GK.01: Identify everyday computing devices | * T30.GK.02: Match devices to actions | * T30.GK.01: Identify everyday computing devices | * T30.G1.01: Label basic computer parts | * T30.G1.01: Label basic computer parts | * T30.G1.01: Label basic computer parts | * T30.G1.02: Describe hardware vs software | * T01.G1.01: Put pictures in order to plant a seed | * T30.GK.03: Recognize input vs output examples | * T30.G1.01: Label basic computer parts | * T01.G1.01: Put pictures in order to plant a seed | * T30.G1.01: Label basic computer parts | * T01.G1.07: Decide if two algorithms finish with the same result | * T30.G1.01: Label basic computer parts | * T01.G1.01: Put pictures in order to plant a seed | * T30.G1.03: Recognize sensors in the environment | * T30.GK.03: Recognize input vs output examples | * T30.G2.01: Explain core internal components | * T30.G2.02: Trace input → process → output | * T30.G1.01: Label basic computer parts | * T30.G3.02: Describe peripheral ports and accessories | * T30.G2.05: Identify common device sensors and their inputs | * T30.G2.02: Trace input → process → output | * T30.G2.05: Identify common device sensors and their inputs | * T30.G2.02: Trace input → process → output | * T30.G2.02: Trace input → process → output | * T30.G3.01: Connect project ideas to required sensors/actuators | * T30.G3.01: Connect project ideas to required sensors/actuators | * T30.G3.02: Describe peripheral ports and accessories | * T30.G2.03: Compare wired vs wireless connections | * T30.G3.01: Connect project ideas to required sensors/actuators | * T30.G3.01: Connect project ideas to required sensors/actuators | * T08.G3.01: Use a simple if in a script | * T30.G3.05: Access device camera in CreatiCode projects | * T30.G4.05: Respond to keyboard and mouse events in CreatiCode | * T30.G4.01: Trace data flow in CreatiCode AI projects | * T30.G4.02: Explain how device performance affects project responsiveness | * T30.G4.04: Explore accessibility hardware | * T30.G2.04: Share best practices for caring for devices | * T30.G4.01: Trace data flow in CreatiCode AI projects | * T30.G4.02: Explain how device performance affects project responsiveness | * T30.G5.01: Identify device requirements for CreatiCode AI features | * T30.G4.04: Explore accessibility hardware | * T30.G4.05: Respond to keyboard and mouse events in CreatiCode | * T30.G3.01: Connect project ideas to required sensors/actuators | * T30.G4.05: Respond to keyboard and mouse events in CreatiCode | * T30.G5.05: Configure 3D cameras for CreatiCode game scenes | * T30.G3.05: Access device camera in CreatiCode projects | * T30.G4.06: Detect device capabilities in CreatiCode projects | * T30.G5.03: Explain how different sensors collect data | * T30.G5.01: Identify device requirements for CreatiCode AI features | * T30.G5.01: Identify device requirements for CreatiCode AI features | * T30.G3.03: Compare CreatiCode cloud save vs local export options | * T30.G5.02: Plan safe device-handling procedures for group work | * T30.G3.05: Access device camera in CreatiCode projects | * T30.G3.06: Access device microphone for audio input | * T30.G5.01: Identify device requirements for CreatiCode AI features | * T30.G5.03: Explain how different sensors collect data | * T30.G3.06: Access device microphone for audio input | * T30.G5.01: Identify device requirements for CreatiCode AI features | * T30.G3.05: Access device camera in CreatiCode projects | * T30.G5.05: Configure 3D cameras for CreatiCode game scenes | * T30.G6.05: Use speech recognition in voice-controlled CreatiCode projects | * T30.G5.06: Use face detection in CreatiCode interactive projects | * T30.G4.05: Respond to keyboard and mouse events in CreatiCode | * T30.G6.06: Implement hand and 2D body tracking in CreatiCode projects | * T30.G5.05: Configure 3D cameras for CreatiCode game scenes | * T30.G5.05.01: Enable mouse picking and hovering for 3D objects | * T30.G6.06: Implement hand and 2D body tracking in CreatiCode projects | * T30.G6.01: Analyze sensor specifications for CreatiCode projects | * T30.G6.04: Plan device capability checklists for CreatiCode AI projects | * T30.G6.01: Analyze sensor specifications for CreatiCode projects | * T30.G6.04: Plan device capability checklists for CreatiCode AI projects | * T30.G7.02: Design redundancy and fail-safes for CreatiCode sensors | * T30.G6.04: Plan device capability checklists for CreatiCode AI projects | * T30.G6.04: Plan device capability checklists for CreatiCode AI projects | * T30.G6.01: Analyze sensor specifications for CreatiCode projects | * T30.G6.03: Explain camera and microphone privacy permissions | * T30.G5.03: Explain how different sensors collect data | * T30.G4.05: Respond to keyboard and mouse events in CreatiCode | * T30.G5.05: Configure 3D cameras for CreatiCode game scenes | * T30.G4.06: Detect device capabilities in CreatiCode projects | * T30.G7.03: Plan graceful degradation strategies | * T30.G7.04: Explain cloud vs edge processing in CreatiCode AI projects | * T30.G7.01: Monitor and optimize CreatiCode project performance | * T30.G7.01: Monitor and optimize CreatiCode project performance | * T30.G7.04: Explain cloud vs edge processing in CreatiCode AI projects | * T30.G7.02: Design redundancy and fail-safes for CreatiCode sensors | * T30.G7.03: Plan graceful degradation strategies | * T30.G8.03: Plan hardware integration tests | * T30.G7.02: Design redundancy and fail-safes for CreatiCode sensors | * T31.G2.01: Understand that the internet connects many computers (picture-based) | * T31.G2.01: Understand that the internet connects many computers (picture-based) | * T31.G3.01: Trace a simple path from device to website | * T31.G3.01: Trace a simple path from device to website | * T02.G3.01: Identify start, action, and end symbols | * T01.G3.01: Complete a simple script with missing blocks | * T30.G3.01: Connect project ideas to required sensors/actuators | * T31.G5.01: Trace how a device reaches an online service | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T31.G5.01: Trace how a device reaches an online service | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T31.G5.01: Trace how a device reaches an online service | * T08.G3.01: Use a simple if in a script | * T31.G5.04: Create and join a multiplayer game session | * T01.G3.01: Complete a simple script with missing blocks | * T01.G3.02: Match a story description to a code sequence | * T31.G5.01: Trace how a device reaches an online service | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T31.G5.03: Fetch and display a web page as markdown | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T31.G6.02: Read data from a Google Sheet cell | * T31.G6.03: Write data to a Google Sheet cell | * T31.G6.03: Write data to a Google Sheet cell | * T31.G5.01: Trace how a device reaches an online service | * T31.G5.02: Decide when apps need the internet vs work offline | * T31.G5.01: Trace how a device reaches an online service | * T31.G5.02: Decide when apps need the internet vs work offline | * T31.G5.04: Create and join a multiplayer game session | * T31.G5.05: Check multiplayer connection status | * T02.G3.01: Identify start, action, and end symbols in flowcharts | * T31.G5.01: Trace how a device reaches an online service | * T31.G6.06: Add sprites to multiplayer game world | * T31.G6.06: Add sprites to multiplayer game world | * T31.G7.02: Synchronize sprite movement in multiplayer games | * T31.G7.02: Synchronize sprite movement in multiplayer games | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T31.G5.04: Create and join a multiplayer game session | * T31.G7.02.03: Insert data into a database collection | * T31.G7.02.04: Fetch data from a database collection | * T31.G6.01: Trace the steps of an HTTP/HTTPS request | * T31.G7.03: Compare network topology options | * T31.G6.05: Evaluate privacy when sharing AI-generated content and data | * T31.G7.04: Client-server vs peer-to-peer architecture | * T02.G6.01: Design a flowchart for a simple guessing game | * T31.G6.01: Trace the steps of an HTTP/HTTPS request | * T31.G7.04: Client-server vs peer-to-peer architecture | * T31.G7.05: Analyze societal impacts of networked systems | * T31.G7.04: Client-server vs peer-to-peer architecture | * T31.G7.05: Analyze societal impacts of networked systems | * T31.G8.01: Architect edge vs cloud processing pipelines for AI | * T31.G7.04: Client-server vs peer-to-peer architecture | * T31.G7.05: Analyze societal impacts of networked systems | * T31.G8.02: Understand AI service network requirements | * T31.G7.05: Analyze societal impacts of networked systems | * T31.G8.03: Design secure AI-powered cloud systems | * T31.G8.02: Understand AI service network requirements | * T31.G8.03: Design secure AI-powered cloud systems | * T31.G8.04: Implement privacy protection for AI data | * T31.G8.05: Evaluate AI service resilience and fallbacks | * T32.GK.01: Spot safe vs unsafe sharing | * T32.GK.01: Spot safe vs unsafe sharing | * T32.GK.01: Spot safe vs unsafe sharing | * T01.GK.03: Find the first and last pictures | * T32.GK.01: Spot safe vs unsafe sharing | * T32.G1.01: Identify personally identifiable information (PII) | * T32.G1.01: Identify personally identifiable information (PII) | * T32.GK.03: Understand that passwords keep things safe | * T32.G1.01: Identify personally identifiable information (PII) | * T01.G1.01: Put pictures in order to plant a seed | * T32.G1.03: Explain why passwords must be secret | * T01.G1.01: Put pictures in order to plant a seed | * T03.G1.03: List steps for a simple classroom routine | * T01.G1.01: Put pictures in order to plant a seed | * T01.G1.01: Put pictures in order to plant a seed | * T03.G1.03: List steps for a simple classroom routine | * T32.G1.04: Spot obvious scam pop-ups | * T32.G2.01: Practice creating strong passwords | * T32.G2.06: Explain purpose of usernames and passwords | * T32.G2.06: Explain purpose of usernames and passwords | * T07.G3.01: Use a counted repeat loop | * T32.G3.00: Identify parts of URLs and email addresses | * T32.G3.01: Explain multi-factor authentication (MFA) with analogies | * T32.G3.02: Recognize website safety indicators | * T32.G3.02: Recognize website safety indicators | * T32.G2.05: Recognize consequences of clicking suspicious links | * T32.G3.01: Explain multi-factor authentication (MFA) with analogies | * T32.G3.02: Recognize website safety indicators | * T32.G3.01: Explain multi-factor authentication (MFA) with analogies | * T01.G3.01: Complete a simple script with missing blocks | * T32.G4.02: Use password managers (conceptual) | * T32.G3.01: Explain multi-factor authentication (MFA) with analogies | * T32.G4.03: Understand data breaches through stories | * T32.G3.02: Recognize website safety indicators | * T32.G3.04: Recognize phishing-like messages | * T32.G4.01: Identify key principles of digital citizenship | * T32.G5.01.01: Analyze digital social engineering tactics | * T32.G3.03: Evaluate and use sharing settings in CreatiCode projects | * T32.G4.01: Identify key principles of digital citizenship | * T22.G5.02: Observe chatbot strengths and weaknesses | * T21.G5.02: Generate AI images with specific prompts | * T32.G5.02: Compare privacy policies of kid-friendly apps | * T32.G5.03.01: Review and identify PII in AI project data | * T32.G5.03.01: Review and identify PII in AI project data | * T32.G3.03: Evaluate and use sharing settings in CreatiCode projects | * T32.G5.03.03: Understand consent for AI data collection | * T32.G3.02: Recognize website safety indicators | * T32.G5.02: Compare privacy policies of kid-friendly apps | * T32.G4.03: Understand data breaches through stories | * T32.G5.01.01: Analyze digital social engineering tactics | * T32.G6.01.01: Identify common malware types | * T32.G6.01.01: Identify common malware types | * T32.G6.01.01: Identify common malware types | * T07.G3.01: Use a counted repeat loop | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T10.G3.01: Use a basic text (string) variable | * T16.G3.01: Create a simple UI with text and button widgets | * T32.G4.02: Use password managers (conceptual) | * T21.G6.02: Write structured prompts to get specific image styles | * T22.G6.01: Trace chatbot conversation flow | * T23.G5.01: Use camera blocks to detect objects | * T32.G5.01.01: Analyze digital social engineering tactics | * T32.G6.01.01: Identify common malware types | * T32.G6.01.01: Identify common malware types | * T32.G4.03: Understand data breaches through stories | * T10.G4.01: Concatenate strings to build messages | * T32.G5.06: Understand why encryption protects data (unplugged activity) | * T09.G5.01: Use multiple variables together in a single expression | * T10.G5.01: Extract substrings and manipulate text | * T32.G6.05: Explore simple cipher techniques with alphabet position lookup | * T32.G5.01.01: Analyze digital social engineering tactics | * T32.G5.02: Compare privacy policies of kid-friendly apps | * T32.G6.02: Design secure login flows in CreatiCode apps | * T07.G5.01: Use a counted repeat loop | * T12.G5.01: Store and retrieve structured data with tables | * T32.G5.04: Create backup plans for CreatiCode projects | * T32.G6.01.01: Identify common malware types | * T23.G6.01: Use camera to detect and track faces | * T32.G5.01.01: Analyze digital social engineering tactics | * T32.G5.03.01: Review and identify PII in AI project data | * T23.G6.02: Recognize gestures using pose detection | * T32.G5.02: Compare privacy policies of kid-friendly apps | * T32.G7.04.01: Analyze facial recognition technology ethics and societal impacts | * T04.G6.01: Group snippets by underlying algorithm pattern | * T32.G6.01.01: Identify common malware types | * T32.G6.04: Analyze ethical hacking vs malicious hacking through case studies | * T06.G6.01: Trace event execution paths in a multi-event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T32.G6.01.01: Identify common malware types | * T32.G6.02: Design secure login flows in CreatiCode apps | * T21.G6.04: Iterate on prompts based on generated results | * T22.G6.04: Debug chatbot logic with conditional responses | * T23.G6.03: Analyze perception system accuracy | * T24.G6.01: Integrate AI features into existing projects | * T32.G6.01.01: Identify common malware types | * T32.G6.03: Conduct AI-specific threat modeling for class projects | * T32.G8.03.01: Audit AI projects for security vulnerabilities | * T32.G7.04.01: Analyze facial recognition technology ethics and societal impacts | * T32.G7.04.02: Evaluate emotion detection and behavior analysis ethics | * T01.G6.01: Count comparisons in linear and binary search | * T32.G6.01.01: Identify common malware types | * T32.G7.03: Implement secure logging and monitoring in CreatiCode apps | * T32.G8.03.01: Audit AI projects for security vulnerabilities | * T32.G8.03.02: Audit AI projects for ethical concerns | * T33.GK.01: Recognize that apps can talk to helpers on the internet | * T33.G1.01: Sort apps into online helpers and offline tools | * T33.G2.01: Describe what happens when an app waits for the internet | * T31.G4.01: Identify the devices and wires in a local network | * T33.G3.01: Identify cloud-connected features in familiar apps | * T31.G5.01: Trace how a device reaches an online service | * T33.G4.01: Explain how apps store and retrieve data from the cloud | * T31.G5.01: Trace how a device reaches an online service | * T33.G5.01: Compare local storage versus cloud storage tradeoffs | * T31.G5.01: Trace how a device reaches an online service | * T33.G5.01: Compare local storage versus cloud storage tradeoffs | * T08.G4.01: Use if-else to choose between two outcomes | * T09.G4.04: Trace code with variables to predict outcomes | * T31.G5.01: Trace how a device reaches an online service | * T33.G5.01: Compare local storage versus cloud storage tradeoffs | * T33.G5.03: Understand that shared URLs grant public access | * T08.G4.01: Use if-else to choose between two outcomes | * T09.G4.01: Prompt user for input and store it in a variable | * T31.G5.01: Trace how a device reaches an online service | * T33.G5.03: Understand that shared URLs grant public access | * T33.G6.01: Identify and test Cloud blocks for network dependencies | * T08.G4.01: Use if-else to choose between two outcomes | * T10.G4.01: Create a list and populate it with items | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.01: Identify and test Cloud blocks for network dependencies | * T08.G4.01: Use if-else to choose between two outcomes | * T10.G4.01: Create a list and populate it with items | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.03: Read data from Google Sheets into a table | * T08.G4.01: Use if-else to choose between two outcomes | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.03: Read data from Google Sheets into a table | * T33.G6.04: Write data from a table to Google Sheets | * T08.G4.01: Use if-else to choose between two outcomes | * T09.G4.01: Prompt user for input and store it in a variable | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.02: Fetch web content using the fetch URL block | * T07.G4.01: Use repeat-until to loop based on a condition | * T09.G4.01: Prompt user for input and store it in a variable | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.06: Handle latency and error states in service calls | * T33.G5.03: Understand that shared URLs grant public access | * T33.G6.03: Read data from Google Sheets into a table | * T33.G6.04: Write data from a table to Google Sheets | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.03: Read data from Google Sheets into a table | * T08.G5.01: Use nested conditionals for multi-branch decisions | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.09: Understand cloud database collections versus Google Sheets | * T08.G5.01: Use nested conditionals for multi-branch decisions | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.03: Read data from Google Sheets into a table | * T33.G6.04: Write data from a table to Google Sheets | * T08.G5.01: Use nested conditionals for multi-branch decisions | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.03: Read data from Google Sheets into a table | * T33.G6.04: Write data from a table to Google Sheets | * T08.G5.01: Use nested conditionals for multi-branch decisions | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.04: Write data from a table to Google Sheets | * T33.G7.02: Perform targeted Google Sheets cell operations | * T08.G5.01: Use nested conditionals for multi-branch decisions | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.03: Read data from Google Sheets into a table | * T33.G6.06: Handle latency and error states in service calls | * T09.G5.01: Use multiple variables together in a single expression | * T31.G5.01: Trace how a device reaches an online service | * T33.G5.02: Distinguish real-time collaboration from one-time requests | * T33.G5.03: Understand that shared URLs grant public access | * T08.G5.01: Use nested conditionals for multi-branch decisions | * T31.G5.01: Trace how a device reaches an online service | * T33.G5.03: Understand that shared URLs grant public access | * T33.G6.03: Read data from Google Sheets into a table | * T06.G5.01: Identify standard event patterns in a small game | * T09.G5.01: Use multiple variables together in a single expression | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.02: Fetch web content using the fetch URL block | * T33.G6.04: Write data from a table to Google Sheets | * T33.G6.07: Respect usage limits and rate limiting | * T08.G5.01: Use nested conditionals for multi-branch decisions | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.06: Handle latency and error states in service calls | * T33.G6.07: Respect usage limits and rate limiting | * T09.G5.01: Use multiple variables together in a single expression | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.06: Handle latency and error states in service calls | * T08.G5.01: Use nested conditionals for multi-branch decisions | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G5.01: Trace how a device reaches an online service | * T33.G6.10: Insert and fetch data from cloud database collections | * T08.G5.01: Use nested conditionals for multi-branch decisions | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G5.01: Trace how a device reaches an online service | * T33.G7.10: Query cloud collections with WHERE conditions | * T08.G6.01: Use conditionals to control simulation steps | * T10.G5.01: Understand table structure (rows, columns, cells) | * T31.G6.01: Trace the steps of an HTTP/HTTPS request | * T33.G7.10: Query cloud collections with WHERE conditions | * T33.G7.11: Update and delete cloud collection data | * T08.G6.01: Use conditionals to control simulation steps | * T10.G6.01: Sort a table by a column | * T31.G6.01: Trace the steps of an HTTP/HTTPS request | * T33.G7.01: List, add, and remove sheets in a Google Spreadsheet | * T33.G7.02: Perform targeted Google Sheets cell operations | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T31.G6.01: Trace the steps of an HTTP/HTTPS request | * T33.G7.08: Compare service options and pick the right tool | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T31.G6.01: Trace the steps of an HTTP/HTTPS request | * T33.G7.08: Compare service options and pick the right tool | * T08.G6.01: Use conditionals to control simulation steps | * T09.G6.01: Model real-world quantities using variables and formulas | * T10.G6.01: Sort a table by a column | * T31.G6.01: Trace the steps of an HTTP/HTTPS request | * T33.G7.08: Compare service options and pick the right tool | * T06.G6.01: Trace event execution paths in a multi‑event program | * T09.G6.01: Model real-world quantities using variables and formulas | * T31.G6.01: Trace the steps of an HTTP/HTTPS request | * T33.G7.08: Compare service options and pick the right tool | * T06.G6.01: Trace event execution paths in a multi‑event program | * T10.G6.01: Sort a table by a column | * T31.G6.01: Trace the steps of an HTTP/HTTPS request | * T33.G7.07: Build workflows that combine multiple services | * T33.G8.04: Validate and sanitize data received from external services | * T34.GK.01: Spot computing tools in daily life | * T34.GK.02: Match old vs new versions of tech | * T34.GK.03: Name a person who uses computers in their job | * T34.G1.01: Describe life before and after a technology | * T34.G1.01: Describe life before and after a technology | * T01.G1.01: Put pictures in order to plant a seed | * T34.G1.01: Describe life before and after a technology | * T34.G1.02: Recognize inventors from diverse backgrounds | * T34.G1.02: Recognize inventors from diverse backgrounds | * T34.G2.01: Build ""then vs now"" comparison charts | * T34.G3.01: Sequence milestones on a timeline | * T34.G3.02: Connect computing milestones to everyday life | * T34.G3.01: Sequence milestones on a timeline | * T34.G3.02: Connect computing milestones to everyday life | * T34.G3.02: Connect computing milestones to everyday life | * T34.G3.03: Highlight underrepresented innovators | * T34.G3.03: Highlight underrepresented innovators | * T34.G4.01: Analyze cause/effect chains in computing history | * T34.G4.01: Analyze cause/effect chains in computing history | * T34.G4.02: Compare regional computing histories | * T34.G3.01: Sequence milestones on a timeline | * T34.G4.02: Compare regional computing histories | * T34.G2.03: Create mini-biographies of computing helpers | * T34.G3.03: Highlight underrepresented innovators | * T34.G4.01: Analyze cause/effect chains in computing history | * T34.G5.02: Compare invention timelines across industries | * T34.G5.01: Research 2-3 social movements where computing played a key role (e.g., civil rights data collection, open-source movement, accessibility advocacy) and present findings | * T34.G4.02: Compare regional computing histories | * T34.G5.01: Research 2-3 social movements where computing played a key role (e.g., civil rights data collection, open-source movement, accessibility advocacy) and present findings | * T34.G4.01: Analyze cause/effect chains in computing history | * T34.G5.01: Research 2-3 social movements where computing played a key role (e.g., civil rights data collection, open-source movement, accessibility advocacy) and present findings | * T34.G5.02: Compare invention timelines across industries | * T34.G6.01: Analyze major waves of computing (mainframe → personal computer → internet → mobile → AI), identifying what each wave made possible and what barriers remained | * T34.G5.01: Research 2-3 social movements where computing played a key role (e.g., civil rights data collection, open-source movement, accessibility advocacy) and present findings | * T34.G6.02: Evaluate historical inclusion and exclusion in computing, including how user interface evolution (command line → GUI → touchscreen → voice) has changed who can use computers | * T34.G5.03: Conduct interviews about technology changes | * T34.G6.03: Analyze historical computing failures (e.g., Therac-25, Y2K, failed AI systems) to identify lessons for preventing similar problems today | * T34.G6.01: Analyze major waves of computing (mainframe → personal computer → internet → mobile → AI), identifying what each wave made possible and what barriers remained | * T34.G7.01: Research AI history milestones | * T34.G6.01: Analyze major waves of computing (mainframe → personal computer → internet → mobile → AI), identifying what each wave made possible and what barriers remained | * T34.G7.02: Evaluate technology policies over time | * T34.G6.01: Analyze major waves of computing (mainframe → personal computer → internet → mobile → AI), identifying what each wave made possible and what barriers remained | * T34.G7.03: Create museum-style exhibits for innovators | * T01.GK.01: Put pictures in order for getting ready for bed | * T01.GK.01: Put pictures in order for getting ready for bed | * T35.GK.01: Identify a helpful use of technology | * T01.GK.01: Put pictures in order for getting ready for bed | * T01.GK.01: Put pictures in order for getting ready for bed | * T01.GK.01: Put pictures in order for getting ready for bed | * T35.G1.02: Match feelings to technology experiences | * T01.G1.07: Decide if two algorithms finish with the same result | * T01.G1.01: Put pictures in order to plant a seed | * T03.G1.03: List steps for a simple classroom routine | * T01.G1.01: Put pictures in order to plant a seed | * T35.G2.01: Compare benefits and harms of a tech tool | * T35.G2.01: Compare benefits and harms of a tech tool | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T16.G3.01: Add a label widget to display text | * T08.G3.01: Use a simple if in a script | * T35.G3.01: Evaluate digital footprints | * T08.G3.01: Use a simple if in a script | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T35.G3.01: Evaluate digital footprints | * T08.G3.01: Use a simple if in a script | * T16.G3.01: Add a label widget to display text | * T22.G3.01: Use ChatGPT blocks for simple queries | * T35.G3.01: Evaluate digital footprints | * T09.G3.01.04: Display variable value on stage using the variable monitor | * T16.G3.01: Add a label widget to display text | * T35.G3.01: Evaluate digital footprints | * T16.G4.01: Create interactive displays with widgets | * T35.G3.02: Discuss how algorithms influence what we see | * T16.G4.01: Create interactive displays with widgets | * T35.G3.03: Develop class guidelines for respectful communication | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T16.G4.01: Create interactive displays with widgets | * T35.G4.03.01: Test game accessibility features | * T22.G4.01: Use AI Speaker for text-to-speech | * T16.G4.01: Create interactive displays with widgets | * T35.G3.01: Evaluate digital footprints | * T35.G3.03: Develop class guidelines for respectful communication | * T06.G3.01: Build a green‑flag script that runs a 3–5 block sequence | * T35.G4.01: Analyze case studies of tech helping/harming communities | * T35.G4.01: Analyze case studies of tech helping/harming communities | * T35.G4.03.01: Test game accessibility features | * T35.G4.01: Analyze case studies of tech helping/harming communities | * T35.G4.02: Understand advertising/persuasion online | * T35.G5.03: Analyze AI's differential impacts on workers and communities | * T19.G5.01: Store data in a Google Sheet using blocks | * T16.G5.01: Build a simple survey using widgets | * T16.G6.01: Create forms with multiple widget types | * T35.G5.01: Examine global impacts of technology | * T35.G4.01: Analyze case studies of tech helping/harming communities | * T22.G6.01: Use ChatGPT for analysis tasks | * T35.G5.01: Examine global impacts of technology | * T35.G4.02: Understand advertising/persuasion online | * T16.G6.01: Create forms with multiple widget types | * T19.G6.01: Store and retrieve data from cloud tables | * T35.G6.02: Analyze data privacy tradeoffs | * T16.G6.01: Create forms with multiple widget types | * T19.G6.01: Store and retrieve data from cloud tables | * T35.G6.05.01: Build consent form and data collection | * T16.G6.01: Create forms with multiple widget types | * T19.G6.01: Store and retrieve data from cloud tables | * T35.G5.03: Analyze AI's differential impacts on workers and communities | * T35.G4.03.01: Test game accessibility features | * T21.G6.01: Generate images with AI (DALL-E blocks) | * T22.G6.01: Use ChatGPT for complex conversations | * T35.G6.03.01: Test AI content generation tools (T21-T22) | * T16.G6.01: Create forms with multiple widget types | * T35.G5.03: Analyze AI's differential impacts on workers and communities | * T23.G6.01: Use AI perception tools (hand/body tracking) | * T24.G6.01: Use AI coding assistants | * T35.G5.01: Examine global impacts of technology | * T35.G6.03.01: Test AI content generation tools (T21-T22) | * T35.G5.03: Analyze AI's differential impacts on workers and communities | * T35.G7.01: Conduct bias audits for AI content generation (T21-T22) | * T35.G6.03.03: Develop ethics guidelines for AI perception and assistance (T23-T24) | * T35.G6.01: Apply ethics lenses (beneficence, fairness, autonomy) | * T35.G6.02: Analyze data privacy tradeoffs | * T35.G5.02: Debate digital well-being scenarios | * T35.G6.02: Analyze data privacy tradeoffs | * T35.G6.03.03: Develop ethics guidelines for AI perception and assistance (T23-T24) | * T23.G7.01: Use hand and body tracking for interactive projects | * T35.G7.04.01: Build AI perception surveillance simulator | * T16.G7.01: Build interactive data displays with widgets | * T35.G6.03.01: Test AI content generation tools (T21-T22) | * T35.G5.03: Analyze AI's differential impacts on workers and communities | * T21.G7.01: Generate complex images with AI | * T16.G7.01: Build interactive data displays with widgets | * T35.G7.05.01: Experiment with AI-generated media | * T16.G7.01: Build interactive data displays with widgets | * T35.G6.04: Examine digital divide data | * T19.G7.01: Create data visualizations using table variables | * T16.G7.01: Build interactive data displays with widgets | * T35.G6.04: Examine digital divide data | * T35.G5.02: Debate digital well-being scenarios | * T35.G7.01: Conduct bias audits for AI content generation (T21-T22) | * T35.G6.01: Apply ethics lenses (beneficence, fairness, autonomy) | * T35.G8.01: Apply ethical frameworks to real proposals | * T35.G7.01: Conduct bias audits for AI content generation (T21-T22) | * T35.G7.06: Facilitate community discussions on AI-powered tech policy | * T35.G6.04: Examine digital divide data | * T35.G7.02: Explore unintended consequences of new tech | * T35.G6.01: Apply ethics lenses (beneficence, fairness, autonomy) | * T16.G8.01: Build complex multi-widget applications | * T22.G8.01: Use ChatGPT for advanced analysis | * T35.G8.03.01: Build impact assessment tool with scoring | * T16.G8.01: Build complex multi-widget applications | * T35.G7.06: Facilitate community discussions on AI-powered tech policy | * T35.G6.04: Examine digital divide data | * T01.GK.01: Answer what happens next in a sequence | * T36.GK.01: Match community helpers to digital tools | * T36.GK.01: Match community helpers to digital tools | * T36.GK.03: Describe what a digital tool helps someone do | * T36.G1.01: List jobs that rely on computers | * T03.GK.01: Identify parts that make up a whole | * T36.G1.01: List jobs that rely on computers | * T03.G1.03: List steps for a simple classroom routine | * T36.G2.01: Identify project roles in simple terms | * T36.G1.01: List jobs that rely on computers | * T36.GK.03: Describe what a digital tool helps someone do | * T36.G2.01: Identify project roles in simple terms | * T36.G3.01: Ask classmates simple questions to understand project needs | * T36.G3.02: Draft simple team agreements | * T36.G2.04: Name jobs where people create digital things | * T36.G3.04: Explore what coders and digital designers do | * T36.G3.01: Ask classmates simple questions to understand project needs | * T36.G3.02: Draft simple team agreements | * T36.G2.03: Recognize teammates' different strengths | * T36.G3.02: Draft simple team agreements | * T36.G3.03: Reflect on collaboration habits | * T36.G2.04: Name jobs where people create digital things | * T36.G4.01: Explore diverse tech careers via profiles/videos | * T36.G4.04: Categorize tech jobs by what they create | * T36.G4.01: Explore diverse tech careers via profiles/videos | * T36.G4.02: Track work with a shared checklist | * T36.G3.03: Reflect on collaboration habits | * T36.G4.01: Explore diverse tech careers via profiles/videos | * T36.G3.01: Ask classmates simple questions to understand project needs | * T36.G5.01: Map personal interests to tech pathways | * T36.G4.01: Explore diverse tech careers via profiles/videos | * T36.G5.03: Evaluate representation and inclusion in tech career stories | * T36.G5.01: Map personal interests to tech pathways | * T36.G5.02: Follow a plan-build-feedback cycle | * T36.G4.02: Track work with a shared checklist | * T36.G5.01: Map personal interests to tech pathways | * T36.G4.04: Categorize tech jobs by what they create | * T36.G5.02: Follow a plan-build-feedback cycle | * T36.G5.02: Follow a plan-build-feedback cycle | * T36.G5.01: Map personal interests to tech pathways | * T36.G6.01: Compare computing career clusters (software, hardware, data, AI) | * T36.G5.03: Evaluate representation and inclusion in tech career stories | * T36.G6.01: Compare computing career clusters (software, hardware, data, AI) | * T36.G6.01.01: Analyze representation in computing careers | * T36.G6.02: Practice stand-ups, task boards, and sprint reviews in team projects | * T36.G6.01: Compare computing career clusters (software, hardware, data, AI) | * T36.G5.02: Follow a plan-build-feedback cycle | * T36.G5.03: Evaluate representation and inclusion in tech career stories | * T36.G4.03: Role-play resolving disagreements in a coding or design project | * T36.G6.04: Add ethics clauses to team charters | * T36.G5.03: Evaluate representation and inclusion in tech career stories | * T36.G6.02: Practice stand-ups, task boards, and sprint reviews in team projects | * T36.G6.05: Document project contributions for a portfolio | * T36.G7.01.01: Research emerging tech careers and required skills | * T36.G6.01.02: Connect AI skills to career pathways | * T36.G6.05: Document project contributions for a portfolio | * T36.G6.03: Analyze job descriptions for skills/values | * T36.G7.04: Mentor younger coders | * T36.G6.01.02: Connect AI skills to career pathways | * T36.G7.01.02: Discuss AI ethics and equity with tech professionals | * T36.G8.03: Research AI's impact on job displacement vs augmentation | * T36.G6.01.01: Analyze representation in computing careers | * T36.G8.03.01: Analyze how AI impacts vary by community | * T36.G7.02: Design cross-functional team diagrams | * T36.G7.03: Facilitate inclusive collaboration | * T36.G6.02: Practice stand-ups, task boards, and sprint reviews in team projects"
